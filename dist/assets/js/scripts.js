/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 31);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(4)(function() {
  return (
    Object.defineProperty({}, "a", {
      get: function() {
        return 7;
      }
    }).a != 7
  );
});


/***/ }),
/* 1 */
/***/ (function(module, exports) {

var core = (module.exports = { version: "2.5.1" });
if (typeof __e == "number") __e = core; // eslint-disable-line no-undef


/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = function(it) {
  return typeof it === "object" ? it !== null : typeof it === "function";
};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(9);
var IE8_DOM_DEFINE = __webpack_require__(10);
var toPrimitive = __webpack_require__(11);
var dP = Object.defineProperty;

exports.f = __webpack_require__(0)
  ? Object.defineProperty
  : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return dP(O, P, Attributes);
        } catch (e) {
          /* empty */
        }
      if ("get" in Attributes || "set" in Attributes)
        throw TypeError("Accessors not supported!");
      if ("value" in Attributes) O[P] = Attributes.value;
      return O;
    };


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function(exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
(function(global, factory) {
  "use strict";

  if (typeof module === "object" && typeof module.exports === "object") {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document
      ? factory(global, true)
      : function(w) {
          if (!w.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w);
        };
  } else {
    factory(global);
  }

  // Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
  // enough that all such attempts are guarded in a try block.
  "use strict";

  var arr = [];

  var document = window.document;

  var getProto = Object.getPrototypeOf;

  var slice = arr.slice;

  var concat = arr.concat;

  var push = arr.push;

  var indexOf = arr.indexOf;

  var class2type = {};

  var toString = class2type.toString;

  var hasOwn = class2type.hasOwnProperty;

  var fnToString = hasOwn.toString;

  var ObjectFunctionString = fnToString.call(Object);

  var support = {};

  function DOMEval(code, doc) {
    doc = doc || document;

    var script = doc.createElement("script");

    script.text = code;
    doc.head.appendChild(script).parentNode.removeChild(script);
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module

  var version = "3.2.1",
    // Define a local copy of jQuery
    jQuery = function(selector, context) {
      // The jQuery object is actually just the init constructor 'enhanced'
      // Need init if jQuery is called (just allow error to be thrown if not included)
      return new jQuery.fn.init(selector, context);
    },
    // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([a-z])/g,
    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function(all, letter) {
      return letter.toUpperCase();
    };

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,

    constructor: jQuery,

    // The default length of a jQuery object is 0
    length: 0,

    toArray: function() {
      return slice.call(this);
    },

    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function(num) {
      // Return all the elements in a clean array
      if (num == null) {
        return slice.call(this);
      }

      // Return just the one element from the set
      return num < 0 ? this[num + this.length] : this[num];
    },

    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function(elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems);

      // Add the old object onto the stack (as a reference)
      ret.prevObject = this;

      // Return the newly-formed element set
      return ret;
    },

    // Execute a callback for every element in the matched set.
    each: function(callback) {
      return jQuery.each(this, callback);
    },

    map: function(callback) {
      return this.pushStack(
        jQuery.map(this, function(elem, i) {
          return callback.call(elem, i, elem);
        })
      );
    },

    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },

    first: function() {
      return this.eq(0);
    },

    last: function() {
      return this.eq(-1);
    },

    eq: function(i) {
      var len = this.length,
        j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },

    end: function() {
      return this.prevObject || this.constructor();
    },

    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function() {
    var options,
      name,
      src,
      copy,
      copyIsArray,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean") {
      deep = target;

      // Skip the boolean and the target
      target = arguments[i] || {};
      i++;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }

    // Extend jQuery itself if only one argument is passed
    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name];

          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }

          // Recurse if we're merging plain objects or arrays
          if (
            deep &&
            copy &&
            (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))
          ) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }

            // Never move original objects, clone them
            target[name] = jQuery.extend(deep, clone, copy);

            // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }

    // Return the modified object
    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

    // Assume jQuery is ready without the ready module
    isReady: true,

    error: function(msg) {
      throw new Error(msg);
    },

    noop: function() {},

    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },

    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },

    isNumeric: function(obj) {
      // As of jQuery 3.0, isNumeric is limited to
      // strings and numbers (primitives or objects)
      // that can be coerced to finite numbers (gh-2662)
      var type = jQuery.type(obj);
      return (
        (type === "number" || type === "string") &&
        // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj))
      );
    },

    isPlainObject: function(obj) {
      var proto, Ctor;

      // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects
      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }

      proto = getProto(obj);

      // Objects with no prototype (e.g., `Object.create( null )`) are plain
      if (!proto) {
        return true;
      }

      // Objects with prototype are plain iff they were constructed by a global Object function
      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return (
        typeof Ctor === "function" &&
        fnToString.call(Ctor) === ObjectFunctionString
      );
    },

    isEmptyObject: function(obj) {
      /* eslint-disable no-unused-vars */
      // See https://github.com/eslint/eslint/issues/6125
      var name;

      for (name in obj) {
        return false;
      }
      return true;
    },

    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }

      // Support: Android <=2.3 only (functionish RegExp)
      return typeof obj === "object" || typeof obj === "function"
        ? class2type[toString.call(obj)] || "object"
        : typeof obj;
    },

    // Evaluates a script in a global context
    globalEval: function(code) {
      DOMEval(code);
    },

    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 13
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },

    each: function(obj, callback) {
      var length,
        i = 0;

      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }

      return obj;
    },

    // Support: Android <=4.0 only
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },

    // results is for internal usage only
    makeArray: function(arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },

    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },

    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function(first, second) {
      var len = +second.length,
        j = 0,
        i = first.length;

      for (; j < len; j++) {
        first[i++] = second[j];
      }

      first.length = i;

      return first;
    },

    grep: function(elems, callback, invert) {
      var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;

      // Go through the array, only saving the items
      // that pass the validator function
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },

    // arg is for internal usage only
    map: function(elems, callback, arg) {
      var length,
        value,
        i = 0,
        ret = [];

      // Go through the array, translating each of the items to their new values
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }

        // Go through every key on the object,
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      }

      // Flatten any nested arrays
      return concat.apply([], ret);
    },

    // A global GUID counter for objects
    guid: 1,

    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function(fn, context) {
      var tmp, args, proxy;

      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }

      // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }

      // Simulated bind
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };

      // Set the guid of unique handler to the same of original handler, so it can be removed
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;

      return proxy;
    },

    now: Date.now,

    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });

  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  }

  // Populate the class2type map
  jQuery.each(
    "Boolean Number String Function Array Date RegExp Object Error Symbol".split(
      " "
    ),
    function(i, name) {
      class2type["[object " + name + "]"] = name.toLowerCase();
    }
  );

  function isArrayLike(obj) {
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
      type = jQuery.type(obj);

    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }

    return (
      type === "array" ||
      length === 0 ||
      (typeof length === "number" && length > 0 && length - 1 in obj)
    );
  }
  var Sizzle =
    /*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
    (function(window) {
      var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        // Local document vars
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        // Instance-specific data
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        // Instance methods
        hasOwn = {}.hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
        // https://jsperf.com/thor-indexof-vs-for/5
        indexOf = function(list, elem) {
          var i = 0,
            len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans =
          "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions

        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]",
        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes =
          "\\[" +
          whitespace +
          "*(" +
          identifier +
          ")(?:" +
          whitespace +
          // Operator (capture 2)
          "*([*^$|!~]?=)" +
          whitespace +
          // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" +
          identifier +
          "))|)" +
          whitespace +
          "*\\]",
        pseudos =
          ":(" +
          identifier +
          ")(?:\\((" +
          // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
          // 1. quoted (capture 3; capture 4 or capture 5)
          "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
          // 2. simple (capture 6)
          "((?:\\\\.|[^\\\\()[\\]]|" +
          attributes +
          ")*)|" +
          // 3. anything else (capture 2)
          ".*" +
          ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp(
          "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
          "g"
        ),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp(
          "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"
        ),
        rattributeQuotes = new RegExp(
          "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]",
          "g"
        ),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
              whitespace +
              "*(even|odd|(([+-]|)(\\d*)n|)" +
              whitespace +
              "*(?:([+-]|)" +
              whitespace +
              "*(\\d+)|))" +
              whitespace +
              "*\\)|)",
            "i"
          ),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp(
            "^" +
              whitespace +
              "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
              whitespace +
              "*((?:-\\d)?\\d*)" +
              whitespace +
              "*\\)|)(?=[^-]|$)",
            "i"
          )
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        // CSS escapes
        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp(
          "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)",
          "ig"
        ),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          // NaN means non-codepoint
          // Support: Firefox<24
          // Workaround erroneous numeric interpretation of +"0x"
          return high !== high || escapedWhitespace
            ? escaped
            : high < 0
              ? // BMP codepoint
                String.fromCharCode(high + 0x10000)
              : // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode(
                  (high >> 10) | 0xd800,
                  (high & 0x3ff) | 0xdc00
                );
        },
        // CSS string/identifier serialization
        // https://drafts.csswg.org/cssom/#common-serializing-idioms
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function(ch, asCodePoint) {
          if (asCodePoint) {
            // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
            if (ch === "\0") {
              return "\uFFFD";
            }

            // Control characters and (dependent upon position) numbers get escaped as code points
            return (
              ch.slice(0, -1) +
              "\\" +
              ch.charCodeAt(ch.length - 1).toString(16) +
              " "
            );
          }

          // Other potentially-special ASCII characters get backslash-escaped
          return "\\" + ch;
        },
        // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
          setDocument();
        },
        disabledAncestor = addCombinator(
          function(elem) {
            return (
              elem.disabled === true && ("form" in elem || "label" in elem)
            );
          },
          { dir: "parentNode", next: "legend" }
        );

      // Optimize for push.apply( _, NodeList )
      try {
        push.apply(
          (arr = slice.call(preferredDoc.childNodes)),
          preferredDoc.childNodes
        );
        // Support: Android<4.0
        // Detect silently failing push.apply
        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length
            ? // Leverage slice if possible
              function(target, els) {
                push_native.apply(target, slice.call(els));
              }
            : // Support: IE<9
              // Otherwise append directly
              function(target, els) {
                var j = target.length,
                  i = 0;
                // Can't trust NodeList.length
                while ((target[j++] = els[i++])) {}
                target.length = j - 1;
              }
        };
      }

      function Sizzle(selector, context, results, seed) {
        var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          // nodeType defaults to 9, since context defaults to document
          nodeType = context ? context.nodeType : 9;

        results = results || [];

        // Return early from calls with invalid selector or context
        if (
          typeof selector !== "string" ||
          !selector ||
          (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)
        ) {
          return results;
        }

        // Try to shortcut find operations (as opposed to filters) in HTML documents
        if (!seed) {
          if (
            (context ? context.ownerDocument || context : preferredDoc) !==
            document
          ) {
            setDocument(context);
          }
          context = context || document;

          if (documentIsHTML) {
            // If the selector is sufficiently simple, try using a "get*By*" DOM method
            // (excepting DocumentFragment context, where the methods don't exist)
            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
              // ID selector
              if ((m = match[1])) {
                // Document context
                if (nodeType === 9) {
                  if ((elem = context.getElementById(m))) {
                    // Support: IE, Opera, Webkit
                    // TODO: identify versions
                    // getElementById can match elements by name instead of ID
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  }

                  // Element context
                } else {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (
                    newContext &&
                    (elem = newContext.getElementById(m)) &&
                    contains(context, elem) &&
                    elem.id === m
                  ) {
                    results.push(elem);
                    return results;
                  }
                }

                // Type selector
              } else if (match[2]) {
                push.apply(results, context.getElementsByTagName(selector));
                return results;

                // Class selector
              } else if (
                (m = match[3]) &&
                support.getElementsByClassName &&
                context.getElementsByClassName
              ) {
                push.apply(results, context.getElementsByClassName(m));
                return results;
              }
            }

            // Take advantage of querySelectorAll
            if (
              support.qsa &&
              !compilerCache[selector + " "] &&
              (!rbuggyQSA || !rbuggyQSA.test(selector))
            ) {
              if (nodeType !== 1) {
                newContext = context;
                newSelector = selector;

                // qSA looks outside Element context, which is not what we want
                // Thanks to Andrew Dupont for this workaround technique
                // Support: IE <=8
                // Exclude object elements
              } else if (context.nodeName.toLowerCase() !== "object") {
                // Capture the context ID, setting it first if necessary
                if ((nid = context.getAttribute("id"))) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", (nid = expando));
                }

                // Prefix every selector in the list
                groups = tokenize(selector);
                i = groups.length;
                while (i--) {
                  groups[i] = "#" + nid + " " + toSelector(groups[i]);
                }
                newSelector = groups.join(",");

                // Expand context for sibling selectors
                newContext =
                  (rsibling.test(selector) &&
                    testContext(context.parentNode)) ||
                  context;
              }

              if (newSelector) {
                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
        }

        // All others
        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }

      /**
       * Create key-value caches of limited size
       * @returns {function(string, object)} Returns the Object data after storing it on itself with
       *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
       *	deleting the oldest entry
       */
      function createCache() {
        var keys = [];

        function cache(key, value) {
          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
          if (keys.push(key + " ") > Expr.cacheLength) {
            // Only keep the most recent entries
            delete cache[keys.shift()];
          }
          return (cache[key + " "] = value);
        }
        return cache;
      }

      /**
       * Mark a function for special use by Sizzle
       * @param {Function} fn The function to mark
       */
      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }

      /**
       * Support testing using an element
       * @param {Function} fn Passed the created element and returns a boolean result
       */
      function assert(fn) {
        var el = document.createElement("fieldset");

        try {
          return !!fn(el);
        } catch (e) {
          return false;
        } finally {
          // Remove from its parent by default
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          }
          // release memory in IE
          el = null;
        }
      }

      /**
       * Adds the same handler for all of the specified attrs
       * @param {String} attrs Pipe-separated list of attributes
       * @param {Function} handler The method that will be applied
       */
      function addHandle(attrs, handler) {
        var arr = attrs.split("|"),
          i = arr.length;

        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }

      /**
       * Checks document order of two siblings
       * @param {Element} a
       * @param {Element} b
       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
       */
      function siblingCheck(a, b) {
        var cur = b && a,
          diff =
            cur &&
            a.nodeType === 1 &&
            b.nodeType === 1 &&
            a.sourceIndex - b.sourceIndex;

        // Use IE sourceIndex if available on both nodes
        if (diff) {
          return diff;
        }

        // Check if b follows a
        if (cur) {
          while ((cur = cur.nextSibling)) {
            if (cur === b) {
              return -1;
            }
          }
        }

        return a ? 1 : -1;
      }

      /**
       * Returns a function to use in pseudos for input types
       * @param {String} type
       */
      function createInputPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
        };
      }

      /**
       * Returns a function to use in pseudos for buttons
       * @param {String} type
       */
      function createButtonPseudo(type) {
        return function(elem) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") && elem.type === type;
        };
      }

      /**
       * Returns a function to use in pseudos for :enabled/:disabled
       * @param {Boolean} disabled true for :disabled; false for :enabled
       */
      function createDisabledPseudo(disabled) {
        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
        return function(elem) {
          // Only certain elements can match :enabled or :disabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
          if ("form" in elem) {
            // Check for inherited disabledness on relevant non-disabled elements:
            // * listed form-associated elements in a disabled fieldset
            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
            // * option elements in a disabled optgroup
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
            // All such elements have a "form" property.
            if (elem.parentNode && elem.disabled === false) {
              // Option elements defer to a parent optgroup if present
              if ("label" in elem) {
                if ("label" in elem.parentNode) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              }

              // Support: IE 6 - 11
              // Use the isDisabled shortcut property to check for disabled fieldset ancestors
              return (
                elem.isDisabled === disabled ||
                // Where there is no isDisabled, check manually
                /* jshint -W018 */
                (elem.isDisabled !== !disabled &&
                  disabledAncestor(elem) === disabled)
              );
            }

            return elem.disabled === disabled;

            // Try to winnow out elements that can't be disabled before trusting the disabled property.
            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
            // even exist on them, let alone have a boolean value.
          } else if ("label" in elem) {
            return elem.disabled === disabled;
          }

          // Remaining elements are neither :enabled nor :disabled
          return false;
        };
      }

      /**
       * Returns a function to use in pseudos for positionals
       * @param {Function} fn
       */
      function createPositionalPseudo(fn) {
        return markFunction(function(argument) {
          argument = +argument;
          return markFunction(function(seed, matches) {
            var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;

            // Match elements found at the specified indexes
            while (i--) {
              if (seed[(j = matchIndexes[i])]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }

      /**
       * Checks a node for validity as a Sizzle context
       * @param {Element|Object=} context
       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
       */
      function testContext(context) {
        return (
          context &&
          typeof context.getElementsByTagName !== "undefined" &&
          context
        );
      }

      // Expose support vars for convenience
      support = Sizzle.support = {};

      /**
       * Detects XML nodes
       * @param {Element|Object} elem An element or a document
       * @returns {Boolean} True iff elem is a non-HTML XML node
       */
      isXML = Sizzle.isXML = function(elem) {
        // documentElement is verified for cases where it doesn't yet exist
        // (such as loading iframes in IE - #4833)
        var documentElement =
          elem && (elem.ownerDocument || elem).documentElement;
        return documentElement ? documentElement.nodeName !== "HTML" : false;
      };

      /**
       * Sets document-related variables once based on the current document
       * @param {Element|Object} [doc] An element or document object to use to set the document
       * @returns {Object} Returns the current document
       */
      setDocument = Sizzle.setDocument = function(node) {
        var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc;

        // Return early if doc is invalid or already selected
        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        }

        // Update global variables
        document = doc;
        docElem = document.documentElement;
        documentIsHTML = !isXML(document);

        // Support: IE 9-11, Edge
        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
        if (
          preferredDoc !== document &&
          (subWindow = document.defaultView) &&
          subWindow.top !== subWindow
        ) {
          // Support: IE 11, Edge
          if (subWindow.addEventListener) {
            subWindow.addEventListener("unload", unloadHandler, false);

            // Support: IE 9 - 10 only
          } else if (subWindow.attachEvent) {
            subWindow.attachEvent("onunload", unloadHandler);
          }
        }

        /* Attributes
	---------------------------------------------------------------------- */

        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)
        support.attributes = assert(function(el) {
          el.className = "i";
          return !el.getAttribute("className");
        });

        /* getElement(s)By*
	---------------------------------------------------------------------- */

        // Check if getElementsByTagName("*") returns only elements
        support.getElementsByTagName = assert(function(el) {
          el.appendChild(document.createComment(""));
          return !el.getElementsByTagName("*").length;
        });

        // Support: IE<9
        support.getElementsByClassName = rnative.test(
          document.getElementsByClassName
        );

        // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programmatically-set names,
        // so use a roundabout getElementsByName test
        support.getById = assert(function(el) {
          docElem.appendChild(el).id = expando;
          return (
            !document.getElementsByName ||
            !document.getElementsByName(expando).length
          );
        });

        // ID filter and find
        if (support.getById) {
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              return elem.getAttribute("id") === attrId;
            };
          };
          Expr.find["ID"] = function(id, context) {
            if (
              typeof context.getElementById !== "undefined" &&
              documentIsHTML
            ) {
              var elem = context.getElementById(id);
              return elem ? [elem] : [];
            }
          };
        } else {
          Expr.filter["ID"] = function(id) {
            var attrId = id.replace(runescape, funescape);
            return function(elem) {
              var node =
                typeof elem.getAttributeNode !== "undefined" &&
                elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          };

          // Support: IE 6 - 7 only
          // getElementById is not reliable as a find shortcut
          Expr.find["ID"] = function(id, context) {
            if (
              typeof context.getElementById !== "undefined" &&
              documentIsHTML
            ) {
              var node,
                i,
                elems,
                elem = context.getElementById(id);

              if (elem) {
                // Verify the id attribute
                node = elem.getAttributeNode("id");
                if (node && node.value === id) {
                  return [elem];
                }

                // Fall back on getElementsByName
                elems = context.getElementsByName(id);
                i = 0;
                while ((elem = elems[i++])) {
                  node = elem.getAttributeNode("id");
                  if (node && node.value === id) {
                    return [elem];
                  }
                }
              }

              return [];
            }
          };
        }

        // Tag
        Expr.find["TAG"] = support.getElementsByTagName
          ? function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);

                // DocumentFragment nodes don't have gEBTN
              } else if (support.qsa) {
                return context.querySelectorAll(tag);
              }
            }
          : function(tag, context) {
              var elem,
                tmp = [],
                i = 0,
                // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                results = context.getElementsByTagName(tag);

              // Filter out possible comments
              if (tag === "*") {
                while ((elem = results[i++])) {
                  if (elem.nodeType === 1) {
                    tmp.push(elem);
                  }
                }

                return tmp;
              }
              return results;
            };

        // Class
        Expr.find["CLASS"] =
          support.getElementsByClassName &&
          function(className, context) {
            if (
              typeof context.getElementsByClassName !== "undefined" &&
              documentIsHTML
            ) {
              return context.getElementsByClassName(className);
            }
          };

        /* QSA/matchesSelector
	---------------------------------------------------------------------- */

        // QSA and matchesSelector support

        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
        rbuggyMatches = [];

        // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See https://bugs.jquery.com/ticket/13378
        rbuggyQSA = [];

        if ((support.qsa = rnative.test(document.querySelectorAll))) {
          // Build QSA regex
          // Regex strategy adopted from Diego Perini
          assert(function(el) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // https://bugs.jquery.com/ticket/12359
            docElem.appendChild(el).innerHTML =
              "<a id='" +
              expando +
              "'></a>" +
              "<select id='" +
              expando +
              "-\r\\' msallowcapture=''>" +
              "<option selected=''></option></select>";

            // Support: IE8, Opera 11-12.16
            // Nothing should be selected when empty strings follow ^= or $= or *=
            // The test attribute must be unknown in Opera but "safe" for WinRT
            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
            if (el.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            }

            // Support: IE8
            // Boolean attributes and "value" are not treated correctly
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push(
                "\\[" + whitespace + "*(?:value|" + booleans + ")"
              );
            }

            // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }

            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }

            // Support: Safari 8+, iOS 8+
            // https://bugs.webkit.org/show_bug.cgi?id=136851
            // In-page `selector#id sibling-combinator selector` fails
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
          });

          assert(function(el) {
            el.innerHTML =
              "<a href='' disabled='disabled'></a>" +
              "<select disabled='disabled'><option/></select>";

            // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment
            var input = document.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D");

            // Support: IE8
            // Enforce case-sensitivity of name attribute
            if (el.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            }

            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests
            if (el.querySelectorAll(":enabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }

            // Support: IE9-11+
            // IE's :disabled selector does not pick up the children of disabled fieldsets
            docElem.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }

            // Opera 10-11 does not throw on post-comma invalid pseudos
            el.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }

        if (
          (support.matchesSelector = rnative.test(
            (matches =
              docElem.matches ||
              docElem.webkitMatchesSelector ||
              docElem.mozMatchesSelector ||
              docElem.oMatchesSelector ||
              docElem.msMatchesSelector)
          ))
        ) {
          assert(function(el) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call(el, "*");

            // This should fail with an exception
            // Gecko does not error, returns false instead
            matches.call(el, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches =
          rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

        /* Contains
	---------------------------------------------------------------------- */
        hasCompare = rnative.test(docElem.compareDocumentPosition);

        // Element contains another
        // Purposefully self-exclusive
        // As in, an element does not contain itself
        contains =
          hasCompare || rnative.test(docElem.contains)
            ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a,
                  bup = b && b.parentNode;
                return (
                  a === bup ||
                  !!(
                    bup &&
                    bup.nodeType === 1 &&
                    (adown.contains
                      ? adown.contains(bup)
                      : a.compareDocumentPosition &&
                        a.compareDocumentPosition(bup) & 16)
                  )
                );
              }
            : function(a, b) {
                if (b) {
                  while ((b = b.parentNode)) {
                    if (b === a) {
                      return true;
                    }
                  }
                }
                return false;
              };

        /* Sorting
	---------------------------------------------------------------------- */

        // Document order sorting
        sortOrder = hasCompare
          ? function(a, b) {
              // Flag for duplicate removal
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }

              // Sort on method existence if only one input has compareDocumentPosition
              var compare =
                !a.compareDocumentPosition - !b.compareDocumentPosition;
              if (compare) {
                return compare;
              }

              // Calculate position if both inputs belong to the same document
              compare =
                (a.ownerDocument || a) === (b.ownerDocument || b)
                  ? a.compareDocumentPosition(b)
                  : // Otherwise we know they are disconnected
                    1;

              // Disconnected nodes
              if (
                compare & 1 ||
                (!support.sortDetached &&
                  b.compareDocumentPosition(a) === compare)
              ) {
                // Choose the first element that is related to our preferred document
                if (
                  a === document ||
                  (a.ownerDocument === preferredDoc &&
                    contains(preferredDoc, a))
                ) {
                  return -1;
                }
                if (
                  b === document ||
                  (b.ownerDocument === preferredDoc &&
                    contains(preferredDoc, b))
                ) {
                  return 1;
                }

                // Maintain original order
                return sortInput
                  ? indexOf(sortInput, a) - indexOf(sortInput, b)
                  : 0;
              }

              return compare & 4 ? -1 : 1;
            }
          : function(a, b) {
              // Exit early if the nodes are identical
              if (a === b) {
                hasDuplicate = true;
                return 0;
              }

              var cur,
                i = 0,
                aup = a.parentNode,
                bup = b.parentNode,
                ap = [a],
                bp = [b];

              // Parentless nodes are either documents or disconnected
              if (!aup || !bup) {
                return a === document
                  ? -1
                  : b === document
                    ? 1
                    : aup
                      ? -1
                      : bup
                        ? 1
                        : sortInput
                          ? indexOf(sortInput, a) - indexOf(sortInput, b)
                          : 0;

                // If the nodes are siblings, we can do a quick check
              } else if (aup === bup) {
                return siblingCheck(a, b);
              }

              // Otherwise we need full lists of their ancestors for comparison
              cur = a;
              while ((cur = cur.parentNode)) {
                ap.unshift(cur);
              }
              cur = b;
              while ((cur = cur.parentNode)) {
                bp.unshift(cur);
              }

              // Walk down the tree looking for a discrepancy
              while (ap[i] === bp[i]) {
                i++;
              }

              return i
                ? // Do a sibling check if the nodes have a common ancestor
                  siblingCheck(ap[i], bp[i])
                : // Otherwise nodes in our document sort first
                  ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };

        return document;
      };

      Sizzle.matches = function(expr, elements) {
        return Sizzle(expr, null, null, elements);
      };

      Sizzle.matchesSelector = function(elem, expr) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }

        // Make sure that attribute selectors are quoted
        expr = expr.replace(rattributeQuotes, "='$1']");

        if (
          support.matchesSelector &&
          documentIsHTML &&
          !compilerCache[expr + " "] &&
          (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
          (!rbuggyQSA || !rbuggyQSA.test(expr))
        ) {
          try {
            var ret = matches.call(elem, expr);

            // IE 9's matchesSelector returns false on disconnected nodes
            if (
              ret ||
              support.disconnectedMatch ||
              // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              (elem.document && elem.document.nodeType !== 11)
            ) {
              return ret;
            }
          } catch (e) {}
        }

        return Sizzle(expr, document, null, [elem]).length > 0;
      };

      Sizzle.contains = function(context, elem) {
        // Set document vars if needed
        if ((context.ownerDocument || context) !== document) {
          setDocument(context);
        }
        return contains(context, elem);
      };

      Sizzle.attr = function(elem, name) {
        // Set document vars if needed
        if ((elem.ownerDocument || elem) !== document) {
          setDocument(elem);
        }

        var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
          val =
            fn && hasOwn.call(Expr.attrHandle, name.toLowerCase())
              ? fn(elem, name, !documentIsHTML)
              : undefined;

        return val !== undefined
          ? val
          : support.attributes || !documentIsHTML
            ? elem.getAttribute(name)
            : (val = elem.getAttributeNode(name)) && val.specified
              ? val.value
              : null;
      };

      Sizzle.escape = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };

      Sizzle.error = function(msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };

      /**
       * Document sorting and removing duplicates
       * @param {ArrayLike} results
       */
      Sizzle.uniqueSort = function(results) {
        var elem,
          duplicates = [],
          j = 0,
          i = 0;

        // Unless we *know* we can detect duplicates, assume their presence
        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);

        if (hasDuplicate) {
          while ((elem = results[i++])) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }
          while (j--) {
            results.splice(duplicates[j], 1);
          }
        }

        // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225
        sortInput = null;

        return results;
      };

      /**
       * Utility function for retrieving the text value of an array of DOM nodes
       * @param {Array|Element} elem
       */
      getText = Sizzle.getText = function(elem) {
        var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

        if (!nodeType) {
          // If no nodeType, this is expected to be an array
          while ((node = elem[i++])) {
            // Do not traverse comment nodes
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (jQuery #11153)
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            // Traverse its children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        }
        // Do not include comment or processing instruction nodes

        return ret;
      };

      Expr = Sizzle.selectors = {
        // Can be adjusted by the user
        cacheLength: 50,

        createPseudo: markFunction,

        match: matchExpr,

        attrHandle: {},

        find: {},

        relative: {
          ">": { dir: "parentNode", first: true },
          " ": { dir: "parentNode" },
          "+": { dir: "previousSibling", first: true },
          "~": { dir: "previousSibling" }
        },

        preFilter: {
          ATTR: function(match) {
            match[1] = match[1].replace(runescape, funescape);

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = (match[3] || match[4] || match[5] || "").replace(
              runescape,
              funescape
            );

            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }

            return match.slice(0, 4);
          },

          CHILD: function(match) {
            /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
            match[1] = match[1].toLowerCase();

            if (match[1].slice(0, 3) === "nth") {
              // nth-* requires argument
              if (!match[3]) {
                Sizzle.error(match[0]);
              }

              // numeric x and y parameters for Expr.filter.CHILD
              // remember that false/true cast respectively to 0/1
              match[4] = +(match[4]
                ? match[5] + (match[6] || 1)
                : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +(match[7] + match[8] || match[3] === "odd");

              // other types prohibit arguments
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }

            return match;
          },

          PSEUDO: function(match) {
            var excess,
              unquoted = !match[6] && match[2];

            if (matchExpr["CHILD"].test(match[0])) {
              return null;
            }

            // Accept quoted arguments as-is
            if (match[3]) {
              match[2] = match[4] || match[5] || "";

              // Strip excess characters from unquoted arguments
            } else if (
              unquoted &&
              rpseudo.test(unquoted) &&
              // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) &&
              // advance to the next closing parenthesis
              (excess =
                unquoted.indexOf(")", unquoted.length - excess) -
                unquoted.length)
            ) {
              // excess is a negative index
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice(0, 3);
          }
        },

        filter: {
          TAG: function(nodeNameSelector) {
            var nodeName = nodeNameSelector
              .replace(runescape, funescape)
              .toLowerCase();
            return nodeNameSelector === "*"
              ? function() {
                  return true;
                }
              : function(elem) {
                  return (
                    elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                  );
                };
          },

          CLASS: function(className) {
            var pattern = classCache[className + " "];

            return (
              pattern ||
              ((pattern = new RegExp(
                "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)"
              )) &&
                classCache(className, function(elem) {
                  return pattern.test(
                    (typeof elem.className === "string" && elem.className) ||
                      (typeof elem.getAttribute !== "undefined" &&
                        elem.getAttribute("class")) ||
                      ""
                  );
                }))
            );
          },

          ATTR: function(name, operator, check) {
            return function(elem) {
              var result = Sizzle.attr(elem, name);

              if (result == null) {
                return operator === "!=";
              }
              if (!operator) {
                return true;
              }

              result += "";

              return operator === "="
                ? result === check
                : operator === "!="
                  ? result !== check
                  : operator === "^="
                    ? check && result.indexOf(check) === 0
                    : operator === "*="
                      ? check && result.indexOf(check) > -1
                      : operator === "$="
                        ? check && result.slice(-check.length) === check
                        : operator === "~="
                          ? (
                              " " +
                              result.replace(rwhitespace, " ") +
                              " "
                            ).indexOf(check) > -1
                          : operator === "|="
                            ? result === check ||
                              result.slice(0, check.length + 1) === check + "-"
                            : false;
            };
          },

          CHILD: function(type, what, argument, first, last) {
            var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";

            return first === 1 && last === 0
              ? // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              : function(elem, context, xml) {
                  var cache,
                    uniqueCache,
                    outerCache,
                    node,
                    nodeIndex,
                    start,
                    dir =
                      simple !== forward ? "nextSibling" : "previousSibling",
                    parent = elem.parentNode,
                    name = ofType && elem.nodeName.toLowerCase(),
                    useCache = !xml && !ofType,
                    diff = false;

                  if (parent) {
                    // :(first|last|only)-(child|of-type)
                    if (simple) {
                      while (dir) {
                        node = elem;
                        while ((node = node[dir])) {
                          if (
                            ofType
                              ? node.nodeName.toLowerCase() === name
                              : node.nodeType === 1
                          ) {
                            return false;
                          }
                        }
                        // Reverse direction for :only-* (if we haven't yet done so)
                        start = dir =
                          type === "only" && !start && "nextSibling";
                      }
                      return true;
                    }

                    start = [forward ? parent.firstChild : parent.lastChild];

                    // non-xml :nth-child(...) stores cache data on `parent`
                    if (forward && useCache) {
                      // Seek `elem` from a previously-cached index

                      // ...in a gzip-friendly way
                      node = parent;
                      outerCache = node[expando] || (node[expando] = {});

                      // Support: IE <9 only
                      // Defend against cloned attroperties (jQuery gh-1709)
                      uniqueCache =
                        outerCache[node.uniqueID] ||
                        (outerCache[node.uniqueID] = {});

                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex && cache[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];

                      while (
                        (node =
                          (++nodeIndex && node && node[dir]) ||
                          // Fallback to seeking `elem` from the start
                          (diff = nodeIndex = 0) ||
                          start.pop())
                      ) {
                        // When found, cache indexes on `parent` and break
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          uniqueCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      // Use previously-cached element index if available
                      if (useCache) {
                        // ...in a gzip-friendly way
                        node = elem;
                        outerCache = node[expando] || (node[expando] = {});

                        // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)
                        uniqueCache =
                          outerCache[node.uniqueID] ||
                          (outerCache[node.uniqueID] = {});

                        cache = uniqueCache[type] || [];
                        nodeIndex = cache[0] === dirruns && cache[1];
                        diff = nodeIndex;
                      }

                      // xml :nth-child(...)
                      // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                      if (diff === false) {
                        // Use the same loop as above to seek `elem` from the start
                        while (
                          (node =
                            (++nodeIndex && node && node[dir]) ||
                            (diff = nodeIndex = 0) ||
                            start.pop())
                        ) {
                          if (
                            (ofType
                              ? node.nodeName.toLowerCase() === name
                              : node.nodeType === 1) &&
                            ++diff
                          ) {
                            // Cache the index of each encountered element
                            if (useCache) {
                              outerCache =
                                node[expando] || (node[expando] = {});

                              // Support: IE <9 only
                              // Defend against cloned attroperties (jQuery gh-1709)
                              uniqueCache =
                                outerCache[node.uniqueID] ||
                                (outerCache[node.uniqueID] = {});

                              uniqueCache[type] = [dirruns, diff];
                            }

                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }

                    // Incorporate the offset, then check against cycle size
                    diff -= last;
                    return (
                      diff === first ||
                      (diff % first === 0 && diff / first >= 0)
                    );
                  }
                };
          },

          PSEUDO: function(pseudo, argument) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
              fn =
                Expr.pseudos[pseudo] ||
                Expr.setFilters[pseudo.toLowerCase()] ||
                Sizzle.error("unsupported pseudo: " + pseudo);

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if (fn[expando]) {
              return fn(argument);
            }

            // But maintain support for old signatures
            if (fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())
                ? markFunction(function(seed, matches) {
                    var idx,
                      matched = fn(seed, argument),
                      i = matched.length;
                    while (i--) {
                      idx = indexOf(seed, matched[i]);
                      seed[idx] = !(matches[idx] = matched[i]);
                    }
                  })
                : function(elem) {
                    return fn(elem, 0, args);
                  };
            }

            return fn;
          }
        },

        pseudos: {
          // Potentially complex pseudos
          not: markFunction(function(selector) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));

            return matcher[expando]
              ? markFunction(function(seed, matches, context, xml) {
                  var elem,
                    unmatched = matcher(seed, null, xml, []),
                    i = seed.length;

                  // Match elements unmatched by `matcher`
                  while (i--) {
                    if ((elem = unmatched[i])) {
                      seed[i] = !(matches[i] = elem);
                    }
                  }
                })
              : function(elem, context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  // Don't keep the element (issue #299)
                  input[0] = null;
                  return !results.pop();
                };
          }),

          has: markFunction(function(selector) {
            return function(elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),

          contains: markFunction(function(text) {
            text = text.replace(runescape, funescape);
            return function(elem) {
              return (
                (elem.textContent || elem.innerText || getText(elem)).indexOf(
                  text
                ) > -1
              );
            };
          }),

          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // http://www.w3.org/TR/selectors/#lang-pseudo
          lang: markFunction(function(lang) {
            // lang value must be a valid identifier
            if (!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }
            lang = lang.replace(runescape, funescape).toLowerCase();
            return function(elem) {
              var elemLang;
              do {
                if (
                  (elemLang = documentIsHTML
                    ? elem.lang
                    : elem.getAttribute("xml:lang") ||
                      elem.getAttribute("lang"))
                ) {
                  elemLang = elemLang.toLowerCase();
                  return (
                    elemLang === lang || elemLang.indexOf(lang + "-") === 0
                  );
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);
              return false;
            };
          }),

          // Miscellaneous
          target: function(elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },

          root: function(elem) {
            return elem === docElem;
          },

          focus: function(elem) {
            return (
              elem === document.activeElement &&
              (!document.hasFocus || document.hasFocus()) &&
              !!(elem.type || elem.href || ~elem.tabIndex)
            );
          },

          // Boolean properties
          enabled: createDisabledPseudo(false),
          disabled: createDisabledPseudo(true),

          checked: function(elem) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return (
              (nodeName === "input" && !!elem.checked) ||
              (nodeName === "option" && !!elem.selected)
            );
          },

          selected: function(elem) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if (elem.parentNode) {
              elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
          },

          // Contents
          empty: function(elem) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }
            return true;
          },

          parent: function(elem) {
            return !Expr.pseudos["empty"](elem);
          },

          // Element/input types
          header: function(elem) {
            return rheader.test(elem.nodeName);
          },

          input: function(elem) {
            return rinputs.test(elem.nodeName);
          },

          button: function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (
              (name === "input" && elem.type === "button") || name === "button"
            );
          },

          text: function(elem) {
            var attr;
            return (
              elem.nodeName.toLowerCase() === "input" &&
              elem.type === "text" &&
              // Support: IE<8
              // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null ||
                attr.toLowerCase() === "text")
            );
          },

          // Position-in-collection
          first: createPositionalPseudo(function() {
            return [0];
          }),

          last: createPositionalPseudo(function(matchIndexes, length) {
            return [length - 1];
          }),

          eq: createPositionalPseudo(function(matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),

          even: createPositionalPseudo(function(matchIndexes, length) {
            var i = 0;
            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          odd: createPositionalPseudo(function(matchIndexes, length) {
            var i = 1;
            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          lt: createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (; --i >= 0; ) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          }),

          gt: createPositionalPseudo(function(matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;
            for (; ++i < length; ) {
              matchIndexes.push(i);
            }
            return matchIndexes;
          })
        }
      };

      Expr.pseudos["nth"] = Expr.pseudos["eq"];

      // Add button/input type pseudos
      for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }
      for (i in { submit: true, reset: true }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      }

      // Easy API for creating new setFilters
      function setFilters() {}
      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();

      tokenize = Sizzle.tokenize = function(selector, parseOnly) {
        var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];

        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while (soFar) {
          // Comma and first run
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              // Don't consume trailing commas as valid
              soFar = soFar.slice(match[0].length) || soFar;
            }
            groups.push((tokens = []));
          }

          matched = false;

          // Combinators
          if ((match = rcombinators.exec(soFar))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              // Cast descendant combinators to space
              type: match[0].replace(rtrim, " ")
            });
            soFar = soFar.slice(matched.length);
          }

          // Filters
          for (type in Expr.filter) {
            if (
              (match = matchExpr[type].exec(soFar)) &&
              (!preFilters[type] || (match = preFilters[type](match)))
            ) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }

          if (!matched) {
            break;
          }
        }

        // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens
        return parseOnly
          ? soFar.length
          : soFar
            ? Sizzle.error(selector)
            : // Cache the tokens
              tokenCache(selector, groups).slice(0);
      };

      function toSelector(tokens) {
        var i = 0,
          len = tokens.length,
          selector = "";
        for (; i < len; i++) {
          selector += tokens[i].value;
        }
        return selector;
      }

      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;

        return combinator.first
          ? // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            }
          : // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache,
                uniqueCache,
                outerCache,
                newCache = [dirruns, doneName];

              // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
              if (xml) {
                while ((elem = elem[dir])) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while ((elem = elem[dir])) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});

                    // Support: IE <9 only
                    // Defend against cloned attroperties (jQuery gh-1709)
                    uniqueCache =
                      outerCache[elem.uniqueID] ||
                      (outerCache[elem.uniqueID] = {});

                    if (skip && skip === elem.nodeName.toLowerCase()) {
                      elem = elem[dir] || elem;
                    } else if (
                      (oldCache = uniqueCache[key]) &&
                      oldCache[0] === dirruns &&
                      oldCache[1] === doneName
                    ) {
                      // Assign to newCache so results back-propagate to previous elements
                      return (newCache[2] = oldCache[2]);
                    } else {
                      // Reuse newcache so results back-propagate to previous elements
                      uniqueCache[key] = newCache;

                      // A match means we're done; a fail means we have to keep checking
                      if ((newCache[2] = matcher(elem, context, xml))) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            };
      }

      function elementMatcher(matchers) {
        return matchers.length > 1
          ? function(elem, context, xml) {
              var i = matchers.length;
              while (i--) {
                if (!matchers[i](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            }
          : matchers[0];
      }

      function multipleContexts(selector, contexts, results) {
        var i = 0,
          len = contexts.length;
        for (; i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }
        return results;
      }

      function condense(unmatched, map, filter, context, xml) {
        var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

        for (; i < len; i++) {
          if ((elem = unmatched[i])) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);
              if (mapped) {
                map.push(i);
              }
            }
          }
        }

        return newUnmatched;
      }

      function setMatcher(
        preFilter,
        selector,
        matcher,
        postFilter,
        postFinder,
        postSelector
      ) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }
        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }
        return markFunction(function(seed, results, context, xml) {
          var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
            elems =
              seed ||
              multipleContexts(
                selector || "*",
                context.nodeType ? [context] : context,
                []
              ),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn =
              preFilter && (seed || !selector)
                ? condense(elems, preMap, preFilter, context, xml)
                : elems,
            matcherOut = matcher
              ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || (seed ? preFilter : preexisting || postFilter)
                ? // ...intermediate processing is necessary
                  []
                : // ...otherwise use results directly
                  results
              : matcherIn;

          // Find primary matches
          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          }

          // Apply postFilter
          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml);

            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while (i--) {
              if ((elem = temp[i])) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }

          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;
                while (i--) {
                  if ((elem = matcherOut[i])) {
                    // Restore matcherIn since elem is not yet a final match
                    temp.push((matcherIn[i] = elem));
                  }
                }
                postFinder(null, (matcherOut = []), temp, xml);
              }

              // Move matched elements from seed to results to keep them synchronized
              i = matcherOut.length;
              while (i--) {
                if (
                  (elem = matcherOut[i]) &&
                  (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1
                ) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            }

            // Add elements to results, through postFinder if defined
          } else {
            matcherOut = condense(
              matcherOut === results
                ? matcherOut.splice(preexisting, matcherOut.length)
                : matcherOut
            );
            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }

      function matcherFromTokens(tokens) {
        var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
          matchContext = addCombinator(
            function(elem) {
              return elem === checkContext;
            },
            implicitRelative,
            true
          ),
          matchAnyContext = addCombinator(
            function(elem) {
              return indexOf(checkContext, elem) > -1;
            },
            implicitRelative,
            true
          ),
          matchers = [
            function(elem, context, xml) {
              var ret =
                (!leadingRelative && (xml || context !== outermostContext)) ||
                ((checkContext = context).nodeType
                  ? matchContext(elem, context, xml)
                  : matchAnyContext(elem, context, xml));
              // Avoid hanging onto element (issue #299)
              checkContext = null;
              return ret;
            }
          ];

        for (; i < len; i++) {
          if ((matcher = Expr.relative[tokens[i].type])) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(
              null,
              tokens[i].matches
            );

            // Return special upon seeing a positional matcher
            if (matcher[expando]) {
              // Find the next relative operator (if any) for proper handling
              j = ++i;
              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }
              return setMatcher(
                i > 1 && elementMatcher(matchers),
                i > 1 &&
                  toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens
                      .slice(0, i - 1)
                      .concat({ value: tokens[i - 2].type === " " ? "*" : "" })
                  ).replace(rtrim, "$1"),
                matcher,
                i < j && matcherFromTokens(tokens.slice(i, j)),
                j < len && matcherFromTokens((tokens = tokens.slice(j))),
                j < len && toSelector(tokens)
              );
            }
            matchers.push(matcher);
          }
        }

        return elementMatcher(matchers);
      }

      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
              j,
              matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed && [],
              setMatched = [],
              contextBackup = outermostContext,
              // We must always have either seed elements or outermost context
              elems = seed || (byElement && Expr.find["TAG"]("*", outermost)),
              // Use integer dirruns iff this is the outermost matcher
              dirrunsUnique = (dirruns +=
                contextBackup == null ? 1 : Math.random() || 0.1),
              len = elems.length;

            if (outermost) {
              outermostContext = context === document || context || outermost;
            }

            // Add elements passing elementMatchers directly to results
            // Support: IE<9, Safari
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }

              // Track unmatched elements for set filters
              if (bySet) {
                // They will have gone through all possible matchers
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }

                // Lengthen the array for every element, matched or not
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }

            // `i` is now the count of elements visited above, and adding it to `matchedCount`
            // makes the latter nonnegative.
            matchedCount += i;

            // Apply set filters to unmatched elements
            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
            // no element matchers and no seed.
            // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
            // case, which will result in a "00" `matchedCount` that differs from `i` but is also
            // numerically zero.
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }

              if (seed) {
                // Reintegrate element matches to eliminate the need for sorting
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }

                // Discard index placeholder values to get only actual matches
                setMatched = condense(setMatched);
              }

              // Add matches to results
              push.apply(results, setMatched);

              // Seedless set matches succeeding multiple successful matchers stipulate sorting
              if (
                outermost &&
                !seed &&
                setMatched.length > 0 &&
                matchedCount + setMatchers.length > 1
              ) {
                Sizzle.uniqueSort(results);
              }
            }

            // Override manipulation of globals by nested matchers
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }

            return unmatched;
          };

        return bySet ? markFunction(superMatcher) : superMatcher;
      }

      compile = Sizzle.compile = function(
        selector,
        match /* Internal Use Only */
      ) {
        var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

        if (!cached) {
          // Generate a function of recursive functions that can be used to check each element
          if (!match) {
            match = tokenize(selector);
          }
          i = match.length;
          while (i--) {
            cached = matcherFromTokens(match[i]);
            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          }

          // Cache the compiled function
          cached = compilerCache(
            selector,
            matcherFromGroupMatchers(elementMatchers, setMatchers)
          );

          // Save selector and tokenization
          cached.selector = selector;
        }
        return cached;
      };

      /**
       * A low-level selection function that works with Sizzle's compiled
       *  selector functions
       * @param {String|Function} selector A selector or a pre-compiled
       *  selector function built with Sizzle.compile
       * @param {Element} context
       * @param {Array} [results]
       * @param {Array} [seed] A set of elements to match against
       */
      select = Sizzle.select = function(selector, context, results, seed) {
        var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));

        results = results || [];

        // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)
        if (match.length === 1) {
          // Reduce context if the leading compound selector is an ID
          tokens = match[0] = match[0].slice(0);
          if (
            tokens.length > 2 &&
            (token = tokens[0]).type === "ID" &&
            context.nodeType === 9 &&
            documentIsHTML &&
            Expr.relative[tokens[1].type]
          ) {
            context = (Expr.find["ID"](
              token.matches[0].replace(runescape, funescape),
              context
            ) || [])[0];
            if (!context) {
              return results;

              // Precompiled matchers will still verify ancestry, so step up a level
            } else if (compiled) {
              context = context.parentNode;
            }

            selector = selector.slice(tokens.shift().value.length);
          }

          // Fetch a seed set for right-to-left matching
          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];

            // Abort if we hit a combinator
            if (Expr.relative[(type = token.type)]) {
              break;
            }
            if ((find = Expr.find[type])) {
              // Search, expanding context for leading sibling combinators
              if (
                (seed = find(
                  token.matches[0].replace(runescape, funescape),
                  (rsibling.test(tokens[0].type) &&
                    testContext(context.parentNode)) ||
                    context
                ))
              ) {
                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }

                break;
              }
            }
          }
        }

        // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above
        (compiled || compile(selector, match))(
          seed,
          context,
          !documentIsHTML,
          results,
          !context ||
            (rsibling.test(selector) && testContext(context.parentNode)) ||
            context
        );
        return results;
      };

      // One-time assignments

      // Sort stability
      support.sortStable =
        expando
          .split("")
          .sort(sortOrder)
          .join("") === expando;

      // Support: Chrome 14-35+
      // Always assume duplicates if they aren't passed to the comparison function
      support.detectDuplicates = !!hasDuplicate;

      // Initialize against the default document
      setDocument();

      // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
      // Detached nodes confoundingly follow *each other*
      support.sortDetached = assert(function(el) {
        // Should return 1, but returns 4 (following)
        return (
          el.compareDocumentPosition(document.createElement("fieldset")) & 1
        );
      });

      // Support: IE<8
      // Prevent attribute/property "interpolation"
      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
      if (
        !assert(function(el) {
          el.innerHTML = "<a href='#'></a>";
          return el.firstChild.getAttribute("href") === "#";
        })
      ) {
        addHandle("type|href|height|width", function(elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(
              name,
              name.toLowerCase() === "type" ? 1 : 2
            );
          }
        });
      }

      // Support: IE<9
      // Use defaultValue in place of getAttribute("value")
      if (
        !support.attributes ||
        !assert(function(el) {
          el.innerHTML = "<input/>";
          el.firstChild.setAttribute("value", "");
          return el.firstChild.getAttribute("value") === "";
        })
      ) {
        addHandle("value", function(elem, name, isXML) {
          if (!isXML && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      }

      // Support: IE<9
      // Use getAttributeNode to fetch booleans when getAttribute lies
      if (
        !assert(function(el) {
          return el.getAttribute("disabled") == null;
        })
      ) {
        addHandle(booleans, function(elem, name, isXML) {
          var val;
          if (!isXML) {
            return elem[name] === true
              ? name.toLowerCase()
              : (val = elem.getAttributeNode(name)) && val.specified
                ? val.value
                : null;
          }
        });
      }

      return Sizzle;
    })(window);

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;

  // Deprecated
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;

  var dir = function(elem, dir, until) {
    var matched = [],
      truncate = until !== undefined;

    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };

  var siblings = function(n, elem) {
    var matched = [];

    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }

    return matched;
  };

  var rneedsContext = jQuery.expr.match.needsContext;

  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }
  var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

  var risSimple = /^.[^:#\[\.,]*$/;

  // Implement the identical functionality for filter and not
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }

    // Single element
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }

    // Arraylike of elements (jQuery, arguments, Array)
    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function(elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    }

    // Simple selector that can be filtered directly, removing non-Elements
    if (risSimple.test(qualifier)) {
      return jQuery.filter(qualifier, elements, not);
    }

    // Complex selector, compare the two sets, removing non-Elements
    qualifier = jQuery.filter(qualifier, elements);
    return jQuery.grep(elements, function(elem) {
      return indexOf.call(qualifier, elem) > -1 !== not && elem.nodeType === 1;
    });
  }

  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }

    return jQuery.find.matches(
      expr,
      jQuery.grep(elems, function(elem) {
        return elem.nodeType === 1;
      })
    );
  };

  jQuery.fn.extend({
    find: function(selector) {
      var i,
        ret,
        len = this.length,
        self = this;

      if (typeof selector !== "string") {
        return this.pushStack(
          jQuery(selector).filter(function() {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self[i], this)) {
                return true;
              }
            }
          })
        );
      }

      ret = this.pushStack([]);

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(
        this,

        // If this is a positional/relative selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        typeof selector === "string" && rneedsContext.test(selector)
          ? jQuery(selector)
          : selector || [],
        false
      ).length;
    }
  });

  // Initialize a jQuery object

  // A central reference to the root jQuery(document)
  var rootjQuery,
    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
    init = (jQuery.fn.init = function(selector, context, root) {
      var match, elem;

      // HANDLE: $(""), $(null), $(undefined), $(false)
      if (!selector) {
        return this;
      }

      // Method init() accepts an alternate rootjQuery
      // so migrate can support jQuery.sub (gh-2101)
      root = root || rootjQuery;

      // Handle HTML strings
      if (typeof selector === "string") {
        if (
          selector[0] === "<" &&
          selector[selector.length - 1] === ">" &&
          selector.length >= 3
        ) {
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }

        // Match html or make sure no context is specified for #id
        if (match && (match[1] || !context)) {
          // HANDLE: $(html) -> $(array)
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;

            // Option to run scripts is true for back-compat
            // Intentionally let the error be thrown if parseHTML is not present
            jQuery.merge(
              this,
              jQuery.parseHTML(
                match[1],
                context && context.nodeType
                  ? context.ownerDocument || context
                  : document,
                true
              )
            );

            // HANDLE: $(html, props)
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                // Properties of context are called as methods if possible
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);

                  // ...and otherwise set as attributes
                } else {
                  this.attr(match, context[match]);
                }
              }
            }

            return this;

            // HANDLE: $(#id)
          } else {
            elem = document.getElementById(match[2]);

            if (elem) {
              // Inject the element directly into the jQuery object
              this[0] = elem;
              this.length = 1;
            }
            return this;
          }

          // HANDLE: $(expr, $(...))
        } else if (!context || context.jquery) {
          return (context || root).find(selector);

          // HANDLE: $(expr, context)
          // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor(context).find(selector);
        }

        // HANDLE: $(DOMElement)
      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this;

        // HANDLE: $(function)
        // Shortcut for document ready
      } else if (jQuery.isFunction(selector)) {
        return root.ready !== undefined
          ? root.ready(selector)
          : // Execute immediately if ready is not present
            selector(jQuery);
      }

      return jQuery.makeArray(selector, this);
    });

  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;

  // Initialize central reference
  rootjQuery = jQuery(document);

  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };

  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
        l = targets.length;

      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },

    closest: function(selectors, context) {
      var cur,
        i = 0,
        l = this.length,
        matched = [],
        targets = typeof selectors !== "string" && jQuery(selectors);

      // Positional selectors never match, since there's no _selection_ context
      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            // Always skip document fragments
            if (
              cur.nodeType < 11 &&
              (targets
                ? targets.index(cur) > -1
                : // Don't pass non-elements to Sizzle
                  cur.nodeType === 1 &&
                  jQuery.find.matchesSelector(cur, selectors))
            ) {
              matched.push(cur);
              break;
            }
          }
        }
      }

      return this.pushStack(
        matched.length > 1 ? jQuery.uniqueSort(matched) : matched
      );
    },

    // Determine the position of an element within the set
    index: function(elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode
          ? this.first().prevAll().length
          : -1;
      }

      // Index in selector
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }

      // Locate the position of the desired element
      return indexOf.call(
        this,

        // If it receives a jQuery object, the first element is used
        elem.jquery ? elem[0] : elem
      );
    },

    add: function(selector, context) {
      return this.pushStack(
        jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context)))
      );
    },

    addBack: function(selector) {
      return this.add(
        selector == null ? this.prevObject : this.prevObject.filter(selector)
      );
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }

  jQuery.each(
    {
      parent: function(elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function(elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function(elem, i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function(elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function(elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function(elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function(elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function(elem, i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function(elem, i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function(elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function(elem) {
        return siblings(elem.firstChild);
      },
      contents: function(elem) {
        if (nodeName(elem, "iframe")) {
          return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }

        return jQuery.merge([], elem.childNodes);
      }
    },
    function(name, fn) {
      jQuery.fn[name] = function(until, selector) {
        var matched = jQuery.map(this, fn, until);

        if (name.slice(-5) !== "Until") {
          selector = until;
        }

        if (selector && typeof selector === "string") {
          matched = jQuery.filter(selector, matched);
        }

        if (this.length > 1) {
          // Remove duplicates
          if (!guaranteedUnique[name]) {
            jQuery.uniqueSort(matched);
          }

          // Reverse order for parents* and prev-derivatives
          if (rparentsprev.test(name)) {
            matched.reverse();
          }
        }

        return this.pushStack(matched);
      };
    }
  );
  var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;

  // Convert String-formatted options into Object-formatted ones
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }

  /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
  jQuery.Callbacks = function(options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options =
      typeof options === "string"
        ? createOptions(options)
        : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
      firing,
      // Last fire value for non-forgettable lists
      memory,
      // Flag to know if list was already fired
      fired,
      // Flag to prevent firing
      locked,
      // Actual callback list
      list = [],
      // Queue of execution data for repeatable lists
      queue = [],
      // Index of currently firing callback (modified by add/remove as needed)
      firingIndex = -1,
      // Fire callbacks
      fire = function() {
        // Enforce single-firing
        locked = locked || options.once;

        // Execute callbacks for all pending executions,
        // respecting firingIndex overrides and runtime changes
        fired = firing = true;
        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();
          while (++firingIndex < list.length) {
            // Run callback and check for early termination
            if (
              list[firingIndex].apply(memory[0], memory[1]) === false &&
              options.stopOnFalse
            ) {
              // Jump to end and forget the data so .add doesn't re-fire
              firingIndex = list.length;
              memory = false;
            }
          }
        }

        // Forget the data if we're done with it
        if (!options.memory) {
          memory = false;
        }

        firing = false;

        // Clean up if we're done firing for good
        if (locked) {
          // Keep an empty list if we have data for future add calls
          if (memory) {
            list = [];

            // Otherwise, this object is spent
          } else {
            list = "";
          }
        }
      },
      // Actual Callbacks object
      self = {
        // Add a callback or a collection of callbacks to the list
        add: function() {
          if (list) {
            // If we have memory from a past run, we should fire after adding
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }

            (function add(args) {
              jQuery.each(args, function(_, arg) {
                if (jQuery.isFunction(arg)) {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                  // Inspect recursively
                  add(arg);
                }
              });
            })(arguments);

            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },

        // Remove a callback from the list
        remove: function() {
          jQuery.each(arguments, function(_, arg) {
            var index;
            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1);

              // Handle firing indexes
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },

        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function(fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },

        // Remove all callbacks from the list
        empty: function() {
          if (list) {
            list = [];
          }
          return this;
        },

        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function() {
          locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function() {
          return !list;
        },

        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function() {
          locked = queue = [];
          if (!memory && !firing) {
            list = memory = "";
          }
          return this;
        },
        locked: function() {
          return !!locked;
        },

        // Call all callbacks with the given context and arguments
        fireWith: function(context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },

        // Call all the callbacks with the given arguments
        fire: function() {
          self.fireWith(this, arguments);
          return this;
        },

        // To know if the callbacks have already been called at least once
        fired: function() {
          return !!fired;
        }
      };

    return self;
  };

  function Identity(v) {
    return v;
  }
  function Thrower(ex) {
    throw ex;
  }

  function adoptValue(value, resolve, reject, noValue) {
    var method;

    try {
      // Check for promise aspect first to privilege synchronous behavior
      if (value && jQuery.isFunction((method = value.promise))) {
        method
          .call(value)
          .done(resolve)
          .fail(reject);

        // Other thenables
      } else if (value && jQuery.isFunction((method = value.then))) {
        method.call(value, resolve, reject);

        // Other non-thenables
      } else {
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply(undefined, [value].slice(noValue));
      }

      // For Promises/A+, convert exceptions into rejections
      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
      // Deferred#then to conditionally suppress rejection.
    } catch (value) {
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply(undefined, [value]);
    }
  }

  jQuery.extend({
    Deferred: function(func) {
      var tuples = [
          // action, add listener, callbacks,
          // ... .then handlers, argument index, [final state]
          [
            "notify",
            "progress",
            jQuery.Callbacks("memory"),
            jQuery.Callbacks("memory"),
            2
          ],
          [
            "resolve",
            "done",
            jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"),
            0,
            "resolved"
          ],
          [
            "reject",
            "fail",
            jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"),
            1,
            "rejected"
          ]
        ],
        state = "pending",
        promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          catch: function(fn) {
            return promise.then(null, fn);
          },

          // Keep pipe for back-compat
          pipe: function(/* fnDone, fnFail, fnProgress */) {
            var fns = arguments;

            return jQuery
              .Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                  var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];

                  // deferred.progress(function() { bind to newDefer or newDefer.notify })
                  // deferred.done(function() { bind to newDefer or newDefer.resolve })
                  // deferred.fail(function() { bind to newDefer or newDefer.reject })
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned
                        .promise()
                        .progress(newDefer.notify)
                        .done(newDefer.resolve)
                        .fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this,
                        fn ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              })
              .promise();
          },
          then: function(onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;
            function resolve(depth, deferred, handler, special) {
              return function() {
                var that = this,
                  args = arguments,
                  mightThrow = function() {
                    var returned, then;

                    // Support: Promises/A+ section 2.3.3.3.3
                    // https://promisesaplus.com/#point-59
                    // Ignore double-resolution attempts
                    if (depth < maxDepth) {
                      return;
                    }

                    returned = handler.apply(that, args);

                    // Support: Promises/A+ section 2.3.1
                    // https://promisesaplus.com/#point-48
                    if (returned === deferred.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }

                    // Support: Promises/A+ sections 2.3.3.1, 3.5
                    // https://promisesaplus.com/#point-54
                    // https://promisesaplus.com/#point-75
                    // Retrieve `then` only once
                    then =
                      returned &&
                      // Support: Promises/A+ section 2.3.4
                      // https://promisesaplus.com/#point-64
                      // Only check objects and functions for thenability
                      (typeof returned === "object" ||
                        typeof returned === "function") &&
                      returned.then;

                    // Handle a returned thenable
                    if (jQuery.isFunction(then)) {
                      // Special processors (notify) just wait for resolution
                      if (special) {
                        then.call(
                          returned,
                          resolve(maxDepth, deferred, Identity, special),
                          resolve(maxDepth, deferred, Thrower, special)
                        );

                        // Normal processors (resolve) also hook into progress
                      } else {
                        // ...and disregard older resolution values
                        maxDepth++;

                        then.call(
                          returned,
                          resolve(maxDepth, deferred, Identity, special),
                          resolve(maxDepth, deferred, Thrower, special),
                          resolve(
                            maxDepth,
                            deferred,
                            Identity,
                            deferred.notifyWith
                          )
                        );
                      }

                      // Handle all other returned values
                    } else {
                      // Only substitute handlers pass on context
                      // and multiple values (non-spec behavior)
                      if (handler !== Identity) {
                        that = undefined;
                        args = [returned];
                      }

                      // Process the value(s)
                      // Default process is resolve
                      (special || deferred.resolveWith)(that, args);
                    }
                  },
                  // Only normal processors (resolve) catch and reject exceptions
                  process = special
                    ? mightThrow
                    : function() {
                        try {
                          mightThrow();
                        } catch (e) {
                          if (jQuery.Deferred.exceptionHook) {
                            jQuery.Deferred.exceptionHook(
                              e,
                              process.stackTrace
                            );
                          }

                          // Support: Promises/A+ section 2.3.3.3.4.1
                          // https://promisesaplus.com/#point-61
                          // Ignore post-resolution exceptions
                          if (depth + 1 >= maxDepth) {
                            // Only substitute handlers pass on context
                            // and multiple values (non-spec behavior)
                            if (handler !== Thrower) {
                              that = undefined;
                              args = [e];
                            }

                            deferred.rejectWith(that, args);
                          }
                        }
                      };

                // Support: Promises/A+ section 2.3.3.3.1
                // https://promisesaplus.com/#point-57
                // Re-resolve promises immediately to dodge false rejection from
                // subsequent errors
                if (depth) {
                  process();
                } else {
                  // Call an optional hook to record the stack, in case of exception
                  // since it's otherwise lost when execution goes async
                  if (jQuery.Deferred.getStackHook) {
                    process.stackTrace = jQuery.Deferred.getStackHook();
                  }
                  window.setTimeout(process);
                }
              };
            }

            return jQuery
              .Deferred(function(newDefer) {
                // progress_handlers.add( ... )
                tuples[0][3].add(
                  resolve(
                    0,
                    newDefer,
                    jQuery.isFunction(onProgress) ? onProgress : Identity,
                    newDefer.notifyWith
                  )
                );

                // fulfilled_handlers.add( ... )
                tuples[1][3].add(
                  resolve(
                    0,
                    newDefer,
                    jQuery.isFunction(onFulfilled) ? onFulfilled : Identity
                  )
                );

                // rejected_handlers.add( ... )
                tuples[2][3].add(
                  resolve(
                    0,
                    newDefer,
                    jQuery.isFunction(onRejected) ? onRejected : Thrower
                  )
                );
              })
              .promise();
          },

          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function(obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        },
        deferred = {};

      // Add list-specific methods
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
          stateString = tuple[5];

        // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add
        promise[tuple[1]] = list.add;

        // Handle state
        if (stateString) {
          list.add(
            function() {
              // state = "resolved" (i.e., fulfilled)
              // state = "rejected"
              state = stateString;
            },

            // rejected_callbacks.disable
            // fulfilled_callbacks.disable
            tuples[3 - i][2].disable,

            // progress_callbacks.lock
            tuples[0][2].lock
          );
        }

        // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire
        list.add(tuple[3].fire);

        // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](
            this === deferred ? undefined : this,
            arguments
          );
          return this;
        };

        // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith
        deferred[tuple[0] + "With"] = list.fireWith;
      });

      // Make the deferred a promise
      promise.promise(deferred);

      // Call given func if any
      if (func) {
        func.call(deferred, deferred);
      }

      // All done!
      return deferred;
    },

    // Deferred helper
    when: function(singleValue) {
      var // count of uncompleted subordinates
        remaining = arguments.length,
        // count of unprocessed arguments
        i = remaining,
        // subordinate fulfillment data
        resolveContexts = Array(i),
        resolveValues = slice.call(arguments),
        // the master Deferred
        master = jQuery.Deferred(),
        // subordinate callback factory
        updateFunc = function(i) {
          return function(value) {
            resolveContexts[i] = this;
            resolveValues[i] =
              arguments.length > 1 ? slice.call(arguments) : value;
            if (!--remaining) {
              master.resolveWith(resolveContexts, resolveValues);
            }
          };
        };

      // Single- and empty arguments are adopted like Promise.resolve
      if (remaining <= 1) {
        adoptValue(
          singleValue,
          master.done(updateFunc(i)).resolve,
          master.reject,
          !remaining
        );

        // Use .then() to unwrap secondary thenables (cf. gh-3000)
        if (
          master.state() === "pending" ||
          jQuery.isFunction(resolveValues[i] && resolveValues[i].then)
        ) {
          return master.then();
        }
      }

      // Multiple arguments are aggregated like Promise.all array elements
      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), master.reject);
      }

      return master.promise();
    }
  });

  // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function(error, stack) {
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if (
      window.console &&
      window.console.warn &&
      error &&
      rerrorNames.test(error.name)
    ) {
      window.console.warn(
        "jQuery.Deferred exception: " + error.message,
        error.stack,
        stack
      );
    }
  };

  jQuery.readyException = function(error) {
    window.setTimeout(function() {
      throw error;
    });
  };

  // The deferred used on DOM ready
  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function(fn) {
    readyList
      .then(fn)

      // Wrap jQuery.readyException in a function so that the lookup
      // happens at the time of error handling instead of callback
      // registration.
      .catch(function(error) {
        jQuery.readyException(error);
      });

    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,

    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,

    // Handle when the DOM is ready
    ready: function(wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }

      // Remember that the DOM is ready
      jQuery.isReady = true;

      // If a normal DOM Ready event fired, decrement, and wait if need be
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }

      // If there are functions bound, to execute
      readyList.resolveWith(document, [jQuery]);
    }
  });

  jQuery.ready.then = readyList.then;

  // The ready event handler and self cleanup method
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  }

  // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon
  if (
    document.readyState === "complete" ||
    (document.readyState !== "loading" && !document.documentElement.doScroll)
  ) {
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout(jQuery.ready);
  } else {
    // Use the handy event callback
    document.addEventListener("DOMContentLoaded", completed);

    // A fallback to window.onload, that will always work
    window.addEventListener("load", completed);
  }

  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
      len = elems.length,
      bulk = key == null;

    // Sets many values
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }

      // Sets one value
    } else if (value !== undefined) {
      chainable = true;

      if (!jQuery.isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null;

          // ...except when executing function values
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < len; i++) {
          fn(
            elems[i],
            key,
            raw ? value : value.call(elems[i], i, fn(elems[i], key))
          );
        }
      }
    }

    if (chainable) {
      return elems;
    }

    // Gets
    if (bulk) {
      return fn.call(elems);
    }

    return len ? fn(elems[0], key) : emptyGet;
  };
  var acceptData = function(owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };

  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;

  Data.prototype = {
    cache: function(owner) {
      // Check if the owner object already has a cache
      var value = owner[this.expando];

      // If not, create one
      if (!value) {
        value = {};

        // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return an empty object.
        if (acceptData(owner)) {
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if (owner.nodeType) {
            owner[this.expando] = value;

            // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }

      return value;
    },
    set: function(owner, data, value) {
      var prop,
        cache = this.cache(owner);

      // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)
      if (typeof data === "string") {
        cache[jQuery.camelCase(data)] = value;

        // Handle: [ owner, { properties } ] args
      } else {
        // Copy the properties one-by-one to the cache object
        for (prop in data) {
          cache[jQuery.camelCase(prop)] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      return key === undefined
        ? this.cache(owner)
        : // Always use camelCase key (gh-2257)
          owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
    },
    access: function(owner, key, value) {
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (
        key === undefined ||
        (key && typeof key === "string" && value === undefined)
      ) {
        return this.get(owner, key);
      }

      // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //
      this.set(owner, key, value);

      // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
        cache = owner[this.expando];

      if (cache === undefined) {
        return;
      }

      if (key !== undefined) {
        // Support array or space separated string of keys
        if (Array.isArray(key)) {
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map(jQuery.camelCase);
        } else {
          key = jQuery.camelCase(key);

          // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace
          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }

        i = key.length;

        while (i--) {
          delete cache[key[i]];
        }
      }

      // Remove the expando if there's no more data
      if (key === undefined || jQuery.isEmptyObject(cache)) {
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();

  var dataUser = new Data();

  //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /[A-Z]/g;

  function getData(data) {
    if (data === "true") {
      return true;
    }

    if (data === "false") {
      return false;
    }

    if (data === "null") {
      return null;
    }

    // Only convert to a number if it doesn't change the string
    if (data === +data + "") {
      return +data;
    }

    if (rbrace.test(data)) {
      return JSON.parse(data);
    }

    return data;
  }

  function dataAttr(elem, key, data) {
    var name;

    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {}

        // Make sure we set the data so it isn't changed later
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }

  jQuery.extend({
    hasData: function(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },

    data: function(elem, name, data) {
      return dataUser.access(elem, name, data);
    },

    removeData: function(elem, name) {
      dataUser.remove(elem, name);
    },

    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },

    _removeData: function(elem, name) {
      dataPriv.remove(elem, name);
    }
  });

  jQuery.fn.extend({
    data: function(key, value) {
      var i,
        name,
        data,
        elem = this[0],
        attrs = elem && elem.attributes;

      // Gets all values
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);

          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              // Support: IE 11 only
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }

        return data;
      }

      // Sets multiple values
      if (typeof key === "object") {
        return this.each(function() {
          dataUser.set(this, key);
        });
      }

      return access(
        this,
        function(value) {
          var data;

          // The calling jQuery object (element matches) is not empty
          // (and therefore has an element appears at this[ 0 ]) and the
          // `value` parameter was not undefined. An empty jQuery object
          // will result in `undefined` for elem = this[ 0 ] which will
          // throw an exception if an attempt to read a data cache is made.
          if (elem && value === undefined) {
            // Attempt to get data from the cache
            // The key will always be camelCased in Data
            data = dataUser.get(elem, key);
            if (data !== undefined) {
              return data;
            }

            // Attempt to "discover" the data in
            // HTML5 custom data-* attrs
            data = dataAttr(elem, key);
            if (data !== undefined) {
              return data;
            }

            // We tried really hard, but the data doesn't exist.
            return;
          }

          // Set the data...
          this.each(function() {
            // We always store the camelCased key
            dataUser.set(this, key, value);
          });
        },
        null,
        value,
        arguments.length > 1,
        null,
        true
      );
    },

    removeData: function(key) {
      return this.each(function() {
        dataUser.remove(this, key);
      });
    }
  });

  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);

        // Speed up dequeue by getting out quickly if this is just a lookup
        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },

    dequeue: function(elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
        startLength = queue.length,
        fn = queue.shift(),
        hooks = jQuery._queueHooks(elem, type),
        next = function() {
          jQuery.dequeue(elem, type);
        };

      // If the fx queue is dequeued, always remove the progress sentinel
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        }

        // Clear up the last queue stop function
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },

    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return (
        dataPriv.get(elem, key) ||
        dataPriv.access(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function() {
            dataPriv.remove(elem, [type + "queue", key]);
          })
        })
      );
    }
  });

  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined
        ? this
        : this.each(function() {
            var queue = jQuery.queue(this, type, data);

            // Ensure a hooks for this queue
            jQuery._queueHooks(this, type);

            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },

    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function(type, obj) {
      var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function() {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";

      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;

  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");

  var cssExpand = ["Top", "Right", "Bottom", "Left"];

  var isHiddenWithinTree = function(elem, el) {
    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;

    // Inline style trumps all
    return (
      elem.style.display === "none" ||
      (elem.style.display === "" &&
        // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        jQuery.contains(elem.ownerDocument, elem) &&
        jQuery.css(elem, "display") === "none")
    );
  };

  var swap = function(elem, options, callback, args) {
    var ret,
      name,
      old = {};

    // Remember the old values, and insert the new ones
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.apply(elem, args || []);

    // Revert the old values
    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
      scale = 1,
      maxIterations = 20,
      currentValue = tween
        ? function() {
            return tween.cur();
          }
        : function() {
            return jQuery.css(elem, prop, "");
          },
      initial = currentValue(),
      unit =
        (valueParts && valueParts[3]) || (jQuery.cssNumber[prop] ? "" : "px"),
      // Starting value computation is required for potential unit mismatches
      initialInUnit =
        (jQuery.cssNumber[prop] || (unit !== "px" && +initial)) &&
        rcssNum.exec(jQuery.css(elem, prop));

    if (initialInUnit && initialInUnit[3] !== unit) {
      // Trust units reported by jQuery.css
      unit = unit || initialInUnit[3];

      // Make sure we update the tween properties later on
      valueParts = valueParts || [];

      // Iteratively approximate from a nonzero starting point
      initialInUnit = +initial || 1;

      do {
        // If previous iteration zeroed out, double until we get *something*.
        // Use string for doubling so we don't accidentally see scale as unchanged below
        scale = scale || ".5";

        // Adjust and apply
        initialInUnit = initialInUnit / scale;
        jQuery.style(elem, prop, initialInUnit + unit);

        // Update scale, tolerating zero or NaN from tween.cur()
        // Break the loop if scale is unchanged or perfect, or if we've just had enough.
      } while (
        scale !== (scale = currentValue() / initial) &&
        scale !== 1 &&
        --maxIterations
      );
    }

    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;

      // Apply relative offset (+=/-=) if specified
      adjusted = valueParts[1]
        ? initialInUnit + (valueParts[1] + 1) * valueParts[2]
        : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }

  var defaultDisplayMap = {};

  function getDefaultDisplay(elem) {
    var temp,
      doc = elem.ownerDocument,
      nodeName = elem.nodeName,
      display = defaultDisplayMap[nodeName];

    if (display) {
      return display;
    }

    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");

    temp.parentNode.removeChild(temp);

    if (display === "none") {
      display = "block";
    }
    defaultDisplayMap[nodeName] = display;

    return display;
  }

  function showHide(elements, show) {
    var display,
      elem,
      values = [],
      index = 0,
      length = elements.length;

    // Determine new display value for elements that need to change
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }

      display = elem.style.display;
      if (show) {
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;
          if (!values[index]) {
            elem.style.display = "";
          }
        }
        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none";

          // Remember what we're overwriting
          dataPriv.set(elem, "display", display);
        }
      }
    }

    // Set the display of the elements in a second loop to avoid constant reflow
    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }

    return elements;
  }

  jQuery.fn.extend({
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function() {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = /^(?:checkbox|radio)$/i;

  var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;

  var rscriptType = /^$|\/(?:java|ecma)script/i;

  // We have to close these tags to support XHTML (#13200)
  var wrapMap = {
    // Support: IE <=9 only
    option: [1, "<select multiple='multiple'>", "</select>"],

    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

    _default: [0, "", ""]
  };

  // Support: IE <=9 only
  wrapMap.optgroup = wrapMap.option;

  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption =
    wrapMap.thead;
  wrapMap.th = wrapMap.td;

  function getAll(context, tag) {
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
    var ret;

    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }

    if (tag === undefined || (tag && nodeName(context, tag))) {
      return jQuery.merge([context], ret);
    }

    return ret;
  }

  // Mark scripts as having already been evaluated
  function setGlobalEval(elems, refElements) {
    var i = 0,
      l = elems.length;

    for (; i < l; i++) {
      dataPriv.set(
        elems[i],
        "globalEval",
        !refElements || dataPriv.get(refElements[i], "globalEval")
      );
    }
  }

  var rhtml = /<|&#?\w+;/;

  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
      tmp,
      tag,
      wrap,
      contains,
      j,
      fragment = context.createDocumentFragment(),
      nodes = [],
      i = 0,
      l = elems.length;

    for (; i < l; i++) {
      elem = elems[i];

      if (elem || elem === 0) {
        // Add nodes directly
        if (jQuery.type(elem) === "object") {
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

          // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));

          // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));

          // Deserialize a standard representation
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

          // Descend through wrappers to the right content
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }

          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, tmp.childNodes);

          // Remember the top-level container
          tmp = fragment.firstChild;

          // Ensure the created nodes are orphaned (#12392)
          tmp.textContent = "";
        }
      }
    }

    // Remove wrapper from fragment
    fragment.textContent = "";

    i = 0;
    while ((elem = nodes[i++])) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }

      contains = jQuery.contains(elem.ownerDocument, elem);

      // Append to fragment
      tmp = getAll(fragment.appendChild(elem), "script");

      // Preserve script evaluation history
      if (contains) {
        setGlobalEval(tmp);
      }

      // Capture executables
      if (scripts) {
        j = 0;
        while ((elem = tmp[j++])) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }

    return fragment;
  }

  (function() {
    var fragment = document.createDocumentFragment(),
      div = fragment.appendChild(document.createElement("div")),
      input = document.createElement("input");

    // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");

    div.appendChild(input);

    // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

    // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var documentElement = document.documentElement;

  var rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  // Support: IE <=9 only
  // See #13393 for more info
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  function on(elem, types, selector, data, fn, one) {
    var origFn, type;

    // Types can be a map of types/handlers
    if (typeof types === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }

    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }

    if (one === 1) {
      origFn = fn;
      fn = function(event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };

      // Use same guid so caller can remove using origFn
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function() {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }

  /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
  jQuery.event = {
    global: {},

    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
        eventHandle,
        tmp,
        events,
        t,
        handleObj,
        special,
        handlers,
        type,
        namespaces,
        origType,
        elemData = dataPriv.get(elem);

      // Don't attach events to noData or text/comment nodes (but allow plain objects)
      if (!elemData) {
        return;
      }

      // Caller can pass in an object of custom data in lieu of the handler
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }

      // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)
      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      }

      // Make sure that the handler has a unique ID, used to find/remove it later
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }

      // Init the element's event structure and main handler, if this is the first
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" &&
            jQuery.event.triggered !== e.type
            ? jQuery.event.dispatch.apply(elem, arguments)
            : undefined;
        };
      }

      // Handle multiple events separated by a space
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();

        // There *must* be a type, no attaching namespace-only handlers
        if (!type) {
          continue;
        }

        // If event changes its type, use the special event handlers for the changed type
        special = jQuery.event.special[type] || {};

        // If selector defined, determine special event api type, otherwise given type
        type = (selector ? special.delegateType : special.bindType) || type;

        // Update special based on newly reset type
        special = jQuery.event.special[type] || {};

        // handleObj is passed to all event handlers
        handleObj = jQuery.extend(
          {
            type: type,
            origType: origType,
            data: data,
            handler: handler,
            guid: handler.guid,
            selector: selector,
            needsContext:
              selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          },
          handleObjIn
        );

        // Init the event handler queue if we're the first
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;

          // Only use addEventListener if the special events handler returns false
          if (
            !special.setup ||
            special.setup.call(elem, data, namespaces, eventHandle) === false
          ) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }

        // Add to the element's handler list, delegates in front
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }

        // Keep track of which events have ever been used, for event optimization
        jQuery.event.global[type] = true;
      }
    },

    // Detach an event or set of events from an element
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
        origCount,
        tmp,
        events,
        t,
        handleObj,
        special,
        handlers,
        type,
        namespaces,
        origType,
        elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      }

      // Once for each type.namespace in types; type may be omitted
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();

        // Unbind all events (on this namespace, if provided) for the element
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp =
          tmp[2] &&
          new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

        // Remove matching events
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];

          if (
            (mappedTypes || origType === handleObj.origType) &&
            (!handler || handler.guid === handleObj.guid) &&
            (!tmp || tmp.test(handleObj.namespace)) &&
            (!selector ||
              selector === handleObj.selector ||
              (selector === "**" && handleObj.selector))
          ) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }

        // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)
        if (origCount && !handlers.length) {
          if (
            !special.teardown ||
            special.teardown.call(elem, namespaces, elemData.handle) === false
          ) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      }

      // Remove data and the expando if it's no longer used
      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },

    dispatch: function(nativeEvent) {
      // Make a writable jQuery.Event from the native event object
      var event = jQuery.event.fix(nativeEvent);

      var i,
        j,
        ret,
        matched,
        handleObj,
        handlerQueue,
        args = new Array(arguments.length),
        handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
        special = jQuery.event.special[event.type] || {};

      // Use the fix-ed jQuery.Event rather than the (read-only) native event
      args[0] = event;

      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      event.delegateTarget = this;

      // Call the preDispatch hook for the mapped type, and let it bail if desired
      if (
        special.preDispatch &&
        special.preDispatch.call(this, event) === false
      ) {
        return;
      }

      // Determine handlers
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);

      // Run delegates first; they may want to stop propagation beneath us
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;

        j = 0;
        while (
          (handleObj = matched.handlers[j++]) &&
          !event.isImmediatePropagationStopped()
        ) {
          // Triggered event must either 1) have no namespace, or 2) have namespace(s)
          // a subset or equal to those in the bound event (both can have no namespace).
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;

            ret = (
              (jQuery.event.special[handleObj.origType] || {}).handle ||
              handleObj.handler
            ).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }

      // Call the postDispatch hook for the mapped type
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },

    handlers: function(event, handlers) {
      var i,
        handleObj,
        sel,
        matchedHandlers,
        matchedSelectors,
        handlerQueue = [],
        delegateCount = handlers.delegateCount,
        cur = event.target;

      // Find delegate handlers
      if (
        delegateCount &&
        // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        cur.nodeType &&
        // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !(event.type === "click" && event.button >= 1)
      ) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (
            cur.nodeType === 1 &&
            !(event.type === "click" && cur.disabled === true)
          ) {
            matchedHandlers = [];
            matchedSelectors = {};
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];

              // Don't conflict with Object.prototype properties (#13203)
              sel = handleObj.selector + " ";

              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext
                  ? jQuery(sel, this).index(cur) > -1
                  : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }
            if (matchedHandlers.length) {
              handlerQueue.push({ elem: cur, handlers: matchedHandlers });
            }
          }
        }
      }

      // Add the remaining (directly-bound) handlers
      cur = this;
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: handlers.slice(delegateCount)
        });
      }

      return handlerQueue;
    },

    addProp: function(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,

        get: jQuery.isFunction(hook)
          ? function() {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            }
          : function() {
              if (this.originalEvent) {
                return this.originalEvent[name];
              }
            },

        set: function(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },

    fix: function(originalEvent) {
      return originalEvent[jQuery.expando]
        ? originalEvent
        : new jQuery.Event(originalEvent);
    },

    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      focus: {
        // Fire native event if possible so blur/focus sequence is correct
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        // For checkbox, fire native event so checked state will be right
        trigger: function() {
          if (
            this.type === "checkbox" &&
            this.click &&
            nodeName(this, "input")
          ) {
            this.click();
            return false;
          }
        },

        // For cross-browser consistency, don't fire native .click() on links
        _default: function(event) {
          return nodeName(event.target, "a");
        }
      },

      beforeunload: {
        postDispatch: function(event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  };

  jQuery.removeEvent = function(elem, type, handle) {
    // This "if" is needed for plain objects
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };

  jQuery.Event = function(src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }

    // Event object
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented =
        src.defaultPrevented ||
        (src.defaultPrevented === undefined &&
          // Support: Android <=2.3 only
          src.returnValue === false)
          ? returnTrue
          : returnFalse;

      // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (#504, #13143)
      this.target =
        src.target && src.target.nodeType === 3
          ? src.target.parentNode
          : src.target;

      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget;

      // Event type
    } else {
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if (props) {
      jQuery.extend(this, props);
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = (src && src.timeStamp) || jQuery.now();

    // Mark it as fixed
    this[jQuery.expando] = true;
  };

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,

    preventDefault: function() {
      var e = this.originalEvent;

      this.isDefaultPrevented = returnTrue;

      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;

      this.isPropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;

      this.isImmediatePropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  };

  // Includes all common event props including KeyEvent and MouseEvent specific props
  jQuery.each(
    {
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      char: true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,

      which: function(event) {
        var button = event.button;

        // Add which for key events
        if (event.which == null && rkeyEvent.test(event.type)) {
          return event.charCode != null ? event.charCode : event.keyCode;
        }

        // Add which for click: 1 === left; 2 === middle; 3 === right
        if (
          !event.which &&
          button !== undefined &&
          rmouseEvent.test(event.type)
        ) {
          if (button & 1) {
            return 1;
          }

          if (button & 2) {
            return 3;
          }

          if (button & 4) {
            return 2;
          }

          return 0;
        }

        return event.which;
      }
    },
    jQuery.event.addProp
  );

  // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).
  jQuery.each(
    {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    },
    function(orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,

        handle: function(event) {
          var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;

          // For mouseenter/leave call the handler if related is outside the target.
          // NB: No relatedTarget if the mouse left/entered the browser window
          if (
            !related ||
            (related !== target && !jQuery.contains(target, related))
          ) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        }
      };
    }
  );

  jQuery.fn.extend({
    on: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(
          handleObj.namespace
            ? handleObj.origType + "." + handleObj.namespace
            : handleObj.origType,
          handleObj.selector,
          handleObj.handler
        );
        return this;
      }
      if (typeof types === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });

  var /* eslint-disable max-len */

    // See https://github.com/eslint/eslint/issues/3229
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
    /* eslint-enable */

    // Support: IE <=10 - 11, Edge 12 - 13
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptTypeMasked = /^true\/(.*)/,
    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  // Prefer a tbody over its parent table for containing new rows
  function manipulationTarget(elem, content) {
    if (
      nodeName(elem, "table") &&
      nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")
    ) {
      return jQuery(">tbody", elem)[0] || elem;
    }

    return elem;
  }

  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);

    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

    if (dest.nodeType !== 1) {
      return;
    }

    // 1. Copy private data: events, handlers, etc.
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;

      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};

        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }

    // 2. Copy user data
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);

      dataUser.set(dest, udataCur);
    }
  }

  // Fix IE bugs, see support tests
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();

    // Fails to persist the checked state of a cloned checkbox or radio button.
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;

      // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = concat.apply([], args);

    var fragment,
      first,
      scripts,
      hasScripts,
      node,
      doc,
      i = 0,
      l = collection.length,
      iNoClone = l - 1,
      value = args[0],
      isFunction = jQuery.isFunction(value);

    // We can't cloneNode fragments that contain checked, in WebKit
    if (
      isFunction ||
      (l > 1 &&
        typeof value === "string" &&
        !support.checkClone &&
        rchecked.test(value))
    ) {
      return collection.each(function(index) {
        var self = collection.eq(index);
        if (isFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }

    if (l) {
      fragment = buildFragment(
        args,
        collection[0].ownerDocument,
        false,
        collection,
        ignored
      );
      first = fragment.firstChild;

      if (fragment.childNodes.length === 1) {
        fragment = first;
      }

      // Require either new content or an interest in ignored elements to invoke the callback
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;

        // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).
        for (; i < l; i++) {
          node = fragment;

          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);

            // Keep references to cloned scripts for later restoration
            if (hasScripts) {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }

          callback.call(collection[i], node, i);
        }

        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;

          // Reenable scripts
          jQuery.map(scripts, restoreScript);

          // Evaluate executable scripts on first document insertion
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (
              rscriptType.test(node.type || "") &&
              !dataPriv.access(node, "globalEval") &&
              jQuery.contains(doc, node)
            ) {
              if (node.src) {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), doc);
              }
            }
          }
        }
      }
    }

    return collection;
  }

  function remove(elem, selector, keepData) {
    var node,
      nodes = selector ? jQuery.filter(selector, elem) : elem,
      i = 0;

    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }

      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }

    return elem;
  }

  jQuery.extend({
    htmlPrefilter: function(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },

    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
        l,
        srcElements,
        destElements,
        clone = elem.cloneNode(true),
        inPage = jQuery.contains(elem.ownerDocument, elem);

      // Fix IE cloning issues
      if (
        !support.noCloneChecked &&
        (elem.nodeType === 1 || elem.nodeType === 11) &&
        !jQuery.isXMLDoc(elem)
      ) {
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }

      // Copy the events from the original to the clone
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }

      // Preserve script evaluation history
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }

      // Return the cloned set
      return clone;
    },

    cleanData: function(elems) {
      var data,
        elem,
        type,
        special = jQuery.event.special,
        i = 0;

      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if ((data = elem[dataPriv.expando])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);

                  // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }

            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });

  jQuery.fn.extend({
    detach: function(selector) {
      return remove(this, selector, true);
    },

    remove: function(selector) {
      return remove(this, selector);
    },

    text: function(value) {
      return access(
        this,
        function(value) {
          return value === undefined
            ? jQuery.text(this)
            : this.empty().each(function() {
                if (
                  this.nodeType === 1 ||
                  this.nodeType === 11 ||
                  this.nodeType === 9
                ) {
                  this.textContent = value;
                }
              });
        },
        null,
        value,
        arguments.length
      );
    },

    append: function() {
      return domManip(this, arguments, function(elem) {
        if (
          this.nodeType === 1 ||
          this.nodeType === 11 ||
          this.nodeType === 9
        ) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },

    prepend: function() {
      return domManip(this, arguments, function(elem) {
        if (
          this.nodeType === 1 ||
          this.nodeType === 11 ||
          this.nodeType === 9
        ) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },

    before: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },

    after: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },

    empty: function() {
      var elem,
        i = 0;

      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false));

          // Remove any remaining nodes
          elem.textContent = "";
        }
      }

      return this;
    },

    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents =
        deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },

    html: function(value) {
      return access(
        this,
        function(value) {
          var elem = this[0] || {},
            i = 0,
            l = this.length;

          if (value === undefined && elem.nodeType === 1) {
            return elem.innerHTML;
          }

          // See if we can take a shortcut and just use innerHTML
          if (
            typeof value === "string" &&
            !rnoInnerhtml.test(value) &&
            !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]
          ) {
            value = jQuery.htmlPrefilter(value);

            try {
              for (; i < l; i++) {
                elem = this[i] || {};

                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value;
                }
              }

              elem = 0;

              // If using innerHTML throws an exception, use the fallback method
            } catch (e) {}
          }

          if (elem) {
            this.empty().append(value);
          }
        },
        null,
        value,
        arguments.length
      );
    },

    replaceWith: function() {
      var ignored = [];

      // Make the changes, replacing each non-ignored context element with the new content
      return domManip(
        this,
        arguments,
        function(elem) {
          var parent = this.parentNode;

          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));
            if (parent) {
              parent.replaceChild(elem, this);
            }
          }

          // Force callback invocation
        },
        ignored
      );
    }
  });

  jQuery.each(
    {
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    },
    function(name, original) {
      jQuery.fn[name] = function(selector) {
        var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;

        for (; i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery(insert[i])[original](elems);

          // Support: Android <=4.0 only, PhantomJS 1 only
          // .get() because push.apply(_, arraylike) throws on ancient WebKit
          push.apply(ret, elems.get());
        }

        return this.pushStack(ret);
      };
    }
  );
  var rmargin = /^margin/;

  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

  var getStyles = function(elem) {
    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if (!view || !view.opener) {
      view = window;
    }

    return view.getComputedStyle(elem);
  };

  (function() {
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
      // This is a singleton, we need to execute it only once
      if (!div) {
        return;
      }

      div.style.cssText =
        "box-sizing:border-box;" +
        "position:relative;display:block;" +
        "margin:auto;border:1px;padding:1px;" +
        "top:1%;width:50%";
      div.innerHTML = "";
      documentElement.appendChild(container);

      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";

      // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
      reliableMarginLeftVal = divStyle.marginLeft === "2px";
      boxSizingReliableVal = divStyle.width === "4px";

      // Support: Android 4.0 - 4.3 only
      // Some styles come back with percentage values, even though they shouldn't
      div.style.marginRight = "50%";
      pixelMarginRightVal = divStyle.marginRight === "4px";

      documentElement.removeChild(container);

      // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed
      div = null;
    }

    var pixelPositionVal,
      boxSizingReliableVal,
      pixelMarginRightVal,
      reliableMarginLeftVal,
      container = document.createElement("div"),
      div = document.createElement("div");

    // Finish early in limited (non-browser) environments
    if (!div.style) {
      return;
    }

    // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (#8908)
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";

    container.style.cssText =
      "border:0;width:8px;height:0;top:0;left:-9999px;" +
      "padding:0;margin-top:1px;position:absolute";
    container.appendChild(div);

    jQuery.extend(support, {
      pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
      },
      boxSizingReliable: function() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelMarginRight: function() {
        computeStyleTests();
        return pixelMarginRightVal;
      },
      reliableMarginLeft: function() {
        computeStyleTests();
        return reliableMarginLeftVal;
      }
    });
  })();

  function curCSS(elem, name, computed) {
    var width,
      minWidth,
      maxWidth,
      ret,
      // Support: Firefox 51+
      // Retrieving style before computed somehow
      // fixes an issue with getting wrong values
      // on detached elements
      style = elem.style;

    computed = computed || getStyles(elem);

    // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, #12537)
    //   .css('--customProperty) (#3144)
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];

      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }

      // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values
      if (
        !support.pixelMarginRight() &&
        rnumnonpx.test(ret) &&
        rmargin.test(name)
      ) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;

        // Put in the new values to get a computed value out
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;

        // Revert the changed values
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret !== undefined
      ? // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + ""
      : ret;
  }

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function() {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        }

        // Hook needed; redefine it so that the support test is not executed again.
        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }

  var // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rcustomProp = /^--/,
    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    },
    cssPrefixes = ["Webkit", "Moz", "ms"],
    emptyStyle = document.createElement("div").style;

  // Return a css property mapped to a potentially vendor prefixed property
  function vendorPropName(name) {
    // Shortcut for names that are not vendor prefixed
    if (name in emptyStyle) {
      return name;
    }

    // Check for vendor prefixed names
    var capName = name[0].toUpperCase() + name.slice(1),
      i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }

  // Return a property mapped along what jQuery.cssProps suggests or to
  // a vendor prefixed property.
  function finalPropName(name) {
    var ret = jQuery.cssProps[name];
    if (!ret) {
      ret = jQuery.cssProps[name] = vendorPropName(name) || name;
    }
    return ret;
  }

  function setPositiveNumber(elem, value, subtract) {
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec(value);
    return matches
      ? // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
      : value;
  }

  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i,
      val = 0;

    // If we already have the right measurement, avoid augmentation
    if (extra === (isBorderBox ? "border" : "content")) {
      i = 4;

      // Otherwise initialize for horizontal or vertical properties
    } else {
      i = name === "width" ? 1 : 0;
    }

    for (; i < 4; i += 2) {
      // Both box models exclude margin, so add it if we want it
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }

      if (isBorderBox) {
        // border-box includes padding, so remove it if we want content
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }

        // At this point, extra isn't border nor margin, so remove border
        if (extra !== "margin") {
          val -= jQuery.css(
            elem,
            "border" + cssExpand[i] + "Width",
            true,
            styles
          );
        }
      } else {
        // At this point, extra isn't content, so add padding
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

        // At this point, extra isn't content nor padding, so add border
        if (extra !== "padding") {
          val += jQuery.css(
            elem,
            "border" + cssExpand[i] + "Width",
            true,
            styles
          );
        }
      }
    }

    return val;
  }

  function getWidthOrHeight(elem, name, extra) {
    // Start with computed style
    var valueIsBorderBox,
      styles = getStyles(elem),
      val = curCSS(elem, name, styles),
      isBorderBox =
        jQuery.css(elem, "boxSizing", false, styles) === "border-box";

    // Computed unit is not pixels. Stop here and return.
    if (rnumnonpx.test(val)) {
      return val;
    }

    // Check for style in case a browser which returns unreliable values
    // for getComputedStyle silently falls back to the reliable elem.style
    valueIsBorderBox =
      isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

    // Fall back to offsetWidth/Height when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    if (val === "auto") {
      val = elem["offset" + name[0].toUpperCase() + name.slice(1)];
    }

    // Normalize "", auto, and prepare for extra
    val = parseFloat(val) || 0;

    // Use the active box-sizing model to add/subtract irrelevant styles
    return (
      val +
      augmentWidthOrHeight(
        elem,
        name,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles
      ) +
      "px"
    );
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function(elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },

    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      animationIterationCount: true,
      columnCount: true,
      fillOpacity: true,
      flexGrow: true,
      flexShrink: true,
      fontWeight: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      widows: true,
      zIndex: true,
      zoom: true
    },

    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
      float: "cssFloat"
    },

    // Get and set the style property on a DOM Node
    style: function(elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }

      // Make sure that we're working with the right name
      var ret,
        type,
        hooks,
        origName = jQuery.camelCase(name),
        isCustomProp = rcustomProp.test(name),
        style = elem.style;

      // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.
      if (!isCustomProp) {
        name = finalPropName(origName);
      }

      // Gets hook for the prefixed version, then unprefixed version
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

      // Check if we're setting a value
      if (value !== undefined) {
        type = typeof value;

        // Convert "+=" or "-=" to relative numbers (#7345)
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);

          // Fixes bug #9237
          type = "number";
        }

        // Make sure that null and NaN values aren't set (#7116)
        if (value == null || value !== value) {
          return;
        }

        // If a number was passed in, add the unit (except for certain CSS properties)
        if (type === "number") {
          value += (ret && ret[3]) || (jQuery.cssNumber[origName] ? "" : "px");
        }

        // background-* props affect original clone's values
        if (
          !support.clearCloneStyle &&
          value === "" &&
          name.indexOf("background") === 0
        ) {
          style[name] = "inherit";
        }

        // If a hook was provided, use that value, otherwise just set the specified value
        if (
          !hooks ||
          !("set" in hooks) ||
          (value = hooks.set(elem, value, extra)) !== undefined
        ) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (
          hooks &&
          "get" in hooks &&
          (ret = hooks.get(elem, false, extra)) !== undefined
        ) {
          return ret;
        }

        // Otherwise just get the value from the style object
        return style[name];
      }
    },

    css: function(elem, name, extra, styles) {
      var val,
        num,
        hooks,
        origName = jQuery.camelCase(name),
        isCustomProp = rcustomProp.test(name);

      // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.
      if (!isCustomProp) {
        name = finalPropName(origName);
      }

      // Try prefixed name followed by the unprefixed name
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

      // If a hook was provided get the computed value from there
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }

      // Otherwise, if a way to get the computed value exists, use that
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }

      // Convert "normal" to computed value
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }

      // Make numeric if forced or a qualifier was provided and val looks numeric
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }

      return val;
    }
  });

  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) &&
            // Support: Safari 8+
            // Table columns in Safari have non-zero offsetWidth & zero
            // getBoundingClientRect().width unless display is changed.
            // Support: IE <=11 only
            // Running getBoundingClientRect on a disconnected node
            // in IE throws an error.
            (!elem.getClientRects().length ||
              !elem.getBoundingClientRect().width)
            ? swap(elem, cssShow, function() {
                return getWidthOrHeight(elem, name, extra);
              })
            : getWidthOrHeight(elem, name, extra);
        }
      },

      set: function(elem, value, extra) {
        var matches,
          styles = extra && getStyles(elem),
          subtract =
            extra &&
            augmentWidthOrHeight(
              elem,
              name,
              extra,
              jQuery.css(elem, "boxSizing", false, styles) === "border-box",
              styles
            );

        // Convert to pixels if value adjustment is needed
        if (
          subtract &&
          (matches = rcssNum.exec(value)) &&
          (matches[3] || "px") !== "px"
        ) {
          elem.style[name] = value;
          value = jQuery.css(elem, name);
        }

        return setPositiveNumber(elem, value, subtract);
      }
    };
  });

  jQuery.cssHooks.marginLeft = addGetHookIf(
    support.reliableMarginLeft,
    function(elem, computed) {
      if (computed) {
        return (
          (parseFloat(curCSS(elem, "marginLeft")) ||
            elem.getBoundingClientRect().left -
              swap(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px"
        );
      }
    }
  );

  // These hooks are used by animate to expand properties
  jQuery.each(
    {
      margin: "",
      padding: "",
      border: "Width"
    },
    function(prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function(value) {
          var i = 0,
            expanded = {},
            // Assumes a single number if not a string
            parts = typeof value === "string" ? value.split(" ") : [value];

          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] =
              parts[i] || parts[i - 2] || parts[0];
          }

          return expanded;
        }
      };

      if (!rmargin.test(prefix)) {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    }
  );

  jQuery.fn.extend({
    css: function(name, value) {
      return access(
        this,
        function(elem, name, value) {
          var styles,
            len,
            map = {},
            i = 0;

          if (Array.isArray(name)) {
            styles = getStyles(elem);
            len = name.length;

            for (; i < len; i++) {
              map[name[i]] = jQuery.css(elem, name[i], false, styles);
            }

            return map;
          }

          return value !== undefined
            ? jQuery.style(elem, name, value)
            : jQuery.css(elem, name);
        },
        name,
        value,
        arguments.length > 1
      );
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;

  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];

      return hooks && hooks.get
        ? hooks.get(this)
        : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
        hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](
          percent,
          this.options.duration * percent,
          0,
          1,
          this.options.duration
        );
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };

  Tween.prototype.init.prototype = Tween.prototype;

  Tween.propHooks = {
    _default: {
      get: function(tween) {
        var result;

        // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.
        if (
          tween.elem.nodeType !== 1 ||
          (tween.elem[tween.prop] != null &&
            tween.elem.style[tween.prop] == null)
        ) {
          return tween.elem[tween.prop];
        }

        // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.
        result = jQuery.css(tween.elem, tween.prop, "");

        // Empty strings, null, undefined and "auto" are converted to 0.
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (
          tween.elem.nodeType === 1 &&
          (tween.elem.style[jQuery.cssProps[tween.prop]] != null ||
            jQuery.cssHooks[tween.prop])
        ) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };

  // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };

  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };

  jQuery.fx = Tween.prototype.init;

  // Back compat <1.8 extension point
  jQuery.fx.step = {};

  var fxNow,
    inProgress,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rrun = /queueHooks$/;

  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }

      jQuery.fx.tick();
    }
  }

  // Animations created synchronously will run synchronously
  function createFxNow() {
    window.setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }

  // Generate parameters to create a standard animation
  function genFx(type, includeWidth) {
    var which,
      i = 0,
      attrs = { height: type };

    // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
      collection = (Animation.tweeners[prop] || []).concat(
        Animation.tweeners["*"]
      ),
      index = 0,
      length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        // We're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop,
      value,
      toggle,
      hooks,
      oldfire,
      propTween,
      restoreDisplay,
      display,
      isBox = "width" in props || "height" in props,
      anim = this,
      orig = {},
      style = elem.style,
      hidden = elem.nodeType && isHiddenWithinTree(elem),
      dataShow = dataPriv.get(elem, "fxshow");

    // Queue-skipping animations hijack the fx hooks
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;

      anim.always(function() {
        // Ensure the complete handler is called before this completes
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }

    // Detect show/hide animations
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;

            // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }
        orig[prop] = (dataShow && dataShow[prop]) || jQuery.style(elem, prop);
      }
    }

    // Bail out if this is a no-op like .hide().hide()
    propTween = !jQuery.isEmptyObject(props);
    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    }

    // Restrict "overflow" and "display" styles during box animations
    if (isBox && elem.nodeType === 1) {
      // Support: IE <=9 - 11, Edge 12 - 13
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];

      // Identify a display type, preferring old show/hide data over the CSS cascade
      restoreDisplay = dataShow && dataShow.display;
      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }
      display = jQuery.css(elem, "display");
      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          // Get nonempty value(s) by temporarily forcing visibility
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      }

      // Animate inline elements as inline-block
      if (
        display === "inline" ||
        (display === "inline-block" && restoreDisplay != null)
      ) {
        if (jQuery.css(elem, "float") === "none") {
          // Restore the original display value at the end of pure show/hide animations
          if (!propTween) {
            anim.done(function() {
              style.display = restoreDisplay;
            });
            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }
          style.display = "inline-block";
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }

    // Implement show/hide animations
    propTween = false;
    for (prop in orig) {
      // General show/hide setup for this element animation
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        }

        // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
        if (toggle) {
          dataShow.hidden = !hidden;
        }

        // Show elements before animating them
        if (hidden) {
          showHide([elem], true);
        }

        /* eslint-disable no-loop-func */

        anim.done(function() {
          /* eslint-enable no-loop-func */

          // The final step of a "hide" animation is actually hiding the element
          if (!hidden) {
            showHide([elem]);
          }
          dataPriv.remove(elem, "fxshow");
          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      }

      // Per-property setup
      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;
        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;

    // camelCase, specialEasing and expand cssHook pass
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];

        // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
      stopped,
      index = 0,
      length = Animation.prefilters.length,
      deferred = jQuery.Deferred().always(function() {
        // Don't match elem in the :animated selector
        delete tick.elem;
      }),
      tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(),
          remaining = Math.max(
            0,
            animation.startTime + animation.duration - currentTime
          ),
          // Support: Android 2.3 only
          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
          temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }

        deferred.notifyWith(elem, [animation, percent, remaining]);

        // If there's more to do, yield
        if (percent < 1 && length) {
          return remaining;
        }

        // If this was an empty animation, synthesize a final progress notification
        if (!length) {
          deferred.notifyWith(elem, [animation, 1, 0]);
        }

        // Resolve the animation and report its conclusion
        deferred.resolveWith(elem, [animation]);
        return false;
      },
      animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(
          true,
          {
            specialEasing: {},
            easing: jQuery.easing._default
          },
          options
        ),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery.Tween(
            elem,
            animation.opts,
            prop,
            end,
            animation.opts.specialEasing[prop] || animation.opts.easing
          );
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index = 0,
            // If we are going to the end, we want to run all the tweens
            // otherwise we skip this part
            length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }

          // Resolve when we played the last frame; otherwise, reject
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }),
      props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = Animation.prefilters[index].call(
        animation,
        elem,
        props,
        animation.opts
      );
      if (result) {
        if (jQuery.isFunction(result.stop)) {
          jQuery._queueHooks(
            animation.elem,
            animation.opts.queue
          ).stop = jQuery.proxy(result.stop, result);
        }
        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }

    // Attach callbacks from options
    animation
      .progress(animation.opts.progress)
      .done(animation.opts.done, animation.opts.complete)
      .fail(animation.opts.fail)
      .always(animation.opts.always);

    jQuery.fx.timer(
      jQuery.extend(tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue
      })
    );

    return animation;
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [
        function(prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        }
      ]
    },

    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }

      var prop,
        index = 0,
        length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },

    prefilters: [defaultPrefilter],

    prefilter: function(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });

  jQuery.speed = function(speed, easing, fn) {
    var opt =
      speed && typeof speed === "object"
        ? jQuery.extend({}, speed)
        : {
            complete:
              fn || (!fn && easing) || (jQuery.isFunction(speed) && speed),
            duration: speed,
            easing:
              (fn && easing) || (easing && !jQuery.isFunction(easing) && easing)
          };

    // Go to the end state if fx are off
    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    }

    // Normalize opt.queue - true/undefined/null -> "fx"
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }

    // Queueing
    opt.old = opt.complete;

    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return (
        this.filter(isHiddenWithinTree)
          .css("opacity", 0)
          .show()

          // Animate to the value specified
          .end()
          .animate({ opacity: to }, speed, easing, callback)
      );
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
        optall = jQuery.speed(speed, easing, callback),
        doAnimation = function() {
          // Operate on a copy of prop so per-property easing won't be lost
          var anim = Animation(this, jQuery.extend({}, prop), optall);

          // Empty animations, or finishing resolves immediately
          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;

      return empty || optall.queue === false
        ? this.each(doAnimation)
        : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }

      return this.each(function() {
        var dequeue = true,
          index = type != null && type + "queueHooks",
          timers = jQuery.timers,
          data = dataPriv.get(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--; ) {
          if (
            timers[index].elem === this &&
            (type == null || timers[index].queue === type)
          ) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }

        // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
          data = dataPriv.get(this),
          queue = data[type + "queue"],
          hooks = data[type + "queueHooks"],
          timers = jQuery.timers,
          length = queue ? queue.length : 0;

        // Enable finishing flag on private data
        data.finish = true;

        // Empty the queue first
        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }

        // Look for any active animations, and finish them
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }

        // Look for any animations in the old queue and finish them
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }

        // Turn off finishing flag
        delete data.finish;
      });
    }
  });

  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean"
        ? cssFn.apply(this, arguments)
        : this.animate(genFx(name, true), speed, easing, callback);
    };
  });

  // Generate shortcuts for custom animations
  jQuery.each(
    {
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" }
    },
    function(name, props) {
      jQuery.fn[name] = function(speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    }
  );

  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
      i = 0,
      timers = jQuery.timers;

    fxNow = jQuery.now();

    for (; i < timers.length; i++) {
      timer = timers[i];

      // Run the timer and safely remove it when done (allowing for external removal)
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };

  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };

  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (inProgress) {
      return;
    }

    inProgress = true;
    schedule();
  };

  jQuery.fx.stop = function() {
    inProgress = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,

    // Default speed
    _default: 400
  };

  // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";

    return this.queue(type, function(next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function() {
        window.clearTimeout(timeout);
      };
    });
  };

  (function() {
    var input = document.createElement("input"),
      select = document.createElement("select"),
      opt = select.appendChild(document.createElement("option"));

    input.type = "checkbox";

    // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"
    support.checkOn = input.value !== "";

    // Support: IE <=11 only
    // Must access selectedIndex to make default options select
    support.optSelected = opt.selected;

    // Support: IE <=11 only
    // An input loses its value after becoming a radio
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();

  var boolHook,
    attrHandle = jQuery.expr.attrHandle;

  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },

    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });

  jQuery.extend({
    attr: function(elem, name, value) {
      var ret,
        hooks,
        nType = elem.nodeType;

      // Don't get/set attributes on text, comment and attribute nodes
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      // Fallback to prop when attributes are not supported
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }

      // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks =
          jQuery.attrHooks[name.toLowerCase()] ||
          (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }

        if (
          hooks &&
          "set" in hooks &&
          (ret = hooks.set(elem, value, name)) !== undefined
        ) {
          return ret;
        }

        elem.setAttribute(name, value + "");
        return value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      ret = jQuery.find.attr(elem, name);

      // Non-existent attributes return null, we normalize to undefined
      return ret == null ? undefined : ret;
    },

    attrHooks: {
      type: {
        set: function(elem, value) {
          if (
            !support.radioValue &&
            value === "radio" &&
            nodeName(elem, "input")
          ) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    },

    removeAttr: function(elem, value) {
      var name,
        i = 0,
        // Attribute names can contain non-HTML whitespace characters
        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
        attrNames = value && value.match(rnothtmlwhite);

      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          elem.removeAttribute(name);
        }
      }
    }
  });

  // Hooks for boolean attributes
  boolHook = {
    set: function(elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };

  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    attrHandle[name] = function(elem, name, isXML) {
      var ret,
        handle,
        lowercaseName = name.toLowerCase();

      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }
      return ret;
    };
  });

  var rfocusable = /^(?:input|select|textarea|button)$/i,
    rclickable = /^(?:a|area)$/i;

  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },

    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });

  jQuery.extend({
    prop: function(elem, name, value) {
      var ret,
        hooks,
        nType = elem.nodeType;

      // Don't get/set properties on text, comment and attribute nodes
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (
          hooks &&
          "set" in hooks &&
          (ret = hooks.set(elem, value, name)) !== undefined
        ) {
          return ret;
        }

        return (elem[name] = value);
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      return elem[name];
    },

    propHooks: {
      tabIndex: {
        get: function(elem) {
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");

          if (tabindex) {
            return parseInt(tabindex, 10);
          }

          if (
            rfocusable.test(elem.nodeName) ||
            (rclickable.test(elem.nodeName) && elem.href)
          ) {
            return 0;
          }

          return -1;
        }
      }
    },

    propFix: {
      for: "htmlFor",
      class: "className"
    }
  });

  // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        /* eslint no-unused-expressions: "off" */

        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function(elem) {
        /* eslint no-unused-expressions: "off" */

        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }

  jQuery.each(
    [
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable"
    ],
    function() {
      jQuery.propFix[this.toLowerCase()] = this;
    }
  );

  // Strip and collapse whitespace according to HTML spec
  // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }

  function getClass(elem) {
    return (elem.getAttribute && elem.getAttribute("class")) || "";
  }

  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
        elem,
        cur,
        curValue,
        clazz,
        j,
        finalValue,
        i = 0;

      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }

      if (typeof value === "string" && value) {
        classes = value.match(rnothtmlwhite) || [];

        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }

            // Only assign if different to avoid unneeded rendering.
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },

    removeClass: function(value) {
      var classes,
        elem,
        cur,
        curValue,
        clazz,
        j,
        finalValue,
        i = 0;

      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }

      if (!arguments.length) {
        return this.attr("class", "");
      }

      if (typeof value === "string" && value) {
        classes = value.match(rnothtmlwhite) || [];

        while ((elem = this[i++])) {
          curValue = getClass(elem);

          // This expression is here for better compressibility (see addClass)
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }

            // Only assign if different to avoid unneeded rendering.
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },

    toggleClass: function(value, stateVal) {
      var type = typeof value;

      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(
            value.call(this, i, getClass(this), stateVal),
            stateVal
          );
        });
      }

      return this.each(function() {
        var className, i, self, classNames;

        if (type === "string") {
          // Toggle individual class names
          i = 0;
          self = jQuery(this);
          classNames = value.match(rnothtmlwhite) || [];

          while ((className = classNames[i++])) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }

          // Toggle whole class name
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            // Store className if set
            dataPriv.set(this, "__className__", className);
          }

          // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.
          if (this.setAttribute) {
            this.setAttribute(
              "class",
              className || value === false
                ? ""
                : dataPriv.get(this, "__className__") || ""
            );
          }
        }
      });
    },

    hasClass: function(selector) {
      var className,
        elem,
        i = 0;

      className = " " + selector + " ";
      while ((elem = this[i++])) {
        if (
          elem.nodeType === 1 &&
          (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1
        ) {
          return true;
        }
      }

      return false;
    }
  });

  var rreturn = /\r/g;

  jQuery.fn.extend({
    val: function(value) {
      var hooks,
        ret,
        isFunction,
        elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks =
            jQuery.valHooks[elem.type] ||
            jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (
            hooks &&
            "get" in hooks &&
            (ret = hooks.get(elem, "value")) !== undefined
          ) {
            return ret;
          }

          ret = elem.value;

          // Handle most common string cases
          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          }

          // Handle cases where value is null/undef or number
          return ret == null ? "" : ret;
        }

        return;
      }

      isFunction = jQuery.isFunction(value);

      return this.each(function(i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }

        // Treat null/undefined as ""; convert numbers to string
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }

        hooks =
          jQuery.valHooks[this.type] ||
          jQuery.valHooks[this.nodeName.toLowerCase()];

        // If set returns undefined, fall back to normal setting
        if (
          !hooks ||
          !("set" in hooks) ||
          hooks.set(this, val, "value") === undefined
        ) {
          this.value = val;
        }
      });
    }
  });

  jQuery.extend({
    valHooks: {
      option: {
        get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null
            ? val
            : // Support: IE <=10 - 11 only
              // option.text throws exceptions (#14686, #14858)
              // Strip and collapse whitespace
              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
              stripAndCollapse(jQuery.text(elem));
        }
      },
      select: {
        get: function(elem) {
          var value,
            option,
            i,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one",
            values = one ? null : [],
            max = one ? index + 1 : options.length;

          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          }

          // Loop through all the selected options
          for (; i < max; i++) {
            option = options[i];

            // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (#2551)
            if (
              (option.selected || i === index) &&
              // Don't return options that are disabled or in a disabled optgroup
              !option.disabled &&
              (!option.parentNode.disabled ||
                !nodeName(option.parentNode, "optgroup"))
            ) {
              // Get the specific value for the option
              value = jQuery(option).val();

              // We don't need an array for one selects
              if (one) {
                return value;
              }

              // Multi-Selects return an array
              values.push(value);
            }
          }

          return values;
        },

        set: function(elem, value) {
          var optionSet,
            option,
            options = elem.options,
            values = jQuery.makeArray(value),
            i = options.length;

          while (i--) {
            option = options[i];

            /* eslint-disable no-cond-assign */

            if (
              (option.selected =
                jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1)
            ) {
              optionSet = true;
            }

            /* eslint-enable no-cond-assign */
          }

          // Force browsers to behave consistently when non-matching value is set
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }
  });

  // Radios and checkboxes getter/setter
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {
      set: function(elem, value) {
        if (Array.isArray(value)) {
          return (elem.checked =
            jQuery.inArray(jQuery(elem).val(), value) > -1);
        }
      }
    };
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });

  // Return jQuery for attributes-only inclusion

  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

  jQuery.extend(jQuery.event, {
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
        cur,
        tmp,
        bubbleType,
        ontype,
        handle,
        special,
        eventPath = [elem || document],
        type = hasOwn.call(event, "type") ? event.type : event,
        namespaces = hasOwn.call(event, "namespace")
          ? event.namespace.split(".")
          : [];

      cur = tmp = elem = elem || document;

      // Don't do events on text and comment nodes
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }

      // focus/blur morphs to focusin/out; ensure we're not firing them right now
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;

      // Caller can pass in a jQuery.Event object, Object, or just an event type string
      event = event[jQuery.expando]
        ? event
        : new jQuery.Event(type, typeof event === "object" && event);

      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace
        ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)")
        : null;

      // Clean up the event in case it is being reused
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }

      // Clone any incoming data and prepend the event, creating the handler arg list
      data = data == null ? [event] : jQuery.makeArray(data, [event]);

      // Allow special events to draw outside the lines
      special = jQuery.event.special[type] || {};
      if (
        !onlyHandlers &&
        special.trigger &&
        special.trigger.apply(elem, data) === false
      ) {
        return;
      }

      // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }

        // Only add window if we got to document (e.g., not plain obj or detached DOM)
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }

      // Fire handlers on the event path
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;

        // jQuery handler
        handle =
          (dataPriv.get(cur, "events") || {})[event.type] &&
          dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }

        // Native handler
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;

      // If nobody prevented the default action, do it now
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if (
          (!special._default ||
            special._default.apply(eventPath.pop(), data) === false) &&
          acceptData(elem)
        ) {
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (
            ontype &&
            jQuery.isFunction(elem[type]) &&
            !jQuery.isWindow(elem)
          ) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            }

            // Prevent re-triggering of the same event, since we already bubbled it above
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },

    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });

      jQuery.event.trigger(e, null, elem);
    }
  });

  jQuery.fn.extend({
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });

  jQuery.each(
    (
      "blur focus focusin focusout resize scroll click dblclick " +
      "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
      "change select submit keydown keypress keyup contextmenu"
    ).split(" "),
    function(i, name) {
      // Handle event binding
      jQuery.fn[name] = function(data, fn) {
        return arguments.length > 0
          ? this.on(name, null, data, fn)
          : this.trigger(name);
      };
    }
  );

  jQuery.fn.extend({
    hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });

  support.focusin = "onfocusin" in window;

  // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
  if (!support.focusin) {
    jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };

      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
            attaches = dataPriv.access(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
            attaches = dataPriv.access(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  var location = window.location;

  var nonce = jQuery.now();

  var rquery = /\?/;

  // Cross-browser xml parsing
  jQuery.parseXML = function(data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }

    // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.
    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }

    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };

  var rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (Array.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(
            prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
            v,
            traditional,
            add
          );
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  }

  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function(a, traditional) {
    var prefix,
      s = [],
      add = function(key, valueOrFunction) {
        // If value is a function, invoke it and use its return value
        var value = jQuery.isFunction(valueOrFunction)
          ? valueOrFunction()
          : valueOrFunction;

        s[s.length] =
          encodeURIComponent(key) +
          "=" +
          encodeURIComponent(value == null ? "" : value);
      };

    // If an array was passed in, assume that it is an array of form elements.
    if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      // Serialize the form elements
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }

    // Return the resulting serialization
    return s.join("&");
  };

  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      })
        .filter(function() {
          var type = this.type;

          // Use .is( ":disabled" ) so that fieldset[disabled] works
          return (
            this.name &&
            !jQuery(this).is(":disabled") &&
            rsubmittable.test(this.nodeName) &&
            !rsubmitterTypes.test(type) &&
            (this.checked || !rcheckableType.test(type))
          );
        })
        .map(function(i, elem) {
          var val = jQuery(this).val();

          if (val == null) {
            return null;
          }

          if (Array.isArray(val)) {
            return jQuery.map(val, function(val) {
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            });
          }

          return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        })
        .get();
    }
  });

  var r20 = /%20/g,
    rhash = /#.*$/,
    rantiCache = /([?&])_=[^&]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
    prefilters = {},
    /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
    transports = {},
    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"),
    // Anchor tag for parsing the document origin
    originAnchor = document.createElement("a");
  originAnchor.href = location.href;

  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
        i = 0,
        dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

      if (jQuery.isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while ((dataType = dataTypes[i++])) {
          // Prepend if requested
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);

            // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }

  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports(
    structure,
    options,
    originalOptions,
    jqXHR
  ) {
    var inspected = {},
      seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(
          options,
          originalOptions,
          jqXHR
        );
        if (
          typeof dataTypeOrTransport === "string" &&
          !seekingTransport &&
          !inspected[dataTypeOrTransport]
        ) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || (!inspected["*"] && inspect("*"));
  }

  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend(target, src) {
    var key,
      deep,
      flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }

  /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
      type,
      finalDataType,
      firstDataType,
      contents = s.contents,
      dataTypes = s.dataTypes;

    // Remove auto dataType and get content-type in the process
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }

    // Check if we're dealing with a known content-type
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }

    // Check to see if we have a response for the expected dataType
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }

      // Or just use first one
      finalDataType = finalDataType || firstDataType;
    }

    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }

  /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
      current,
      conv,
      tmp,
      prev,
      converters = {},
      // Work with a copy of dataTypes in case we need to modify it for conversion
      dataTypes = s.dataTypes.slice();

    // Create converters map with lowercased keys
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift();

    // Convert to each sequential dataType
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }

      // Apply the dataFilter if provided
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev;

          // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current];

          // If none found, seek a pair
          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv =
                  converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2];

                    // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }

          // Apply converter (if not an equivalence)
          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv
                    ? e
                    : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }

    return { state: "success", data: response };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,

    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},

    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

      /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },

      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },

      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },

      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,

        // Text to html (true = no transformation)
        "text html": true,

        // Evaluate text as a json expression
        "text json": JSON.parse,

        // Parse text as xml
        "text xml": jQuery.parseXML
      },

      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },

    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function(target, settings) {
      return settings
        ? // Building a settings object
          ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
        : // Extending ajaxSettings
          ajaxExtend(jQuery.ajaxSettings, target);
    },

    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),

    // Main method
    ajax: function(url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }

      // Force options to be an object
      options = options || {};

      var transport,
        // URL without anti-cache param
        cacheURL,
        // Response headers
        responseHeadersString,
        responseHeaders,
        // timeout handle
        timeoutTimer,
        // Url cleanup var
        urlAnchor,
        // Request state (becomes false upon send and true upon completion)
        completed,
        // To know if global events are to be dispatched
        fireGlobals,
        // Loop variable
        i,
        // uncached part of the url
        uncached,
        // Create the final options object
        s = jQuery.ajaxSetup({}, options),
        // Callbacks context
        callbackContext = s.context || s,
        // Context for global events is callbackContext if it is a DOM node or jQuery collection
        globalEventContext =
          s.context && (callbackContext.nodeType || callbackContext.jquery)
            ? jQuery(callbackContext)
            : jQuery.event,
        // Deferreds
        deferred = jQuery.Deferred(),
        completeDeferred = jQuery.Callbacks("once memory"),
        // Status-dependent callbacks
        statusCode = s.statusCode || {},
        // Headers (they are sent all at once)
        requestHeaders = {},
        requestHeadersNames = {},
        // Default abort message
        strAbort = "canceled",
        // Fake xhr
        jqXHR = {
          readyState: 0,

          // Builds headers hashtable if needed
          getResponseHeader: function(key) {
            var match;
            if (completed) {
              if (!responseHeaders) {
                responseHeaders = {};
                while ((match = rheaders.exec(responseHeadersString))) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },

          // Raw string
          getAllResponseHeaders: function() {
            return completed ? responseHeadersString : null;
          },

          // Caches the header
          setRequestHeader: function(name, value) {
            if (completed == null) {
              name = requestHeadersNames[name.toLowerCase()] =
                requestHeadersNames[name.toLowerCase()] || name;
              requestHeaders[name] = value;
            }
            return this;
          },

          // Overrides response content-type header
          overrideMimeType: function(type) {
            if (completed == null) {
              s.mimeType = type;
            }
            return this;
          },

          // Status-dependent callbacks
          statusCode: function(map) {
            var code;
            if (map) {
              if (completed) {
                // Execute the appropriate callbacks
                jqXHR.always(map[jqXHR.status]);
              } else {
                // Lazy-add the new callbacks in a way that preserves old ones
                for (code in map) {
                  statusCode[code] = [statusCode[code], map[code]];
                }
              }
            }
            return this;
          },

          // Cancel the request
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };

      // Attach deferreds
      deferred.promise(jqXHR);

      // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available
      s.url = ((url || s.url || location.href) + "").replace(
        rprotocol,
        location.protocol + "//"
      );

      // Alias method option to type as per ticket #12004
      s.type = options.method || options.type || s.method || s.type;

      // Extract dataTypes list
      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [
        ""
      ];

      // A cross-domain request is in order when the origin doesn't match the current origin.
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");

        // Support: IE <=8 - 11, Edge 12 - 13
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/
        try {
          urlAnchor.href = s.url;

          // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative
          urlAnchor.href = urlAnchor.href;
          s.crossDomain =
            originAnchor.protocol + "//" + originAnchor.host !==
            urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      }

      // Convert data if not already a string
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }

      // Apply prefilters
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

      // If request was aborted inside a prefilter, stop there
      if (completed) {
        return jqXHR;
      }

      // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
      fireGlobals = jQuery.event && s.global;

      // Watch for a new set of requests
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }

      // Uppercase the type
      s.type = s.type.toUpperCase();

      // Determine if request has content
      s.hasContent = !rnoContent.test(s.type);

      // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation
      cacheURL = s.url.replace(rhash, "");

      // More options handling for requests with no content
      if (!s.hasContent) {
        // Remember the hash so we can put it back
        uncached = s.url.slice(cacheURL.length);

        // If data is available, append data to url
        if (s.data) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

          // #9682: remove data so that it's not used in an eventual retry
          delete s.data;
        }

        // Add or update anti-cache param if needed
        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached =
            (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
        }

        // Put hash and anti-cache on the URL that will be requested (gh-1732)
        s.url = cacheURL + uncached;

        // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if (
        s.data &&
        s.processData &&
        (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0
      ) {
        s.data = s.data.replace(r20, "+");
      }

      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader(
            "If-Modified-Since",
            jQuery.lastModified[cacheURL]
          );
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }

      // Set the correct header, if data is being sent
      if (
        (s.data && s.hasContent && s.contentType !== false) ||
        options.contentType
      ) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }

      // Set the Accepts header for the server, depending on the dataType
      jqXHR.setRequestHeader(
        "Accept",
        s.dataTypes[0] && s.accepts[s.dataTypes[0]]
          ? s.accepts[s.dataTypes[0]] +
            (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "")
          : s.accepts["*"]
      );

      // Check for headers option
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }

      // Allow custom headers/mimetypes and early abort
      if (
        s.beforeSend &&
        (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)
      ) {
        // Abort if not done already and return
        return jqXHR.abort();
      }

      // Aborting is no longer a cancellation
      strAbort = "abort";

      // Install callbacks on deferreds
      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error);

      // Get transport
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

      // If no transport, we auto-abort
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;

        // Send global event
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }

        // If request was aborted inside ajaxSend, stop there
        if (completed) {
          return jqXHR;
        }

        // Timeout
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Rethrow post-completion exceptions
          if (completed) {
            throw e;
          }

          // Propagate others as results
          done(-1, e);
        }
      }

      // Callback for when everything is done
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
          success,
          error,
          response,
          modified,
          statusText = nativeStatusText;

        // Ignore repeat invocations
        if (completed) {
          return;
        }

        completed = true;

        // Clear timeout if it exists
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }

        // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)
        transport = undefined;

        // Cache response headers
        responseHeadersString = headers || "";

        // Set readyState
        jqXHR.readyState = status > 0 ? 4 : 0;

        // Determine if successful
        isSuccess = (status >= 200 && status < 300) || status === 304;

        // Get response data
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }

        // Convert no matter what (that way responseXXX fields are always set)
        response = ajaxConvert(s, response, jqXHR, isSuccess);

        // If successful, handle type chaining
        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }

          // if no content
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";

            // if not modified
          } else if (status === 304) {
            statusText = "notmodified";

            // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }

        // Set data for the fake xhr object
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";

        // Success/Error
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }

        // Status-dependent callbacks
        jqXHR.statusCode(statusCode);
        statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [
            jqXHR,
            s,
            isSuccess ? success : error
          ]);
        }

        // Complete
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

          // Handle the global AJAX counter
          if (!--jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },

    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },

    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });

  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }

      // The url can be an options object (which then must have .url)
      return jQuery.ajax(
        jQuery.extend(
          {
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
          },
          jQuery.isPlainObject(url) && url
        )
      );
    };
  });

  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,

      // Make this explicit, since user can override this through ajaxSetup (#11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      throws: true
    });
  };

  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;

      if (this[0]) {
        if (jQuery.isFunction(html)) {
          html = html.call(this[0]);
        }

        // The elements to wrap the target around
        wrap = jQuery(html, this[0].ownerDocument)
          .eq(0)
          .clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap
          .map(function() {
            var elem = this;

            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }

            return elem;
          })
          .append(this);
      }

      return this;
    },

    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function() {
        var self = jQuery(this),
          contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },

    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);

      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },

    unwrap: function(selector) {
      this.parent(selector)
        .not("body")
        .each(function() {
          jQuery(this).replaceWith(this.childNodes);
        });
      return this;
    }
  });

  jQuery.expr.pseudos.hidden = function(elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };
  jQuery.expr.pseudos.visible = function(elem) {
    return !!(
      elem.offsetWidth ||
      elem.offsetHeight ||
      elem.getClientRects().length
    );
  };

  jQuery.ajaxSettings.xhr = function() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };

  var xhrSuccessStatus = {
      // File protocol always yields status code 0, assume 200
      0: 200,

      // Support: IE <=9 only
      // #1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    },
    xhrSupported = jQuery.ajaxSettings.xhr();

  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;

  jQuery.ajaxTransport(function(options) {
    var callback, errorCallback;

    // Cross domain only allowed if supported through XMLHttpRequest
    if (support.cors || (xhrSupported && !options.crossDomain)) {
      return {
        send: function(headers, complete) {
          var i,
            xhr = options.xhr();

          xhr.open(
            options.type,
            options.url,
            options.async,
            options.username,
            options.password
          );

          // Apply custom fields if provided
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }

          // Override mime type if needed
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }

          // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }

          // Set headers
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }

          // Callback
          callback = function(type) {
            return function() {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(
                      // File: protocol always yields status 0; see #8605, #14207
                      xhr.status,
                      xhr.statusText
                    );
                  }
                } else {
                  complete(
                    xhrSuccessStatus[xhr.status] || xhr.status,
                    xhr.statusText,

                    // Support: IE <=9 only
                    // IE9 has no XHR2 but throws on binary (trac-11426)
                    // For XHR2 non-text, let the caller handle it (gh-2498)
                    (xhr.responseType || "text") !== "text" ||
                    typeof xhr.responseText !== "string"
                      ? { binary: xhr.response }
                      : { text: xhr.responseText },
                    xhr.getAllResponseHeaders()
                  );
                }
              }
            };
          };

          // Listen to events
          xhr.onload = callback();
          errorCallback = xhr.onerror = callback("error");

          // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function() {
              // Check readyState before timeout as it changes
              if (xhr.readyState === 4) {
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout(function() {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          }

          // Create the abort callback
          callback = callback("abort");

          try {
            // Do send the request (this may raise an exception)
            xhr.send((options.hasContent && options.data) || null);
          } catch (e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if (callback) {
              throw e;
            }
          }
        },

        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });

  // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
  jQuery.ajaxPrefilter(function(s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  });

  // Install script dataType
  jQuery.ajaxSetup({
    accepts: {
      script:
        "text/javascript, application/javascript, " +
        "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });

  // Handle cache's special case and crossDomain
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });

  // Bind script tag hack transport
  jQuery.ajaxTransport("script", function(s) {
    // This transport only deals with cross domain requests
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>")
            .prop({
              charset: s.scriptCharset,
              src: s.url
            })
            .on(
              "load error",
              (callback = function(evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              })
            );

          // Use native DOM manipulation to avoid our domManip AJAX trickery
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });

  var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;

  // Default jsonp settings
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
      this[callback] = true;
      return callback;
    }
  });

  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
      overwritten,
      responseContainer,
      jsonProp =
        s.jsonp !== false &&
        (rjsonp.test(s.url)
          ? "url"
          : typeof s.data === "string" &&
            (s.contentType || "").indexOf(
              "application/x-www-form-urlencoded"
            ) === 0 &&
            rjsonp.test(s.data) &&
            "data");

    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback)
        ? s.jsonpCallback()
        : s.jsonpCallback;

      // Insert callback into url or form data
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url +=
          (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }

      // Use data converter to retrieve json after script execution
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };

      // Force json dataType
      s.dataTypes[0] = "json";

      // Install callback
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };

      // Clean-up function (fires after converters)
      jqXHR.always(function() {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);

          // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        }

        // Save back as free
        if (s[callbackName]) {
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback;

          // Save the callback name for future use
          oldCallbacks.push(callbackName);
        }

        // Call if it was a function and we have a response
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      });

      // Delegate to script
      return "script";
    }
  });

  // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337
  support.createHTMLDocument = (function() {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  })();

  // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }

    var base, parsed, scripts;

    if (!context) {
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument("");

        // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)
        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }

    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && [];

    // Single tag
    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };

  /**
   * Load a url into a page
   */
  jQuery.fn.load = function(url, params, callback) {
    var selector,
      type,
      response,
      self = this,
      off = url.indexOf(" ");

    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    }

    // If it's a function
    if (jQuery.isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined;

      // Otherwise, build a param string
    } else if (params && typeof params === "object") {
      type = "POST";
    }

    // If we have elements to modify, make the request
    if (self.length > 0) {
      jQuery
        .ajax({
          url: url,

          // If "type" variable is undefined, then "GET" method will be used.
          // Make value of this field explicit since
          // user can override it through ajaxSetup method
          type: type || "GET",
          dataType: "html",
          data: params
        })
        .done(function(responseText) {
          // Save response for use in complete callback
          response = arguments;

          self.html(
            selector
              ? // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>")
                  .append(jQuery.parseHTML(responseText))
                  .find(selector)
              : // Otherwise use the full result
                responseText
          );

          // If the request succeeds, this function gets "data", "status", "jqXHR"
          // but they are ignored because response was set above.
          // If it fails, this function gets "jqXHR", "status", "error"
        })
        .always(
          callback &&
            function(jqXHR, status) {
              self.each(function() {
                callback.apply(
                  this,
                  response || [jqXHR.responseText, status, jqXHR]
                );
              });
            }
        );
    }

    return this;
  };

  // Attach a bunch of functions for handling common AJAX events
  jQuery.each(
    [
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend"
    ],
    function(i, type) {
      jQuery.fn[type] = function(fn) {
        return this.on(type, fn);
      };
    }
  );

  jQuery.expr.pseudos.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };

  jQuery.offset = {
    setOffset: function(elem, options, i) {
      var curPosition,
        curLeft,
        curCSSTop,
        curTop,
        curOffset,
        curCSSLeft,
        calculatePosition,
        position = jQuery.css(elem, "position"),
        curElem = jQuery(elem),
        props = {};

      // Set position first, in-case top/left are set even on static elem
      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition =
        (position === "absolute" || position === "fixed") &&
        (curCSSTop + curCSSLeft).indexOf("auto") > -1;

      // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (jQuery.isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };

  jQuery.fn.extend({
    offset: function(options) {
      // Preserve chaining for setter
      if (arguments.length) {
        return options === undefined
          ? this
          : this.each(function(i) {
              jQuery.offset.setOffset(this, options, i);
            });
      }

      var doc,
        docElem,
        rect,
        win,
        elem = this[0];

      if (!elem) {
        return;
      }

      // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error
      if (!elem.getClientRects().length) {
        return { top: 0, left: 0 };
      }

      rect = elem.getBoundingClientRect();

      doc = elem.ownerDocument;
      docElem = doc.documentElement;
      win = doc.defaultView;

      return {
        top: rect.top + win.pageYOffset - docElem.clientTop,
        left: rect.left + win.pageXOffset - docElem.clientLeft
      };
    },

    position: function() {
      if (!this[0]) {
        return;
      }

      var offsetParent,
        offset,
        elem = this[0],
        parentOffset = { top: 0, left: 0 };

      // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
      // because it is its only offset parent
      if (jQuery.css(elem, "position") === "fixed") {
        // Assume getBoundingClientRect is there when computed position is fixed
        offset = elem.getBoundingClientRect();
      } else {
        // Get *real* offsetParent
        offsetParent = this.offsetParent();

        // Get correct offsets
        offset = this.offset();
        if (!nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }

        // Add offsetParent borders
        parentOffset = {
          top:
            parentOffset.top +
            jQuery.css(offsetParent[0], "borderTopWidth", true),
          left:
            parentOffset.left +
            jQuery.css(offsetParent[0], "borderLeftWidth", true)
        };
      }

      // Subtract parent offsets and element margins
      return {
        top:
          offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left:
          offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },

    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent;

        while (
          offsetParent &&
          jQuery.css(offsetParent, "position") === "static"
        ) {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || documentElement;
      });
    }
  });

  // Create scrollLeft and scrollTop methods
  jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(
    method,
    prop
  ) {
    var top = "pageYOffset" === prop;

    jQuery.fn[method] = function(val) {
      return access(
        this,
        function(elem, method, val) {
          // Coalesce documents and windows
          var win;
          if (jQuery.isWindow(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }

          if (val === undefined) {
            return win ? win[prop] : elem[method];
          }

          if (win) {
            win.scrollTo(
              !top ? val : win.pageXOffset,
              top ? val : win.pageYOffset
            );
          } else {
            elem[method] = val;
          }
        },
        method,
        val,
        arguments.length
      );
    };
  });

  // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(
      elem,
      computed
    ) {
      if (computed) {
        computed = curCSS(elem, prop);

        // If curCSS returns percentage, fallback to offset
        return rnumnonpx.test(computed)
          ? jQuery(elem).position()[prop] + "px"
          : computed;
      }
    });
  });

  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
    jQuery.each(
      { padding: "inner" + name, content: type, "": "outer" + name },
      function(defaultExtra, funcName) {
        // Margin is only for outerHeight, outerWidth
        jQuery.fn[funcName] = function(margin, value) {
          var chainable =
              arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra =
              defaultExtra ||
              (margin === true || value === true ? "margin" : "border");

          return access(
            this,
            function(elem, type, value) {
              var doc;

              if (jQuery.isWindow(elem)) {
                // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                return funcName.indexOf("outer") === 0
                  ? elem["inner" + name]
                  : elem.document.documentElement["client" + name];
              }

              // Get document width or height
              if (elem.nodeType === 9) {
                doc = elem.documentElement;

                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                // whichever is greatest
                return Math.max(
                  elem.body["scroll" + name],
                  doc["scroll" + name],
                  elem.body["offset" + name],
                  doc["offset" + name],
                  doc["client" + name]
                );
              }

              return value === undefined
                ? // Get width or height on the element, requesting but not forcing parseFloat
                  jQuery.css(elem, type, extra)
                : // Set width or height on the element
                  jQuery.style(elem, type, value, extra);
            },
            type,
            chainable ? margin : undefined,
            chainable
          );
        };
      }
    );
  });

  jQuery.fn.extend({
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },

    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1
        ? this.off(selector, "**")
        : this.off(types, selector || "**", fn);
    }
  });

  jQuery.holdReady = function(hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };
  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;

  // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.

  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return jQuery;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  var // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,
    // Map over the $ in case of overwrite
    _$ = window.$;

  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  };

  // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }

  return jQuery;
});


/***/ }),
/* 6 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = (module.exports =
  typeof window != "undefined" && window.Math == Math
    ? window
    : typeof self != "undefined" && self.Math == Math
      ? self
      : // eslint-disable-next-line no-new-func
        Function("return this")());
if (typeof __g == "number") __g = global; // eslint-disable-line no-undef


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(6);
var core = __webpack_require__(1);
var ctx = __webpack_require__(18);
var hide = __webpack_require__(20);
var PROTOTYPE = "prototype";

var $export = function(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL
    ? global
    : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] =
      IS_GLOBAL && typeof target[key] != "function"
        ? source[key]
        : // bind timers to global for call from export context
          IS_BIND && own
          ? ctx(out, global)
          : // wrap global constructors for prevent change them in library
            IS_WRAP && target[key] == out
            ? (function(C) {
                var F = function(a, b, c) {
                  if (this instanceof C) {
                    switch (arguments.length) {
                      case 0:
                        return new C();
                      case 1:
                        return new C(a);
                      case 2:
                        return new C(a, b);
                    }
                    return new C(a, b, c);
                  }
                  return C.apply(this, arguments);
                };
                F[PROTOTYPE] = C[PROTOTYPE];
                return F;
                // make static versions for prototype methods
              })(out)
            : IS_PROTO && typeof out == "function"
              ? ctx(Function.call, out)
              : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key])
        hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 8 */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(2);
module.exports = function(it) {
  if (!isObject(it)) throw TypeError(it + " is not an object!");
  return it;
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
  !__webpack_require__(0) &&
  !__webpack_require__(4)(function() {
    return (
      Object.defineProperty(__webpack_require__(21)("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7
    );
  });


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(2);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (
    S &&
    typeof (fn = it.toString) == "function" &&
    !isObject((val = fn.call(it)))
  )
    return val;
  if (typeof (fn = it.valueOf) == "function" && !isObject((val = fn.call(it))))
    return val;
  if (
    !S &&
    typeof (fn = it.toString) == "function" &&
    !isObject((val = fn.call(it)))
  )
    return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(37);
var defined = __webpack_require__(39);
module.exports = function(it) {
  return IObject(defined(it));
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

(function(window, factory) {
  var lazySizes = factory(window, window.document);
  window.lazySizes = lazySizes;
  if (typeof module == "object" && module.exports) {
    module.exports = lazySizes;
  }
})(window, function l(window, document) {
  "use strict";
  /*jshint eqnull:true */
  if (!document.getElementsByClassName) {
    return;
  }

  var lazysizes, lazySizesConfig;

  var docElem = document.documentElement;

  var Date = window.Date;

  var supportPicture = window.HTMLPictureElement;

  var _addEventListener = "addEventListener";

  var _getAttribute = "getAttribute";

  var addEventListener = window[_addEventListener];

  var setTimeout = window.setTimeout;

  var requestAnimationFrame = window.requestAnimationFrame || setTimeout;

  var requestIdleCallback = window.requestIdleCallback;

  var regPicture = /^picture$/i;

  var loadEvents = ["load", "error", "lazyincluded", "_lazyloaded"];

  var regClassCache = {};

  var forEach = Array.prototype.forEach;

  var hasClass = function(ele, cls) {
    if (!regClassCache[cls]) {
      regClassCache[cls] = new RegExp("(\\s|^)" + cls + "(\\s|$)");
    }
    return (
      regClassCache[cls].test(ele[_getAttribute]("class") || "") &&
      regClassCache[cls]
    );
  };

  var addClass = function(ele, cls) {
    if (!hasClass(ele, cls)) {
      ele.setAttribute(
        "class",
        (ele[_getAttribute]("class") || "").trim() + " " + cls
      );
    }
  };

  var removeClass = function(ele, cls) {
    var reg;
    if ((reg = hasClass(ele, cls))) {
      ele.setAttribute(
        "class",
        (ele[_getAttribute]("class") || "").replace(reg, " ")
      );
    }
  };

  var addRemoveLoadEvents = function(dom, fn, add) {
    var action = add ? _addEventListener : "removeEventListener";
    if (add) {
      addRemoveLoadEvents(dom, fn);
    }
    loadEvents.forEach(function(evt) {
      dom[action](evt, fn);
    });
  };

  var triggerEvent = function(elem, name, detail, noBubbles, noCancelable) {
    var event = document.createEvent("CustomEvent");

    if (!detail) {
      detail = {};
    }

    detail.instance = lazysizes;

    event.initCustomEvent(name, !noBubbles, !noCancelable, detail);

    elem.dispatchEvent(event);
    return event;
  };

  var updatePolyfill = function(el, full) {
    var polyfill;
    if (
      !supportPicture &&
      (polyfill = window.picturefill || lazySizesConfig.pf)
    ) {
      polyfill({ reevaluate: true, elements: [el] });
    } else if (full && full.src) {
      el.src = full.src;
    }
  };

  var getCSS = function(elem, style) {
    return (getComputedStyle(elem, null) || {})[style];
  };

  var getWidth = function(elem, parent, width) {
    width = width || elem.offsetWidth;

    while (width < lazySizesConfig.minSize && parent && !elem._lazysizesWidth) {
      width = parent.offsetWidth;
      parent = parent.parentNode;
    }

    return width;
  };

  var rAF = (function() {
    var running, waiting;
    var firstFns = [];
    var secondFns = [];
    var fns = firstFns;

    var run = function() {
      var runFns = fns;

      fns = firstFns.length ? secondFns : firstFns;

      running = true;
      waiting = false;

      while (runFns.length) {
        runFns.shift()();
      }

      running = false;
    };

    var rafBatch = function(fn, queue) {
      if (running && !queue) {
        fn.apply(this, arguments);
      } else {
        fns.push(fn);

        if (!waiting) {
          waiting = true;
          (document.hidden ? setTimeout : requestAnimationFrame)(run);
        }
      }
    };

    rafBatch._lsFlush = run;

    return rafBatch;
  })();

  var rAFIt = function(fn, simple) {
    return simple
      ? function() {
          rAF(fn);
        }
      : function() {
          var that = this;
          var args = arguments;
          rAF(function() {
            fn.apply(that, args);
          });
        };
  };

  var throttle = function(fn) {
    var running;
    var lastTime = 0;
    var gDelay = 125;
    var rICTimeout = lazySizesConfig.ricTimeout;
    var run = function() {
      running = false;
      lastTime = Date.now();
      fn();
    };
    var idleCallback =
      requestIdleCallback && lazySizesConfig.ricTimeout
        ? function() {
            requestIdleCallback(run, { timeout: rICTimeout });

            if (rICTimeout !== lazySizesConfig.ricTimeout) {
              rICTimeout = lazySizesConfig.ricTimeout;
            }
          }
        : rAFIt(function() {
            setTimeout(run);
          }, true);

    return function(isPriority) {
      var delay;

      if ((isPriority = isPriority === true)) {
        rICTimeout = 33;
      }

      if (running) {
        return;
      }

      running = true;

      delay = gDelay - (Date.now() - lastTime);

      if (delay < 0) {
        delay = 0;
      }

      if (isPriority || (delay < 9 && requestIdleCallback)) {
        idleCallback();
      } else {
        setTimeout(idleCallback, delay);
      }
    };
  };

  //based on http://modernjavascript.blogspot.de/2013/08/building-better-debounce.html
  var debounce = function(func) {
    var timeout, timestamp;
    var wait = 99;
    var run = function() {
      timeout = null;
      func();
    };
    var later = function() {
      var last = Date.now() - timestamp;

      if (last < wait) {
        setTimeout(later, wait - last);
      } else {
        (requestIdleCallback || run)(run);
      }
    };

    return function() {
      timestamp = Date.now();

      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
    };
  };

  (function() {
    var prop;

    var lazySizesDefaults = {
      lazyClass: "lazyload",
      loadedClass: "lazyloaded",
      loadingClass: "lazyloading",
      preloadClass: "lazypreload",
      errorClass: "lazyerror",
      //strictClass: 'lazystrict',
      autosizesClass: "lazyautosizes",
      srcAttr: "data-src",
      srcsetAttr: "data-srcset",
      sizesAttr: "data-sizes",
      //preloadAfterLoad: false,
      minSize: 40,
      customMedia: {},
      init: true,
      expFactor: 1.5,
      hFac: 0.8,
      loadMode: 2,
      loadHidden: true,
      ricTimeout: 300
    };

    lazySizesConfig = window.lazySizesConfig || window.lazysizesConfig || {};

    for (prop in lazySizesDefaults) {
      if (!(prop in lazySizesConfig)) {
        lazySizesConfig[prop] = lazySizesDefaults[prop];
      }
    }

    window.lazySizesConfig = lazySizesConfig;

    setTimeout(function() {
      if (lazySizesConfig.init) {
        init();
      }
    });
  })();

  var loader = (function() {
    var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started;

    var eLvW, elvH, eLtop, eLleft, eLright, eLbottom;

    var defaultExpand, preloadExpand, hFac;

    var regImg = /^img$/i;
    var regIframe = /^iframe$/i;

    var supportScroll =
      "onscroll" in window && !/glebot/.test(navigator.userAgent);

    var shrinkExpand = 0;
    var currentExpand = 0;

    var isLoading = 0;
    var lowRuns = -1;

    var resetPreloading = function(e) {
      isLoading--;
      if (e && e.target) {
        addRemoveLoadEvents(e.target, resetPreloading);
      }

      if (!e || isLoading < 0 || !e.target) {
        isLoading = 0;
      }
    };

    var isNestedVisible = function(elem, elemExpand) {
      var outerRect;
      var parent = elem;
      var visible =
        getCSS(document.body, "visibility") == "hidden" ||
        getCSS(elem, "visibility") != "hidden";

      eLtop -= elemExpand;
      eLbottom += elemExpand;
      eLleft -= elemExpand;
      eLright += elemExpand;

      while (
        visible &&
        (parent = parent.offsetParent) &&
        parent != document.body &&
        parent != docElem
      ) {
        visible = (getCSS(parent, "opacity") || 1) > 0;

        if (visible && getCSS(parent, "overflow") != "visible") {
          outerRect = parent.getBoundingClientRect();
          visible =
            eLright > outerRect.left &&
            eLleft < outerRect.right &&
            eLbottom > outerRect.top - 1 &&
            eLtop < outerRect.bottom + 1;
        }
      }

      return visible;
    };

    var checkElements = function() {
      var eLlen,
        i,
        rect,
        autoLoadElem,
        loadedSomething,
        elemExpand,
        elemNegativeExpand,
        elemExpandVal,
        beforeExpandVal;

      var lazyloadElems = lazysizes.elements;

      if (
        (loadMode = lazySizesConfig.loadMode) &&
        isLoading < 8 &&
        (eLlen = lazyloadElems.length)
      ) {
        i = 0;

        lowRuns++;

        if (preloadExpand == null) {
          if (!("expand" in lazySizesConfig)) {
            lazySizesConfig.expand =
              docElem.clientHeight > 500 && docElem.clientWidth > 500
                ? 500
                : 370;
          }

          defaultExpand = lazySizesConfig.expand;
          preloadExpand = defaultExpand * lazySizesConfig.expFactor;
        }

        if (
          currentExpand < preloadExpand &&
          isLoading < 1 &&
          lowRuns > 2 &&
          loadMode > 2 &&
          !document.hidden
        ) {
          currentExpand = preloadExpand;
          lowRuns = 0;
        } else if (loadMode > 1 && lowRuns > 1 && isLoading < 6) {
          currentExpand = defaultExpand;
        } else {
          currentExpand = shrinkExpand;
        }

        for (; i < eLlen; i++) {
          if (!lazyloadElems[i] || lazyloadElems[i]._lazyRace) {
            continue;
          }

          if (!supportScroll) {
            unveilElement(lazyloadElems[i]);
            continue;
          }

          if (
            !(elemExpandVal = lazyloadElems[i][_getAttribute]("data-expand")) ||
            !(elemExpand = elemExpandVal * 1)
          ) {
            elemExpand = currentExpand;
          }

          if (beforeExpandVal !== elemExpand) {
            eLvW = innerWidth + elemExpand * hFac;
            elvH = innerHeight + elemExpand;
            elemNegativeExpand = elemExpand * -1;
            beforeExpandVal = elemExpand;
          }

          rect = lazyloadElems[i].getBoundingClientRect();

          if (
            (eLbottom = rect.bottom) >= elemNegativeExpand &&
            (eLtop = rect.top) <= elvH &&
            (eLright = rect.right) >= elemNegativeExpand * hFac &&
            (eLleft = rect.left) <= eLvW &&
            (eLbottom || eLright || eLleft || eLtop) &&
            (lazySizesConfig.loadHidden ||
              getCSS(lazyloadElems[i], "visibility") != "hidden") &&
            ((isCompleted &&
              isLoading < 3 &&
              !elemExpandVal &&
              (loadMode < 3 || lowRuns < 4)) ||
              isNestedVisible(lazyloadElems[i], elemExpand))
          ) {
            unveilElement(lazyloadElems[i]);
            loadedSomething = true;
            if (isLoading > 9) {
              break;
            }
          } else if (
            !loadedSomething &&
            isCompleted &&
            !autoLoadElem &&
            isLoading < 4 &&
            lowRuns < 4 &&
            loadMode > 2 &&
            (preloadElems[0] || lazySizesConfig.preloadAfterLoad) &&
            (preloadElems[0] ||
              (!elemExpandVal &&
                (eLbottom ||
                  eLright ||
                  eLleft ||
                  eLtop ||
                  lazyloadElems[i][_getAttribute](lazySizesConfig.sizesAttr) !=
                    "auto")))
          ) {
            autoLoadElem = preloadElems[0] || lazyloadElems[i];
          }
        }

        if (autoLoadElem && !loadedSomething) {
          unveilElement(autoLoadElem);
        }
      }
    };

    var throttledCheckElements = throttle(checkElements);

    var switchLoadingClass = function(e) {
      addClass(e.target, lazySizesConfig.loadedClass);
      removeClass(e.target, lazySizesConfig.loadingClass);
      addRemoveLoadEvents(e.target, rafSwitchLoadingClass);
      triggerEvent(e.target, "lazyloaded");
    };
    var rafedSwitchLoadingClass = rAFIt(switchLoadingClass);
    var rafSwitchLoadingClass = function(e) {
      rafedSwitchLoadingClass({ target: e.target });
    };

    var changeIframeSrc = function(elem, src) {
      try {
        elem.contentWindow.location.replace(src);
      } catch (e) {
        elem.src = src;
      }
    };

    var handleSources = function(source) {
      var customMedia;

      var sourceSrcset = source[_getAttribute](lazySizesConfig.srcsetAttr);

      if (
        (customMedia =
          lazySizesConfig.customMedia[
            source[_getAttribute]("data-media") ||
              source[_getAttribute]("media")
          ])
      ) {
        source.setAttribute("media", customMedia);
      }

      if (sourceSrcset) {
        source.setAttribute("srcset", sourceSrcset);
      }
    };

    var lazyUnveil = rAFIt(function(elem, detail, isAuto, sizes, isImg) {
      var src, srcset, parent, isPicture, event, firesLoad;

      if (
        !(event = triggerEvent(elem, "lazybeforeunveil", detail))
          .defaultPrevented
      ) {
        if (sizes) {
          if (isAuto) {
            addClass(elem, lazySizesConfig.autosizesClass);
          } else {
            elem.setAttribute("sizes", sizes);
          }
        }

        srcset = elem[_getAttribute](lazySizesConfig.srcsetAttr);
        src = elem[_getAttribute](lazySizesConfig.srcAttr);

        if (isImg) {
          parent = elem.parentNode;
          isPicture = parent && regPicture.test(parent.nodeName || "");
        }

        firesLoad =
          detail.firesLoad || ("src" in elem && (srcset || src || isPicture));

        event = { target: elem };

        if (firesLoad) {
          addRemoveLoadEvents(elem, resetPreloading, true);
          clearTimeout(resetPreloadingTimer);
          resetPreloadingTimer = setTimeout(resetPreloading, 2500);

          addClass(elem, lazySizesConfig.loadingClass);
          addRemoveLoadEvents(elem, rafSwitchLoadingClass, true);
        }

        if (isPicture) {
          forEach.call(parent.getElementsByTagName("source"), handleSources);
        }

        if (srcset) {
          elem.setAttribute("srcset", srcset);
        } else if (src && !isPicture) {
          if (regIframe.test(elem.nodeName)) {
            changeIframeSrc(elem, src);
          } else {
            elem.src = src;
          }
        }

        if (isImg && (srcset || isPicture)) {
          updatePolyfill(elem, { src: src });
        }
      }

      if (elem._lazyRace) {
        delete elem._lazyRace;
      }
      removeClass(elem, lazySizesConfig.lazyClass);

      rAF(function() {
        if (!firesLoad || (elem.complete && elem.naturalWidth > 1)) {
          if (firesLoad) {
            resetPreloading(event);
          } else {
            isLoading--;
          }
          switchLoadingClass(event);
        }
      }, true);
    });

    var unveilElement = function(elem) {
      var detail;

      var isImg = regImg.test(elem.nodeName);

      //allow using sizes="auto", but don't use. it's invalid. Use data-sizes="auto" or a valid value for sizes instead (i.e.: sizes="80vw")
      var sizes =
        isImg &&
        (elem[_getAttribute](lazySizesConfig.sizesAttr) ||
          elem[_getAttribute]("sizes"));
      var isAuto = sizes == "auto";

      if (
        (isAuto || !isCompleted) &&
        isImg &&
        (elem[_getAttribute]("src") || elem.srcset) &&
        !elem.complete &&
        !hasClass(elem, lazySizesConfig.errorClass) &&
        hasClass(elem, lazySizesConfig.lazyClass)
      ) {
        return;
      }

      detail = triggerEvent(elem, "lazyunveilread").detail;

      if (isAuto) {
        autoSizer.updateElem(elem, true, elem.offsetWidth);
      }

      elem._lazyRace = true;
      isLoading++;

      lazyUnveil(elem, detail, isAuto, sizes, isImg);
    };

    var onload = function() {
      if (isCompleted) {
        return;
      }
      if (Date.now() - started < 999) {
        setTimeout(onload, 999);
        return;
      }
      var afterScroll = debounce(function() {
        lazySizesConfig.loadMode = 3;
        throttledCheckElements();
      });

      isCompleted = true;

      lazySizesConfig.loadMode = 3;

      throttledCheckElements();

      addEventListener(
        "scroll",
        function() {
          if (lazySizesConfig.loadMode == 3) {
            lazySizesConfig.loadMode = 2;
          }
          afterScroll();
        },
        true
      );
    };

    return {
      _: function() {
        started = Date.now();

        lazysizes.elements = document.getElementsByClassName(
          lazySizesConfig.lazyClass
        );
        preloadElems = document.getElementsByClassName(
          lazySizesConfig.lazyClass + " " + lazySizesConfig.preloadClass
        );
        hFac = lazySizesConfig.hFac;

        addEventListener("scroll", throttledCheckElements, true);

        addEventListener("resize", throttledCheckElements, true);

        if (window.MutationObserver) {
          new MutationObserver(throttledCheckElements).observe(docElem, {
            childList: true,
            subtree: true,
            attributes: true
          });
        } else {
          docElem[_addEventListener](
            "DOMNodeInserted",
            throttledCheckElements,
            true
          );
          docElem[_addEventListener](
            "DOMAttrModified",
            throttledCheckElements,
            true
          );
          setInterval(throttledCheckElements, 999);
        }

        addEventListener("hashchange", throttledCheckElements, true);

        //, 'fullscreenchange'
        [
          "focus",
          "mouseover",
          "click",
          "load",
          "transitionend",
          "animationend",
          "webkitAnimationEnd"
        ].forEach(function(name) {
          document[_addEventListener](name, throttledCheckElements, true);
        });

        if (/d$|^c/.test(document.readyState)) {
          onload();
        } else {
          addEventListener("load", onload);
          document[_addEventListener](
            "DOMContentLoaded",
            throttledCheckElements
          );
          setTimeout(onload, 20000);
        }

        if (lazysizes.elements.length) {
          checkElements();
          rAF._lsFlush();
        } else {
          throttledCheckElements();
        }
      },
      checkElems: throttledCheckElements,
      unveil: unveilElement
    };
  })();

  var autoSizer = (function() {
    var autosizesElems;

    var sizeElement = rAFIt(function(elem, parent, event, width) {
      var sources, i, len;
      elem._lazysizesWidth = width;
      width += "px";

      elem.setAttribute("sizes", width);

      if (regPicture.test(parent.nodeName || "")) {
        sources = parent.getElementsByTagName("source");
        for (i = 0, len = sources.length; i < len; i++) {
          sources[i].setAttribute("sizes", width);
        }
      }

      if (!event.detail.dataAttr) {
        updatePolyfill(elem, event.detail);
      }
    });
    var getSizeElement = function(elem, dataAttr, width) {
      var event;
      var parent = elem.parentNode;

      if (parent) {
        width = getWidth(elem, parent, width);
        event = triggerEvent(elem, "lazybeforesizes", {
          width: width,
          dataAttr: !!dataAttr
        });

        if (!event.defaultPrevented) {
          width = event.detail.width;

          if (width && width !== elem._lazysizesWidth) {
            sizeElement(elem, parent, event, width);
          }
        }
      }
    };

    var updateElementsSizes = function() {
      var i;
      var len = autosizesElems.length;
      if (len) {
        i = 0;

        for (; i < len; i++) {
          getSizeElement(autosizesElems[i]);
        }
      }
    };

    var debouncedUpdateElementsSizes = debounce(updateElementsSizes);

    return {
      _: function() {
        autosizesElems = document.getElementsByClassName(
          lazySizesConfig.autosizesClass
        );
        addEventListener("resize", debouncedUpdateElementsSizes);
      },
      checkElems: debouncedUpdateElementsSizes,
      updateElem: getSizeElement
    };
  })();

  var init = function() {
    if (!init.i) {
      init.i = true;
      autoSizer._();
      loader._();
    }
  };

  lazysizes = {
    cfg: lazySizesConfig,
    autoSizer: autoSizer,
    loader: loader,
    init: init,
    uP: updatePolyfill,
    aC: addClass,
    rC: removeClass,
    hC: hasClass,
    fire: triggerEvent,
    gW: getWidth,
    rAF: rAF
  };

  return lazysizes;
});


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(16);

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(17);
var $Object = __webpack_require__(1).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(7);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(0), "Object", {
  defineProperty: __webpack_require__(3).f
});


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(19);
module.exports = function(fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function(a) {
        return fn.call(that, a);
      };
    case 2:
      return function(a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function(a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function(/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = function(it) {
  if (typeof it != "function") throw TypeError(it + " is not a function!");
  return it;
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(3);
var createDesc = __webpack_require__(12);
module.exports = __webpack_require__(0)
  ? function(object, key, value) {
      return dP.f(object, key, createDesc(1, value));
    }
  : function(object, key, value) {
      object[key] = value;
      return object;
    };


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(2);
var document = __webpack_require__(6).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function(it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 22 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(7);
var core = __webpack_require__(1);
var fails = __webpack_require__(4);
module.exports = function(KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export(
    $export.S +
      $export.F *
        fails(function() {
          fn(1);
        }),
    "Object",
    exp
  );
};


/***/ }),
/* 24 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function(it) {
  return isNaN((it = +it)) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 25 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function(key) {
  return "Symbol(".concat(
    key === undefined ? "" : key,
    ")_",
    (++id + px).toString(36)
  );
};


/***/ }),
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _interopRequireDefault = __webpack_require__(8);

var _interopRequireWildcard = __webpack_require__(33);

var _taggedTemplateLiteral2 = _interopRequireDefault(__webpack_require__(42));

var _jquery = _interopRequireDefault(__webpack_require__(5));

var _modernizr = _interopRequireDefault(__webpack_require__(59));

var _dedent = _interopRequireDefault(__webpack_require__(60));

var _picturefill = _interopRequireDefault(__webpack_require__(61));

var _webfontloader = _interopRequireDefault(__webpack_require__(62));

var _responsiveNav = _interopRequireDefault(__webpack_require__(63));

var _ls = _interopRequireDefault(__webpack_require__(64));

var _ls2 = _interopRequireDefault(__webpack_require__(65));

var _ls3 = _interopRequireDefault(__webpack_require__(66));

var _lazysizes = _interopRequireDefault(__webpack_require__(14));

var _ismobilejs = _interopRequireDefault(__webpack_require__(67));

var _bowser = _interopRequireDefault(__webpack_require__(68));

var R = _interopRequireWildcard(__webpack_require__(70));

var _templateObject = /*#__PURE__*/ (0, _taggedTemplateLiteral2.default)(["A string that gets so long you need to break it over\n                     multiple lines. Luckily dedent is here to keep it\n                     readable without lots of spaces ending up in the string\n                     itself."], ["A string that gets so long you need to break it over\n                     multiple lines. Luckily dedent is here to keep it\n                     readable without lots of spaces ending up in the string\n                     itself."]);

window.$ = _jquery.default;
window.jQuery = _jquery.default;
window.R = R;
global.isMobile = _ismobilejs.default;
global.bowser = _bowser.default;

__webpack_require__(71);

__webpack_require__(72);

__webpack_require__(73);

__webpack_require__(74);

var __svg__ = { filename: __webpack_require__.p +"../../assets/images/svg/symbol.svg" };

__webpack_require__(75)(__svg__);

var detect = {
  desktop: !isMobile.any,
  mobile: isMobile.any,
  phone: isMobile.phone,
  tablet: isMobile.tablet,
  chrome: _bowser.default.chrome ? _bowser.default.version : false,
  firefox: _bowser.default.firefox ? _bowser.default.version : false,
  safari: _bowser.default.safari ? _bowser.default.version : false,
  msie: _bowser.default.msie ? _bowser.default.version : false,
  msedge: _bowser.default.msedge ? _bowser.default.version : false,
  iPhone: isMobile.apple.phone,
  androidphone: isMobile.android.phone,
  iOS: isMobile.apple.device,
  androidOS: isMobile.android.device
};
console.log(detect);

if (!_modernizr.default.objectfit) {
  console.log('non-objectfit');
} else {
  console.log('objectfit');
} // For dedent


var sectsect = (0, _dedent.default)(_templateObject);
console.log(sectsect); // if (typeof picturefill === 'function') {
//   console.log('picture!!!!!!!!');
// }
// if (typeof WebFont === 'object') {
//   console.log('WebFont!!!!!!!!');
// }
// if (typeof responsiveNav === 'function') {
//   console.log('responsiveNav!!!!!!!!');
// }

$('body').addClass('sektsekt');
var ary = R.append('foo', ['bar', 'baz']);
console.log(ary);
/*= =================================================
Google web-fonts
================================================== */

_webfontloader.default.load({
  google: {
    families: ['Crimson+Text::latin', 'Cinzel::latin', 'Italianno::latin', 'Pinyon+Script::latin']
  }
});

jQuery(function () {
  /*= =================================================
  switch viewport for tablet
  ================================================== */
  if (isMobile.tablet) {
    jQuery('#viewport').attr('content', 'width=1024');
  }
  /*= =================================================
  Detect the devicePixelRatio
  ================================================== */


  var hiDPI = !!('devicePixelRatio' in window && devicePixelRatio > 1); // console.log(hiDPI);

  /*= =================================================
  Responsible menu (responsive-nav.min.js)
  ================================================== */

  (0, _responsiveNav.default)('#nav', {
    // Selector
    //	animate 		: true,								  // Boolean: Use CSS3 transitions, true or false
    transition: 150,
    // Integer: Speed of the transition, in milliseconds
    //	label 			: "<span>Menu</span>",	// String: Label for the navigation toggle
    label: '<span>bar</span><i>MENU</i>',
    // String: Label for the navigation toggle
    //	insert 			: "before",							// String: Insert the toggle before or after the navigation
    //	customToggle 	: "#nav-toggle",			// Selector: Specify the ID of a custom toggle
    //	closeOnNavClick	: false,						// Boolean: Close the navigation when one of the links are clicked
    //	openPos			: "static",							// String: Position of the opened nav, relative or static
    //	navClass		: "nav-collapse",				// String: Default CSS class. If changed, you need to edit the CSS too!
    //	navActiveClass	: "js-nav-active",	// String: Class that is added to element when nav is active
    //	jsClass			: "js",								  // String: 'JS enabled' class which is added to element
    init: function init() {
      jQuery('#nav').show();
    }
  } // Function: Init callback
  //	open	: function() {},							// Function: Open callback
  //	close	: function() {}								// Function: Close callback
  );
  /*= =================================================
  fadein /fadeout button Pagetop
  ================================================== */

  /* if (!isMobile.phone) {
   const topBtn = jQuery('#pagetop');
   //	100
   jQuery(window).scroll(function () {
    if (jQuery(this).scrollTop() > 100) {
    topBtn.addClass('show');
      } else {
        topBtn.removeClass('show');
      }
    });
  }
  */

  /*= =================================================
  Image fadeIn / fadeOut
  ================================================== */
  // // we use touchstart and touchend events on buttons
  // let enterEvent = 'touchstart';
  // let leaveEvent = 'touchend';
  // // we use mousedown and mouseup events on big items
  // let enterBigEvent = 'mousedown';
  // let leaveBigEvent = 'mouseup';
  // if (!('ontouchstart' in window)) {
  //   enterEvent = 'mouseenter';
  //   enterBigEvent = 'mouseenter';
  //   leaveEvent = 'mouseleave';
  //   leaveBigEvent = 'mouseleave';
  // }
  // jQuery('main a').not('.home #sec_recommend .bxslider li a').on(enterEvent, function (e) {
  //   jQuery(this).find('img').addClass('on');
  // });
  // jQuery('main a').not('.home #sec_recommend .bxslider li a').on(leaveEvent, function (e) {
  //   jQuery(this).find('img').removeClass('on');
  // });
});
jQuery.event.add(window, 'load', function () {
  /*= =================================================
  	Text Truncation
  ================================================== */
  if (jQuery('.truncation').length) {
    jQuery('.truncation').dotdotdot({
      watch: 'window',
      truncate: 'letter',
      callback: function callback(isTruncated) {
        jQuery(this).addClass('ready');
      }
    });
  }
  /*= =================================================
  smooth scroll
  ================================================== */


  var h = parseInt("-".concat(jQuery('#header').outerHeight(true)), 10);
  jQuery("a[href^='#']").on('click', function () {
    var offset = jQuery(this).parent().hasClass('pageTop') ? 0 : h;
    var target = jQuery(this).attr('href');
    $.smoothScroll({
      easing: 'easeOutQuint',
      speed: 800,
      offset: offset,
      scrollTarget: target
    });
    return false;
  });
  var headerH = jQuery('#header').outerHeight(true); //	

  var url = jQuery(window.location).attr('href');

  if (url.indexOf('?id=') === -1) {//	Do Noting
  } else {
    var urlsp = url.split('?id=');
    var hash = "#".concat(urlsp[urlsp.length - 1]);
    var tgt = jQuery(hash);
    setTimeout(function () {
      var pos = tgt.offset().top - headerH; //	headerH 

      jQuery('html, body').animate({
        scrollTop: pos
      }, 1000, 'easeOutQuint');
    }, 300);
  }
});
jQuery(window).on('load orientationchange resize', function () {
  /*= =================================================
  Lazyload
  ================================================== */
  // // CASE: Less than Equal "IE8"
  // if (typeof LazyLoad == "function") {
  // 	new LazyLoad({
  // 		data_src          : "src",
  // 		data_srcset       : "srcset",
  // 		threshold         : 200,
  // 		show_while_loading: true,
  // 		placeholder       : true,
  // 		callback_set      : function(img) {
  // 			picturefill({
  // 				elements  : [img]
  // 			});
  // 		}
  // 	});
  // } else if (typeof lazySizes == "object") {
  // 	lazySizes.init();
  // }

  /*= =================================================
  Trim words	(Supported Mobile-Device) & Setting same height on column
  ================================================== */
  // if (jQuery('.trim_line1').length) {
  // 	jQuery('.trim_line1').trunk8({
  // 		tooltip: false
  // 	});
  // }
  // if (jQuery('.trim_line2').length) {
  // 	jQuery('.trim_line2').trunk8({
  // 		tooltip: false,
  // 		lines: 2
  // 	});
  // }
  // if (jQuery('.trim_line3').length) {
  // 	jQuery('.trim_line3').trunk8({
  // 		tooltip: false,
  // 		lines: 3
  // 	});
  // }
  // if (jQuery('.trim_line4').length) {
  // 	jQuery('.trim_line4').trunk8({
  // 		tooltip: false,
  // 		lines: 4
  // 	});
  // }
  // if (jQuery('.trim_line5').length) {
  // 	jQuery('.trim_line5').trunk8({
  // 		tooltip: false,
  // 		lines: 5
  // 	});
  // }

  /*= =================================================
  match height (jQuery.matchheight.js)
  ================================================== */
  jQuery('.mh-byrow').matchHeight();
  jQuery('.mh').matchHeight({
    byRow: false
  }); // USAGE:	Case: multiple
  // <ul>
  // 	<li data-mh="group-01" class="mh">My text</li>
  // 	<li data-mh="group-01" class="mh">My text</li>
  // </ul>
  // <ul>
  // 	<li data-mh="group-02" class="mh">My text</li>
  // 	<li data-mh="group-02" class="mh">My text</li>
  // </ul>
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32)))

/***/ }),
/* 32 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
  return this;
})();

try {
  // This works if eval is allowed (see CSP)
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var _Object$getOwnPropertyDescriptor = __webpack_require__(34);

var _Object$defineProperty = __webpack_require__(15);

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = _Object$defineProperty && _Object$getOwnPropertyDescriptor ? _Object$getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            _Object$defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj.default = obj;
    return newObj;
  }
}

module.exports = _interopRequireWildcard;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(35);

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(36);
var $Object = __webpack_require__(1).Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(13);
var $getOwnPropertyDescriptor = __webpack_require__(40).f;

__webpack_require__(23)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(38);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object("z").propertyIsEnumerable(0)
  ? Object
  : function(it) {
      return cof(it) == "String" ? it.split("") : Object(it);
    };


/***/ }),
/* 38 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 39 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(41);
var createDesc = __webpack_require__(12);
var toIObject = __webpack_require__(13);
var toPrimitive = __webpack_require__(11);
var has = __webpack_require__(22);
var IE8_DOM_DEFINE = __webpack_require__(10);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(0) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 41 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var _Object$defineProperties = __webpack_require__(43);

var _Object$freeze = __webpack_require__(55);

function _taggedTemplateLiteral(strings, raw) {
  return _Object$freeze(_Object$defineProperties(strings, {
    raw: {
      value: _Object$freeze(raw)
    }
  }));
}

module.exports = _taggedTemplateLiteral;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(44);

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(45);
var $Object = __webpack_require__(1).Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(7);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(0), "Object", {
  defineProperties: __webpack_require__(46)
});


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(3);
var anObject = __webpack_require__(9);
var getKeys = __webpack_require__(47);

module.exports = __webpack_require__(0)
  ? Object.defineProperties
  : function defineProperties(O, Properties) {
      anObject(O);
      var keys = getKeys(Properties);
      var length = keys.length;
      var i = 0;
      var P;
      while (length > i) dP.f(O, (P = keys[i++]), Properties[P]);
      return O;
    };


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(48);
var enumBugKeys = __webpack_require__(54);

module.exports =
  Object.keys ||
  function keys(O) {
    return $keys(O, enumBugKeys);
  };


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(22);
var toIObject = __webpack_require__(13);
var arrayIndexOf = __webpack_require__(49)(false);
var IE_PROTO = __webpack_require__(52)("IE_PROTO");

module.exports = function(object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i)
    if (has(O, (key = names[i++]))) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  return result;
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(13);
var toLength = __webpack_require__(50);
var toAbsoluteIndex = __webpack_require__(51);
module.exports = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el)
      while (length > index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
        // Array#indexOf ignores holes, Array#includes - not
      }
    else
      for (; length > index; index++)
        if (IS_INCLUDES || index in O) {
          if (O[index] === el) return IS_INCLUDES || index || 0;
        }
    return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(24);
var min = Math.min;
module.exports = function(it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(24);
var max = Math.max;
var min = Math.min;
module.exports = function(index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(53)("keys");
var uid = __webpack_require__(25);
module.exports = function(key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(6);
var SHARED = "__core-js_shared__";
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function(key) {
  return store[key] || (store[key] = {});
};


/***/ }),
/* 54 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(
  ","
);


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(56);

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(57);
module.exports = __webpack_require__(1).Object.freeze;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(2);
var meta = __webpack_require__(58).onFreeze;

__webpack_require__(23)("freeze", function($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(25)("meta");
var isObject = __webpack_require__(2);
var has = __webpack_require__(22);
var setDesc = __webpack_require__(3).f;
var id = 0;
var isExtensible =
  Object.isExtensible ||
  function() {
    return true;
  };
var FREEZE = !__webpack_require__(4)(function() {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it) {
  setDesc(it, META, {
    value: {
      i: "O" + ++id, // object ID
      w: {} // weak collections IDs
    }
  });
};
var fastKey = function(it, create) {
  // return primitive with prefix
  if (!isObject(it))
    return typeof it == "symbol"
      ? it
      : (typeof it == "string" ? "S" : "P") + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return "F";
    // not necessary to add metadata
    if (!create) return "E";
    // add missing metadata
    setMeta(it);
    // return object ID
  }
  return it[META].i;
};
var getWeak = function(it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
    // return hash weak collections IDs
  }
  return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = (module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
});


/***/ }),
/* 59 */
/***/ (function(module, exports) {

;(function(window){
var hadGlobal = 'Modernizr' in window;
var oldGlobal = window.Modernizr;
/*! modernizr 3.5.0 (Custom Build) | MIT *
 * https://modernizr.com/download/?-flexbox-flexboxtweener-objectfit-setclasses !*/
!function(e,n,t){function r(e,n){return typeof e===n}function o(){var e,n,t,o,i,s,l;for(var a in C)if(C.hasOwnProperty(a)){if(e=[],n=C[a],n.name&&(e.push(n.name.toLowerCase()),n.options&&n.options.aliases&&n.options.aliases.length))for(t=0;t<n.options.aliases.length;t++)e.push(n.options.aliases[t].toLowerCase());for(o=r(n.fn,"function")?n.fn():n.fn,i=0;i<e.length;i++)s=e[i],l=s.split("."),1===l.length?Modernizr[l[0]]=o:(!Modernizr[l[0]]||Modernizr[l[0]]instanceof Boolean||(Modernizr[l[0]]=new Boolean(Modernizr[l[0]])),Modernizr[l[0]][l[1]]=o),S.push((o?"":"no-")+l.join("-"))}}function i(e){var n=w.className,t=Modernizr._config.classPrefix||"";if(_&&(n=n.baseVal),Modernizr._config.enableJSClass){var r=new RegExp("(^|\\s)"+t+"no-js(\\s|$)");n=n.replace(r,"$1"+t+"js$2")}Modernizr._config.enableClasses&&(n+=" "+t+e.join(" "+t),_?w.className.baseVal=n:w.className=n)}function s(e,n){return!!~(""+e).indexOf(n)}function l(){return"function"!=typeof n.createElement?n.createElement(arguments[0]):_?n.createElementNS.call(n,"http://www.w3.org/2000/svg",arguments[0]):n.createElement.apply(n,arguments)}function a(){var e=n.body;return e||(e=l(_?"svg":"body"),e.fake=!0),e}function f(e,t,r,o){var i,s,f,u,p="modernizr",d=l("div"),c=a();if(parseInt(r,10))for(;r--;)f=l("div"),f.id=o?o[r]:p+(r+1),d.appendChild(f);return i=l("style"),i.type="text/css",i.id="s"+p,(c.fake?c:d).appendChild(i),c.appendChild(d),i.styleSheet?i.styleSheet.cssText=e:i.appendChild(n.createTextNode(e)),d.id=p,c.fake&&(c.style.background="",c.style.overflow="hidden",u=w.style.overflow,w.style.overflow="hidden",w.appendChild(c)),s=t(d,e),c.fake?(c.parentNode.removeChild(c),w.style.overflow=u,w.offsetHeight):d.parentNode.removeChild(d),!!s}function u(e){return e.replace(/([A-Z])/g,function(e,n){return"-"+n.toLowerCase()}).replace(/^ms-/,"-ms-")}function p(n,t,r){var o;if("getComputedStyle"in e){o=getComputedStyle.call(e,n,t);var i=e.console;if(null!==o)r&&(o=o.getPropertyValue(r));else if(i){var s=i.error?"error":"log";i[s].call(i,"getComputedStyle returning null, its possible modernizr test results are inaccurate")}}else o=!t&&n.currentStyle&&n.currentStyle[r];return o}function d(n,r){var o=n.length;if("CSS"in e&&"supports"in e.CSS){for(;o--;)if(e.CSS.supports(u(n[o]),r))return!0;return!1}if("CSSSupportsRule"in e){for(var i=[];o--;)i.push("("+u(n[o])+":"+r+")");return i=i.join(" or "),f("@supports ("+i+") { #modernizr { position: absolute; } }",function(e){return"absolute"==p(e,null,"position")})}return t}function c(e){return e.replace(/([a-z])-([a-z])/g,function(e,n,t){return n+t.toUpperCase()}).replace(/^-/,"")}function m(e,n,o,i){function a(){u&&(delete j.style,delete j.modElem)}if(i=r(i,"undefined")?!1:i,!r(o,"undefined")){var f=d(e,o);if(!r(f,"undefined"))return f}for(var u,p,m,v,y,g=["modernizr","tspan","samp"];!j.style&&g.length;)u=!0,j.modElem=l(g.shift()),j.style=j.modElem.style;for(m=e.length,p=0;m>p;p++)if(v=e[p],y=j.style[v],s(v,"-")&&(v=c(v)),j.style[v]!==t){if(i||r(o,"undefined"))return a(),"pfx"==n?v:!0;try{j.style[v]=o}catch(h){}if(j.style[v]!=y)return a(),"pfx"==n?v:!0}return a(),!1}function v(e,n){return function(){return e.apply(n,arguments)}}function y(e,n,t){var o;for(var i in e)if(e[i]in n)return t===!1?e[i]:(o=n[e[i]],r(o,"function")?v(o,t||n):o);return!1}function g(e,n,t,o,i){var s=e.charAt(0).toUpperCase()+e.slice(1),l=(e+" "+E.join(s+" ")+s).split(" ");return r(n,"string")||r(n,"undefined")?m(l,n,o,i):(l=(e+" "+z.join(s+" ")+s).split(" "),y(l,n,t))}function h(e,n,r){return g(e,t,t,n,r)}var C=[],x={_version:"3.5.0",_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},_q:[],on:function(e,n){var t=this;setTimeout(function(){n(t[e])},0)},addTest:function(e,n,t){C.push({name:e,fn:n,options:t})},addAsyncTest:function(e){C.push({name:null,fn:e})}},Modernizr=function(){};Modernizr.prototype=x,Modernizr=new Modernizr;var S=[],w=n.documentElement,_="svg"===w.nodeName.toLowerCase(),b="Moz O ms Webkit",E=x._config.usePrefixes?b.split(" "):[];x._cssomPrefixes=E;var P={elem:l("modernizr")};Modernizr._q.push(function(){delete P.elem});var j={style:P.elem.style};Modernizr._q.unshift(function(){delete j.style});var z=x._config.usePrefixes?b.toLowerCase().split(" "):[];x._domPrefixes=z,x.testAllProps=g;var T=function(n){var r,o=prefixes.length,i=e.CSSRule;if("undefined"==typeof i)return t;if(!n)return!1;if(n=n.replace(/^@/,""),r=n.replace(/-/g,"_").toUpperCase()+"_RULE",r in i)return"@"+n;for(var s=0;o>s;s++){var l=prefixes[s],a=l.toUpperCase()+"_"+r;if(a in i)return"@-"+l.toLowerCase()+"-"+n}return!1};x.atRule=T;var N=x.prefixed=function(e,n,t){return 0===e.indexOf("@")?T(e):(-1!=e.indexOf("-")&&(e=c(e)),n?g(e,n,t):g(e,"pfx"))};Modernizr.addTest("objectfit",!!N("objectFit"),{aliases:["object-fit"]}),x.testAllProps=h,Modernizr.addTest("flexbox",h("flexBasis","1px",!0)),Modernizr.addTest("flexboxtweener",h("flexAlign","end",!0)),o(),i(S),delete x.addTest,delete x.addAsyncTest;for(var A=0;A<Modernizr._q.length;A++)Modernizr._q[A]();e.Modernizr=Modernizr}(window,document);
module.exports = window.Modernizr;
if (hadGlobal) { window.Modernizr = oldGlobal; }
else { delete window.Modernizr; }
})(window);

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function dedent(strings) {
  var raw = void 0;
  if (typeof strings === "string") {
    // dedent can be used as a plain function
    raw = [strings];
  } else {
    raw = strings.raw;
  }

  // first, perform interpolation
  var result = "";
  for (var i = 0; i < raw.length; i++) {
    result += raw[i]
      // join lines when there is a suppressed newline
      .replace(/\\\n[ \t]*/g, "")
      // handle escaped backticks
      .replace(/\\`/g, "`");

    if (i < (arguments.length <= 1 ? 0 : arguments.length - 1)) {
      result += arguments.length <= i + 1 ? undefined : arguments[i + 1];
    }
  }

  // now strip indentation
  var lines = result.split("\n");
  var mindent = null;
  lines.forEach(function(l) {
    var m = l.match(/^(\s+)\S+/);
    if (m) {
      var indent = m[1].length;
      if (!mindent) {
        // this is the first indented line
        mindent = indent;
      } else {
        mindent = Math.min(mindent, indent);
      }
    }
  });

  if (mindent !== null) {
    result = lines
      .map(function(l) {
        return l[0] === " " ? l.slice(mindent) : l;
      })
      .join("\n");
  }

  // dedent eats leading and trailing whitespace too
  result = result.trim();

  // handle escaped newlines at the end to ensure they don't get stripped too
  return result.replace(/\\n/g, "\n");
}

if (true) {
  module.exports = dedent;
}


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! picturefill - v3.0.2 - 2016-02-12
 * https://scottjehl.github.io/picturefill/
 * Copyright (c) 2016 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT
 */
/*! Gecko-Picture - v1.0
 * https://github.com/scottjehl/picturefill/tree/3.0/src/plugins/gecko-picture
 * Firefox's early picture implementation (prior to FF41) is static and does
 * not react to viewport changes. This tiny module fixes this.
 */
(function(window) {
  /*jshint eqnull:true */
  var ua = navigator.userAgent;

  if (
    window.HTMLPictureElement &&
    (/ecko/.test(ua) && ua.match(/rv\:(\d+)/) && RegExp.$1 < 45)
  ) {
    addEventListener(
      "resize",
      (function() {
        var timer;

        var dummySrc = document.createElement("source");

        var fixRespimg = function(img) {
          var source, sizes;
          var picture = img.parentNode;

          if (picture.nodeName.toUpperCase() === "PICTURE") {
            source = dummySrc.cloneNode();

            picture.insertBefore(source, picture.firstElementChild);
            setTimeout(function() {
              picture.removeChild(source);
            });
          } else if (!img._pfLastSize || img.offsetWidth > img._pfLastSize) {
            img._pfLastSize = img.offsetWidth;
            sizes = img.sizes;
            img.sizes += ",100vw";
            setTimeout(function() {
              img.sizes = sizes;
            });
          }
        };

        var findPictureImgs = function() {
          var i;
          var imgs = document.querySelectorAll(
            "picture > img, img[srcset][sizes]"
          );
          for (i = 0; i < imgs.length; i++) {
            fixRespimg(imgs[i]);
          }
        };
        var onResize = function() {
          clearTimeout(timer);
          timer = setTimeout(findPictureImgs, 99);
        };
        var mq = window.matchMedia && matchMedia("(orientation: landscape)");
        var init = function() {
          onResize();

          if (mq && mq.addListener) {
            mq.addListener(onResize);
          }
        };

        dummySrc.srcset =
          "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";

        if (/^[c|i]|d$/.test(document.readyState || "")) {
          init();
        } else {
          document.addEventListener("DOMContentLoaded", init);
        }

        return onResize;
      })()
    );
  }
})(window);

/*! Picturefill - v3.0.2
 * http://scottjehl.github.io/picturefill
 * Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt;
 *  License: MIT
 */

(function(window, document, undefined) {
  // Enable strict mode
  "use strict";

  // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)
  document.createElement("picture");

  var warn, eminpx, alwaysCheckWDescriptor, evalId;
  // local object for method references and testing exposure
  var pf = {};
  var isSupportTestReady = false;
  var noop = function() {};
  var image = document.createElement("img");
  var getImgAttr = image.getAttribute;
  var setImgAttr = image.setAttribute;
  var removeImgAttr = image.removeAttribute;
  var docElem = document.documentElement;
  var types = {};
  var cfg = {
    //resource selection:
    algorithm: ""
  };
  var srcAttr = "data-pfsrc";
  var srcsetAttr = srcAttr + "set";
  // ua sniffing is done for undetectable img loading features,
  // to do some non crucial perf optimizations
  var ua = navigator.userAgent;
  var supportAbort =
    /rident/.test(ua) ||
    (/ecko/.test(ua) && ua.match(/rv\:(\d+)/) && RegExp.$1 > 35);
  var curSrcProp = "currentSrc";
  var regWDesc = /\s+\+?\d+(e\d+)?w/;
  var regSize = /(\([^)]+\))?\s*(.+)/;
  var setOptions = window.picturefillCFG;
  /**
   * Shortcut property for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )
   */
  // baseStyle also used by getEmValue (i.e.: width: 1em is important)
  var baseStyle =
    "position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)";
  var fsCss = "font-size:100%!important;";
  var isVwDirty = true;

  var cssCache = {};
  var sizeLengthCache = {};
  var DPR = window.devicePixelRatio;
  var units = {
    px: 1,
    in: 96
  };
  var anchor = document.createElement("a");
  /**
   * alreadyRun flag used for setOptions. is it true setOptions will reevaluate
   * @type {boolean}
   */
  var alreadyRun = false;

  // Reusable, non-"g" Regexes

  // (Don't use \s, to avoid matching non-breaking space.)
  var regexLeadingSpaces = /^[ \t\n\r\u000c]+/,
    regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/,
    regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/,
    regexTrailingCommas = /[,]+$/,
    regexNonNegativeInteger = /^\d+$/,
    // ( Positive or negative or unsigned integers or decimals, without or without exponents.
    // Must include at least one digit.
    // According to spec tests any decimal point must be followed by a digit.
    // No leading plus sign is allowed.)
    // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number
    regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;

  var on = function(obj, evt, fn, capture) {
    if (obj.addEventListener) {
      obj.addEventListener(evt, fn, capture || false);
    } else if (obj.attachEvent) {
      obj.attachEvent("on" + evt, fn);
    }
  };

  /**
   * simple memoize function:
   */

  var memoize = function(fn) {
    var cache = {};
    return function(input) {
      if (!(input in cache)) {
        cache[input] = fn(input);
      }
      return cache[input];
    };
  };

  // UTILITY FUNCTIONS

  // Manual is faster than RegEx
  // http://jsperf.com/whitespace-character/5
  function isSpace(c) {
    return (
      c === "\u0020" || // space
      c === "\u0009" || // horizontal tab
      c === "\u000A" || // new line
      c === "\u000C" || // form feed
      c === "\u000D"
    ); // carriage return
  }

  /**
   * gets a mediaquery and returns a boolean or gets a css length and returns a number
   * @param css mediaqueries or css length
   * @returns {boolean|number}
   *
   * based on: https://gist.github.com/jonathantneal/db4f77009b155f083738
   */
  var evalCSS = (function() {
    var regLength = /^([\d\.]+)(em|vw|px)$/;
    var replace = function() {
      var args = arguments,
        index = 0,
        string = args[0];
      while (++index in args) {
        string = string.replace(args[index], args[++index]);
      }
      return string;
    };

    var buildStr = memoize(function(css) {
      return (
        "return " +
        replace(
          (css || "").toLowerCase(),
          // interpret `and`
          /\band\b/g,
          "&&",

          // interpret `,`
          /,/g,
          "||",

          // interpret `min-` as >=
          /min-([a-z-\s]+):/g,
          "e.$1>=",

          // interpret `max-` as <=
          /max-([a-z-\s]+):/g,
          "e.$1<=",

          //calc value
          /calc([^)]+)/g,
          "($1)",

          // interpret css values
          /(\d+[\.]*[\d]*)([a-z]+)/g,
          "($1 * e.$2)",
          //make eval less evil
          /^(?!(e.[a-z]|[0-9\.&=|><\+\-\*\(\)\/])).*/gi,
          ""
        ) +
        ";"
      );
    });

    return function(css, length) {
      var parsedLength;
      if (!(css in cssCache)) {
        cssCache[css] = false;
        if (length && (parsedLength = css.match(regLength))) {
          cssCache[css] = parsedLength[1] * units[parsedLength[2]];
        } else {
          /*jshint evil:true */
          try {
            cssCache[css] = new Function("e", buildStr(css))(units);
          } catch (e) {}
          /*jshint evil:false */
        }
      }
      return cssCache[css];
    };
  })();

  var setResolution = function(candidate, sizesattr) {
    if (candidate.w) {
      // h = means height: || descriptor.type === 'h' do not handle yet...
      candidate.cWidth = pf.calcListLength(sizesattr || "100vw");
      candidate.res = candidate.w / candidate.cWidth;
    } else {
      candidate.res = candidate.d;
    }
    return candidate;
  };

  /**
   *
   * @param opt
   */
  var picturefill = function(opt) {
    if (!isSupportTestReady) {
      return;
    }

    var elements, i, plen;

    var options = opt || {};

    if (options.elements && options.elements.nodeType === 1) {
      if (options.elements.nodeName.toUpperCase() === "IMG") {
        options.elements = [options.elements];
      } else {
        options.context = options.elements;
        options.elements = null;
      }
    }

    elements =
      options.elements ||
      pf.qsa(
        options.context || document,
        options.reevaluate || options.reselect ? pf.sel : pf.selShort
      );

    if ((plen = elements.length)) {
      pf.setupRun(options);
      alreadyRun = true;

      // Loop through all elements
      for (i = 0; i < plen; i++) {
        pf.fillImg(elements[i], options);
      }

      pf.teardownRun(options);
    }
  };

  /**
   * outputs a warning for the developer
   * @param {message}
   * @type {Function}
   */
  warn =
    window.console && console.warn
      ? function(message) {
          console.warn(message);
        }
      : noop;

  if (!(curSrcProp in image)) {
    curSrcProp = "src";
  }

  // Add support for standard mime types.
  types["image/jpeg"] = true;
  types["image/gif"] = true;
  types["image/png"] = true;

  function detectTypeSupport(type, typeUri) {
    // based on Modernizr's lossless img-webp test
    // note: asynchronous
    var image = new window.Image();
    image.onerror = function() {
      types[type] = false;
      picturefill();
    };
    image.onload = function() {
      types[type] = image.width === 1;
      picturefill();
    };
    image.src = typeUri;
    return "pending";
  }

  // test svg support
  types["image/svg+xml"] = document.implementation.hasFeature(
    "http://www.w3.org/TR/SVG11/feature#Image",
    "1.1"
  );

  /**
   * updates the internal vW property with the current viewport width in px
   */
  function updateMetrics() {
    isVwDirty = false;
    DPR = window.devicePixelRatio;
    cssCache = {};
    sizeLengthCache = {};

    pf.DPR = DPR || 1;

    units.width = Math.max(window.innerWidth || 0, docElem.clientWidth);
    units.height = Math.max(window.innerHeight || 0, docElem.clientHeight);

    units.vw = units.width / 100;
    units.vh = units.height / 100;

    evalId = [units.height, units.width, DPR].join("-");

    units.em = pf.getEmValue();
    units.rem = units.em;
  }

  function chooseLowRes(lowerValue, higherValue, dprValue, isCached) {
    var bonusFactor, tooMuch, bonus, meanDensity;

    //experimental
    if (cfg.algorithm === "saveData") {
      if (lowerValue > 2.7) {
        meanDensity = dprValue + 1;
      } else {
        tooMuch = higherValue - dprValue;
        bonusFactor = Math.pow(lowerValue - 0.6, 1.5);

        bonus = tooMuch * bonusFactor;

        if (isCached) {
          bonus += 0.1 * bonusFactor;
        }

        meanDensity = lowerValue + bonus;
      }
    } else {
      meanDensity =
        dprValue > 1 ? Math.sqrt(lowerValue * higherValue) : lowerValue;
    }

    return meanDensity > dprValue;
  }

  function applyBestCandidate(img) {
    var srcSetCandidates;
    var matchingSet = pf.getSet(img);
    var evaluated = false;
    if (matchingSet !== "pending") {
      evaluated = evalId;
      if (matchingSet) {
        srcSetCandidates = pf.setRes(matchingSet);
        pf.applySetCandidate(srcSetCandidates, img);
      }
    }
    img[pf.ns].evaled = evaluated;
  }

  function ascendingSort(a, b) {
    return a.res - b.res;
  }

  function setSrcToCur(img, src, set) {
    var candidate;
    if (!set && src) {
      set = img[pf.ns].sets;
      set = set && set[set.length - 1];
    }

    candidate = getCandidateForSrc(src, set);

    if (candidate) {
      src = pf.makeUrl(src);
      img[pf.ns].curSrc = src;
      img[pf.ns].curCan = candidate;

      if (!candidate.res) {
        setResolution(candidate, candidate.set.sizes);
      }
    }
    return candidate;
  }

  function getCandidateForSrc(src, set) {
    var i, candidate, candidates;
    if (src && set) {
      candidates = pf.parseSet(set);
      src = pf.makeUrl(src);
      for (i = 0; i < candidates.length; i++) {
        if (src === pf.makeUrl(candidates[i].url)) {
          candidate = candidates[i];
          break;
        }
      }
    }
    return candidate;
  }

  function getAllSourceElements(picture, candidates) {
    var i, len, source, srcset;

    // SPEC mismatch intended for size and perf:
    // actually only source elements preceding the img should be used
    // also note: don't use qsa here, because IE8 sometimes doesn't like source as the key part in a selector
    var sources = picture.getElementsByTagName("source");

    for (i = 0, len = sources.length; i < len; i++) {
      source = sources[i];
      source[pf.ns] = true;
      srcset = source.getAttribute("srcset");

      // if source does not have a srcset attribute, skip
      if (srcset) {
        candidates.push({
          srcset: srcset,
          media: source.getAttribute("media"),
          type: source.getAttribute("type"),
          sizes: source.getAttribute("sizes")
        });
      }
    }
  }

  /**
   * Srcset Parser
   * By Alex Bell |  MIT License
   *
   * @returns Array [{url: _, d: _, w: _, h:_, set:_(????)}, ...]
   *
   * Based super duper closely on the reference algorithm at:
   * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute
   */

  // 1. Let input be the value passed to this algorithm.
  // (TO-DO : Explain what "set" argument is here. Maybe choose a more
  // descriptive & more searchable name.  Since passing the "set" in really has
  // nothing to do with parsing proper, I would prefer this assignment eventually
  // go in an external fn.)
  function parseSrcset(input, set) {
    function collectCharacters(regEx) {
      var chars,
        match = regEx.exec(input.substring(pos));
      if (match) {
        chars = match[0];
        pos += chars.length;
        return chars;
      }
    }

    var inputLength = input.length,
      url,
      descriptors,
      currentDescriptor,
      state,
      c,
      // 2. Let position be a pointer into input, initially pointing at the start
      //    of the string.
      pos = 0,
      // 3. Let candidates be an initially empty source set.
      candidates = [];

    /**
     * Adds descriptor properties to a candidate, pushes to the candidates array
     * @return undefined
     */
    // (Declared outside of the while loop so that it's only created once.
    // (This fn is defined before it is used, in order to pass JSHINT.
    // Unfortunately this breaks the sequencing of the spec comments. :/ )
    function parseDescriptors() {
      // 9. Descriptor parser: Let error be no.
      var pError = false,
        // 10. Let width be absent.
        // 11. Let density be absent.
        // 12. Let future-compat-h be absent. (We're implementing it now as h)
        w,
        d,
        h,
        i,
        candidate = {},
        desc,
        lastChar,
        value,
        intVal,
        floatVal;

      // 13. For each descriptor in descriptors, run the appropriate set of steps
      // from the following list:
      for (i = 0; i < descriptors.length; i++) {
        desc = descriptors[i];

        lastChar = desc[desc.length - 1];
        value = desc.substring(0, desc.length - 1);
        intVal = parseInt(value, 10);
        floatVal = parseFloat(value);

        // If the descriptor consists of a valid non-negative integer followed by
        // a U+0077 LATIN SMALL LETTER W character
        if (regexNonNegativeInteger.test(value) && lastChar === "w") {
          // If width and density are not both absent, then let error be yes.
          if (w || d) {
            pError = true;
          }

          // Apply the rules for parsing non-negative integers to the descriptor.
          // If the result is zero, let error be yes.
          // Otherwise, let width be the result.
          if (intVal === 0) {
            pError = true;
          } else {
            w = intVal;
          }

          // If the descriptor consists of a valid floating-point number followed by
          // a U+0078 LATIN SMALL LETTER X character
        } else if (regexFloatingPoint.test(value) && lastChar === "x") {
          // If width, density and future-compat-h are not all absent, then let error
          // be yes.
          if (w || d || h) {
            pError = true;
          }

          // Apply the rules for parsing floating-point number values to the descriptor.
          // If the result is less than zero, let error be yes. Otherwise, let density
          // be the result.
          if (floatVal < 0) {
            pError = true;
          } else {
            d = floatVal;
          }

          // If the descriptor consists of a valid non-negative integer followed by
          // a U+0068 LATIN SMALL LETTER H character
        } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
          // If height and density are not both absent, then let error be yes.
          if (h || d) {
            pError = true;
          }

          // Apply the rules for parsing non-negative integers to the descriptor.
          // If the result is zero, let error be yes. Otherwise, let future-compat-h
          // be the result.
          if (intVal === 0) {
            pError = true;
          } else {
            h = intVal;
          }

          // Anything else, Let error be yes.
        } else {
          pError = true;
        }
      } // (close step 13 for loop)

      // 15. If error is still no, then append a new image source to candidates whose
      // URL is url, associated with a width width if not absent and a pixel
      // density density if not absent. Otherwise, there is a parse error.
      if (!pError) {
        candidate.url = url;

        if (w) {
          candidate.w = w;
        }
        if (d) {
          candidate.d = d;
        }
        if (h) {
          candidate.h = h;
        }
        if (!h && !d && !w) {
          candidate.d = 1;
        }
        if (candidate.d === 1) {
          set.has1x = true;
        }
        candidate.set = set;

        candidates.push(candidate);
      }
    } // (close parseDescriptors fn)

    /**
     * Tokenizes descriptor properties prior to parsing
     * Returns undefined.
     * (Again, this fn is defined before it is used, in order to pass JSHINT.
     * Unfortunately this breaks the logical sequencing of the spec comments. :/ )
     */
    function tokenize() {
      // 8.1. Descriptor tokeniser: Skip whitespace
      collectCharacters(regexLeadingSpaces);

      // 8.2. Let current descriptor be the empty string.
      currentDescriptor = "";

      // 8.3. Let state be in descriptor.
      state = "in descriptor";

      while (true) {
        // 8.4. Let c be the character at position.
        c = input.charAt(pos);

        //  Do the following depending on the value of state.
        //  For the purpose of this step, "EOF" is a special character representing
        //  that position is past the end of input.

        // In descriptor
        if (state === "in descriptor") {
          // Do the following, depending on the value of c:

          // Space character
          // If current descriptor is not empty, append current descriptor to
          // descriptors and let current descriptor be the empty string.
          // Set state to after descriptor.
          if (isSpace(c)) {
            if (currentDescriptor) {
              descriptors.push(currentDescriptor);
              currentDescriptor = "";
              state = "after descriptor";
            }

            // U+002C COMMA (,)
            // Advance position to the next character in input. If current descriptor
            // is not empty, append current descriptor to descriptors. Jump to the step
            // labeled descriptor parser.
          } else if (c === ",") {
            pos += 1;
            if (currentDescriptor) {
              descriptors.push(currentDescriptor);
            }
            parseDescriptors();
            return;

            // U+0028 LEFT PARENTHESIS (()
            // Append c to current descriptor. Set state to in parens.
          } else if (c === "\u0028") {
            currentDescriptor = currentDescriptor + c;
            state = "in parens";

            // EOF
            // If current descriptor is not empty, append current descriptor to
            // descriptors. Jump to the step labeled descriptor parser.
          } else if (c === "") {
            if (currentDescriptor) {
              descriptors.push(currentDescriptor);
            }
            parseDescriptors();
            return;

            // Anything else
            // Append c to current descriptor.
          } else {
            currentDescriptor = currentDescriptor + c;
          }
          // (end "in descriptor"

          // In parens
        } else if (state === "in parens") {
          // U+0029 RIGHT PARENTHESIS ())
          // Append c to current descriptor. Set state to in descriptor.
          if (c === ")") {
            currentDescriptor = currentDescriptor + c;
            state = "in descriptor";

            // EOF
            // Append current descriptor to descriptors. Jump to the step labeled
            // descriptor parser.
          } else if (c === "") {
            descriptors.push(currentDescriptor);
            parseDescriptors();
            return;

            // Anything else
            // Append c to current descriptor.
          } else {
            currentDescriptor = currentDescriptor + c;
          }

          // After descriptor
        } else if (state === "after descriptor") {
          // Do the following, depending on the value of c:
          // Space character: Stay in this state.
          if (isSpace(c)) {
            // EOF: Jump to the step labeled descriptor parser.
          } else if (c === "") {
            parseDescriptors();
            return;

            // Anything else
            // Set state to in descriptor. Set position to the previous character in input.
          } else {
            state = "in descriptor";
            pos -= 1;
          }
        }

        // Advance position to the next character in input.
        pos += 1;

        // Repeat this step.
      } // (close while true loop)
    }

    // 4. Splitting loop: Collect a sequence of characters that are space
    //    characters or U+002C COMMA characters. If any U+002C COMMA characters
    //    were collected, that is a parse error.
    while (true) {
      collectCharacters(regexLeadingCommasOrSpaces);

      // 5. If position is past the end of input, return candidates and abort these steps.
      if (pos >= inputLength) {
        return candidates; // (we're done, this is the sole return path)
      }

      // 6. Collect a sequence of characters that are not space characters,
      //    and let that be url.
      url = collectCharacters(regexLeadingNotSpaces);

      // 7. Let descriptors be a new empty list.
      descriptors = [];

      // 8. If url ends with a U+002C COMMA character (,), follow these substeps:
      //		(1). Remove all trailing U+002C COMMA characters from url. If this removed
      //         more than one character, that is a parse error.
      if (url.slice(-1) === ",") {
        url = url.replace(regexTrailingCommas, "");
        // (Jump ahead to step 9 to skip tokenization and just push the candidate).
        parseDescriptors();

        //	Otherwise, follow these substeps:
      } else {
        tokenize();
      } // (close else of step 8)

      // 16. Return to the step labeled splitting loop.
    } // (Close of big while loop.)
  }

  /*
	 * Sizes Parser
	 *
	 * By Alex Bell |  MIT License
	 *
	 * Non-strict but accurate and lightweight JS Parser for the string value <img sizes="here">
	 *
	 * Reference algorithm at:
	 * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-sizes-attribute
	 *
	 * Most comments are copied in directly from the spec
	 * (except for comments in parens).
	 *
	 * Grammar is:
	 * <source-size-list> = <source-size># [ , <source-size-value> ]? | <source-size-value>
	 * <source-size> = <media-condition> <source-size-value>
	 * <source-size-value> = <length>
	 * http://www.w3.org/html/wg/drafts/html/master/embedded-content.html#attr-img-sizes
	 *
	 * E.g. "(max-width: 30em) 100vw, (max-width: 50em) 70vw, 100vw"
	 * or "(min-width: 30em), calc(30vw - 15px)" or just "30vw"
	 *
	 * Returns the first valid <css-length> with a media condition that evaluates to true,
	 * or "100vw" if all valid media conditions evaluate to false.
	 *
	 */

  function parseSizes(strValue) {
    // (Percentage CSS lengths are not allowed in this case, to avoid confusion:
    // https://html.spec.whatwg.org/multipage/embedded-content.html#valid-source-size-list
    // CSS allows a single optional plus or minus sign:
    // http://www.w3.org/TR/CSS2/syndata.html#numbers
    // CSS is ASCII case-insensitive:
    // http://www.w3.org/TR/CSS2/syndata.html#characters )
    // Spec allows exponential notation for <number> type:
    // http://dev.w3.org/csswg/css-values/#numbers
    var regexCssLengthWithUnits = /^(?:[+-]?[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i;

    // (This is a quick and lenient test. Because of optional unlimited-depth internal
    // grouping parens and strict spacing rules, this could get very complicated.)
    var regexCssCalc = /^calc\((?:[0-9a-z \.\+\-\*\/\(\)]+)\)$/i;

    var i;
    var unparsedSizesList;
    var unparsedSizesListLength;
    var unparsedSize;
    var lastComponentValue;
    var size;

    // UTILITY FUNCTIONS

    //  (Toy CSS parser. The goals here are:
    //  1) expansive test coverage without the weight of a full CSS parser.
    //  2) Avoiding regex wherever convenient.
    //  Quick tests: http://jsfiddle.net/gtntL4gr/3/
    //  Returns an array of arrays.)
    function parseComponentValues(str) {
      var chrctr;
      var component = "";
      var componentArray = [];
      var listArray = [];
      var parenDepth = 0;
      var pos = 0;
      var inComment = false;

      function pushComponent() {
        if (component) {
          componentArray.push(component);
          component = "";
        }
      }

      function pushComponentArray() {
        if (componentArray[0]) {
          listArray.push(componentArray);
          componentArray = [];
        }
      }

      // (Loop forwards from the beginning of the string.)
      while (true) {
        chrctr = str.charAt(pos);

        if (chrctr === "") {
          // ( End of string reached.)
          pushComponent();
          pushComponentArray();
          return listArray;
        } else if (inComment) {
          if (chrctr === "*" && str[pos + 1] === "/") {
            // (At end of a comment.)
            inComment = false;
            pos += 2;
            pushComponent();
            continue;
          } else {
            pos += 1; // (Skip all characters inside comments.)
            continue;
          }
        } else if (isSpace(chrctr)) {
          // (If previous character in loop was also a space, or if
          // at the beginning of the string, do not add space char to
          // component.)
          if (
            (str.charAt(pos - 1) && isSpace(str.charAt(pos - 1))) ||
            !component
          ) {
            pos += 1;
            continue;
          } else if (parenDepth === 0) {
            pushComponent();
            pos += 1;
            continue;
          } else {
            // (Replace any space character with a plain space for legibility.)
            chrctr = " ";
          }
        } else if (chrctr === "(") {
          parenDepth += 1;
        } else if (chrctr === ")") {
          parenDepth -= 1;
        } else if (chrctr === ",") {
          pushComponent();
          pushComponentArray();
          pos += 1;
          continue;
        } else if (chrctr === "/" && str.charAt(pos + 1) === "*") {
          inComment = true;
          pos += 2;
          continue;
        }

        component = component + chrctr;
        pos += 1;
      }
    }

    function isValidNonNegativeSourceSizeValue(s) {
      if (regexCssLengthWithUnits.test(s) && parseFloat(s) >= 0) {
        return true;
      }
      if (regexCssCalc.test(s)) {
        return true;
      }
      // ( http://www.w3.org/TR/CSS2/syndata.html#numbers says:
      // "-0 is equivalent to 0 and is not a negative number." which means that
      // unitless zero and unitless negative zero must be accepted as special cases.)
      if (s === "0" || s === "-0" || s === "+0") {
        return true;
      }
      return false;
    }

    // When asked to parse a sizes attribute from an element, parse a
    // comma-separated list of component values from the value of the element's
    // sizes attribute (or the empty string, if the attribute is absent), and let
    // unparsed sizes list be the result.
    // http://dev.w3.org/csswg/css-syntax/#parse-comma-separated-list-of-component-values

    unparsedSizesList = parseComponentValues(strValue);
    unparsedSizesListLength = unparsedSizesList.length;

    // For each unparsed size in unparsed sizes list:
    for (i = 0; i < unparsedSizesListLength; i++) {
      unparsedSize = unparsedSizesList[i];

      // 1. Remove all consecutive <whitespace-token>s from the end of unparsed size.
      // ( parseComponentValues() already omits spaces outside of parens. )

      // If unparsed size is now empty, that is a parse error; continue to the next
      // iteration of this algorithm.
      // ( parseComponentValues() won't push an empty array. )

      // 2. If the last component value in unparsed size is a valid non-negative
      // <source-size-value>, let size be its value and remove the component value
      // from unparsed size. Any CSS function other than the calc() function is
      // invalid. Otherwise, there is a parse error; continue to the next iteration
      // of this algorithm.
      // http://dev.w3.org/csswg/css-syntax/#parse-component-value
      lastComponentValue = unparsedSize[unparsedSize.length - 1];

      if (isValidNonNegativeSourceSizeValue(lastComponentValue)) {
        size = lastComponentValue;
        unparsedSize.pop();
      } else {
        continue;
      }

      // 3. Remove all consecutive <whitespace-token>s from the end of unparsed
      // size. If unparsed size is now empty, return size and exit this algorithm.
      // If this was not the last item in unparsed sizes list, that is a parse error.
      if (unparsedSize.length === 0) {
        return size;
      }

      // 4. Parse the remaining component values in unparsed size as a
      // <media-condition>. If it does not parse correctly, or it does parse
      // correctly but the <media-condition> evaluates to false, continue to the
      // next iteration of this algorithm.
      // (Parsing all possible compound media conditions in JS is heavy, complicated,
      // and the payoff is unclear. Is there ever an situation where the
      // media condition parses incorrectly but still somehow evaluates to true?
      // Can we just rely on the browser/polyfill to do it?)
      unparsedSize = unparsedSize.join(" ");
      if (!pf.matchesMedia(unparsedSize)) {
        continue;
      }

      // 5. Return size and exit this algorithm.
      return size;
    }

    // If the above algorithm exhausts unparsed sizes list without returning a
    // size value, return 100vw.
    return "100vw";
  }

  // namespace
  pf.ns = ("pf" + new Date().getTime()).substr(0, 9);

  // srcset support test
  pf.supSrcset = "srcset" in image;
  pf.supSizes = "sizes" in image;
  pf.supPicture = !!window.HTMLPictureElement;

  // UC browser does claim to support srcset and picture, but not sizes,
  // this extended test reveals the browser does support nothing
  if (pf.supSrcset && pf.supPicture && !pf.supSizes) {
    (function(image2) {
      image.srcset = "data:,a";
      image2.src = "data:,a";
      pf.supSrcset = image.complete === image2.complete;
      pf.supPicture = pf.supSrcset && pf.supPicture;
    })(document.createElement("img"));
  }

  // Safari9 has basic support for sizes, but does't expose the `sizes` idl attribute
  if (pf.supSrcset && !pf.supSizes) {
    (function() {
      var width2 =
        "data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw==";
      var width1 =
        "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      var img = document.createElement("img");
      var test = function() {
        var width = img.width;

        if (width === 2) {
          pf.supSizes = true;
        }

        alwaysCheckWDescriptor = pf.supSrcset && !pf.supSizes;

        isSupportTestReady = true;
        // force async
        setTimeout(picturefill);
      };

      img.onload = test;
      img.onerror = test;
      img.setAttribute("sizes", "9px");

      img.srcset = width1 + " 1w," + width2 + " 9w";
      img.src = width1;
    })();
  } else {
    isSupportTestReady = true;
  }

  // using pf.qsa instead of dom traversing does scale much better,
  // especially on sites mixing responsive and non-responsive images
  pf.selShort = "picture>img,img[srcset]";
  pf.sel = pf.selShort;
  pf.cfg = cfg;

  /**
   * Shortcut property for `devicePixelRatio` ( for easy overriding in tests )
   */
  pf.DPR = DPR || 1;
  pf.u = units;

  // container of supported mime types that one might need to qualify before using
  pf.types = types;

  pf.setSize = noop;

  /**
   * Gets a string and returns the absolute URL
   * @param src
   * @returns {String} absolute URL
   */

  pf.makeUrl = memoize(function(src) {
    anchor.href = src;
    return anchor.href;
  });

  /**
   * Gets a DOM element or document and a selctor and returns the found matches
   * Can be extended with jQuery/Sizzle for IE7 support
   * @param context
   * @param sel
   * @returns {NodeList|Array}
   */
  pf.qsa = function(context, sel) {
    return "querySelector" in context ? context.querySelectorAll(sel) : [];
  };

  /**
   * Shortcut method for matchMedia ( for easy overriding in tests )
   * wether native or pf.mMQ is used will be decided lazy on first call
   * @returns {boolean}
   */
  pf.matchesMedia = function() {
    if (window.matchMedia && (matchMedia("(min-width: 0.1em)") || {}).matches) {
      pf.matchesMedia = function(media) {
        return !media || matchMedia(media).matches;
      };
    } else {
      pf.matchesMedia = pf.mMQ;
    }

    return pf.matchesMedia.apply(this, arguments);
  };

  /**
   * A simplified matchMedia implementation for IE8 and IE9
   * handles only min-width/max-width with px or em values
   * @param media
   * @returns {boolean}
   */
  pf.mMQ = function(media) {
    return media ? evalCSS(media) : true;
  };

  /**
   * Returns the calculated length in css pixel from the given sourceSizeValue
   * http://dev.w3.org/csswg/css-values-3/#length-value
   * intended Spec mismatches:
   * * Does not check for invalid use of CSS functions
   * * Does handle a computed length of 0 the same as a negative and therefore invalid value
   * @param sourceSizeValue
   * @returns {Number}
   */
  pf.calcLength = function(sourceSizeValue) {
    var value = evalCSS(sourceSizeValue, true) || false;
    if (value < 0) {
      value = false;
    }

    return value;
  };

  /**
   * Takes a type string and checks if its supported
   */

  pf.supportsType = function(type) {
    return type ? types[type] : true;
  };

  /**
   * Parses a sourceSize into mediaCondition (media) and sourceSizeValue (length)
   * @param sourceSizeStr
   * @returns {*}
   */
  pf.parseSize = memoize(function(sourceSizeStr) {
    var match = (sourceSizeStr || "").match(regSize);
    return {
      media: match && match[1],
      length: match && match[2]
    };
  });

  pf.parseSet = function(set) {
    if (!set.cands) {
      set.cands = parseSrcset(set.srcset, set);
    }
    return set.cands;
  };

  /**
   * returns 1em in css px for html/body default size
   * function taken from respondjs
   * @returns {*|number}
   */
  pf.getEmValue = function() {
    var body;
    if (!eminpx && (body = document.body)) {
      var div = document.createElement("div"),
        originalHTMLCSS = docElem.style.cssText,
        originalBodyCSS = body.style.cssText;

      div.style.cssText = baseStyle;

      // 1em in a media query is the value of the default font size of the browser
      // reset docElem and body to ensure the correct value is returned
      docElem.style.cssText = fsCss;
      body.style.cssText = fsCss;

      body.appendChild(div);
      eminpx = div.offsetWidth;
      body.removeChild(div);

      //also update eminpx before returning
      eminpx = parseFloat(eminpx, 10);

      // restore the original values
      docElem.style.cssText = originalHTMLCSS;
      body.style.cssText = originalBodyCSS;
    }
    return eminpx || 16;
  };

  /**
   * Takes a string of sizes and returns the width in pixels as a number
   */
  pf.calcListLength = function(sourceSizeListStr) {
    // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%
    //
    //                           or (min-width:30em) calc(30% - 15px)
    if (!(sourceSizeListStr in sizeLengthCache) || cfg.uT) {
      var winningLength = pf.calcLength(parseSizes(sourceSizeListStr));

      sizeLengthCache[sourceSizeListStr] = !winningLength
        ? units.width
        : winningLength;
    }

    return sizeLengthCache[sourceSizeListStr];
  };

  /**
   * Takes a candidate object with a srcset property in the form of url/
   * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or
   *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or
   *     "images/pic-small.png"
   * Get an array of image candidates in the form of
   *      {url: "/foo/bar.png", resolution: 1}
   * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
   * If sizes is specified, res is calculated
   */
  pf.setRes = function(set) {
    var candidates;
    if (set) {
      candidates = pf.parseSet(set);

      for (var i = 0, len = candidates.length; i < len; i++) {
        setResolution(candidates[i], set.sizes);
      }
    }
    return candidates;
  };

  pf.setRes.res = setResolution;

  pf.applySetCandidate = function(candidates, img) {
    if (!candidates.length) {
      return;
    }
    var candidate,
      i,
      j,
      length,
      bestCandidate,
      curSrc,
      curCan,
      candidateSrc,
      abortCurSrc;

    var imageData = img[pf.ns];
    var dpr = pf.DPR;

    curSrc = imageData.curSrc || img[curSrcProp];

    curCan = imageData.curCan || setSrcToCur(img, curSrc, candidates[0].set);

    // if we have a current source, we might either become lazy or give this source some advantage
    if (curCan && curCan.set === candidates[0].set) {
      // if browser can abort image request and the image has a higher pixel density than needed
      // and this image isn't downloaded yet, we skip next part and try to save bandwidth
      abortCurSrc = supportAbort && !img.complete && curCan.res - 0.1 > dpr;

      if (!abortCurSrc) {
        curCan.cached = true;

        // if current candidate is "best", "better" or "okay",
        // set it to bestCandidate
        if (curCan.res >= dpr) {
          bestCandidate = curCan;
        }
      }
    }

    if (!bestCandidate) {
      candidates.sort(ascendingSort);

      length = candidates.length;
      bestCandidate = candidates[length - 1];

      for (i = 0; i < length; i++) {
        candidate = candidates[i];
        if (candidate.res >= dpr) {
          j = i - 1;

          // we have found the perfect candidate,
          // but let's improve this a little bit with some assumptions ;-)
          if (
            candidates[j] &&
            (abortCurSrc || curSrc !== pf.makeUrl(candidate.url)) &&
            chooseLowRes(
              candidates[j].res,
              candidate.res,
              dpr,
              candidates[j].cached
            )
          ) {
            bestCandidate = candidates[j];
          } else {
            bestCandidate = candidate;
          }
          break;
        }
      }
    }

    if (bestCandidate) {
      candidateSrc = pf.makeUrl(bestCandidate.url);

      imageData.curSrc = candidateSrc;
      imageData.curCan = bestCandidate;

      if (candidateSrc !== curSrc) {
        pf.setSrc(img, bestCandidate);
      }
      pf.setSize(img);
    }
  };

  pf.setSrc = function(img, bestCandidate) {
    var origWidth;
    img.src = bestCandidate.url;

    // although this is a specific Safari issue, we don't want to take too much different code paths
    if (bestCandidate.set.type === "image/svg+xml") {
      origWidth = img.style.width;
      img.style.width = img.offsetWidth + 1 + "px";

      // next line only should trigger a repaint
      // if... is only done to trick dead code removal
      if (img.offsetWidth + 1) {
        img.style.width = origWidth;
      }
    }
  };

  pf.getSet = function(img) {
    var i, set, supportsType;
    var match = false;
    var sets = img[pf.ns].sets;

    for (i = 0; i < sets.length && !match; i++) {
      set = sets[i];

      if (
        !set.srcset ||
        !pf.matchesMedia(set.media) ||
        !(supportsType = pf.supportsType(set.type))
      ) {
        continue;
      }

      if (supportsType === "pending") {
        set = supportsType;
      }

      match = set;
      break;
    }

    return match;
  };

  pf.parseSets = function(element, parent, options) {
    var srcsetAttribute, imageSet, isWDescripor, srcsetParsed;

    var hasPicture = parent && parent.nodeName.toUpperCase() === "PICTURE";
    var imageData = element[pf.ns];

    if (imageData.src === undefined || options.src) {
      imageData.src = getImgAttr.call(element, "src");
      if (imageData.src) {
        setImgAttr.call(element, srcAttr, imageData.src);
      } else {
        removeImgAttr.call(element, srcAttr);
      }
    }

    if (
      imageData.srcset === undefined ||
      options.srcset ||
      !pf.supSrcset ||
      element.srcset
    ) {
      srcsetAttribute = getImgAttr.call(element, "srcset");
      imageData.srcset = srcsetAttribute;
      srcsetParsed = true;
    }

    imageData.sets = [];

    if (hasPicture) {
      imageData.pic = true;
      getAllSourceElements(parent, imageData.sets);
    }

    if (imageData.srcset) {
      imageSet = {
        srcset: imageData.srcset,
        sizes: getImgAttr.call(element, "sizes")
      };

      imageData.sets.push(imageSet);

      isWDescripor =
        (alwaysCheckWDescriptor || imageData.src) &&
        regWDesc.test(imageData.srcset || "");

      // add normal src as candidate, if source has no w descriptor
      if (
        !isWDescripor &&
        imageData.src &&
        !getCandidateForSrc(imageData.src, imageSet) &&
        !imageSet.has1x
      ) {
        imageSet.srcset += ", " + imageData.src;
        imageSet.cands.push({
          url: imageData.src,
          d: 1,
          set: imageSet
        });
      }
    } else if (imageData.src) {
      imageData.sets.push({
        srcset: imageData.src,
        sizes: null
      });
    }

    imageData.curCan = null;
    imageData.curSrc = undefined;

    // if img has picture or the srcset was removed or has a srcset and does not support srcset at all
    // or has a w descriptor (and does not support sizes) set support to false to evaluate
    imageData.supported = !(
      hasPicture ||
      (imageSet && !pf.supSrcset) ||
      (isWDescripor && !pf.supSizes)
    );

    if (srcsetParsed && pf.supSrcset && !imageData.supported) {
      if (srcsetAttribute) {
        setImgAttr.call(element, srcsetAttr, srcsetAttribute);
        element.srcset = "";
      } else {
        removeImgAttr.call(element, srcsetAttr);
      }
    }

    if (
      imageData.supported &&
      !imageData.srcset &&
      ((!imageData.src && element.src) ||
        element.src !== pf.makeUrl(imageData.src))
    ) {
      if (imageData.src === null) {
        element.removeAttribute("src");
      } else {
        element.src = imageData.src;
      }
    }

    imageData.parsed = true;
  };

  pf.fillImg = function(element, options) {
    var imageData;
    var extreme = options.reselect || options.reevaluate;

    // expando for caching data on the img
    if (!element[pf.ns]) {
      element[pf.ns] = {};
    }

    imageData = element[pf.ns];

    // if the element has already been evaluated, skip it
    // unless `options.reevaluate` is set to true ( this, for example,
    // is set to true when running `picturefill` on `resize` ).
    if (!extreme && imageData.evaled === evalId) {
      return;
    }

    if (!imageData.parsed || options.reevaluate) {
      pf.parseSets(element, element.parentNode, options);
    }

    if (!imageData.supported) {
      applyBestCandidate(element);
    } else {
      imageData.evaled = evalId;
    }
  };

  pf.setupRun = function() {
    if (!alreadyRun || isVwDirty || DPR !== window.devicePixelRatio) {
      updateMetrics();
    }
  };

  // If picture is supported, well, that's awesome.
  if (pf.supPicture) {
    picturefill = noop;
    pf.fillImg = noop;
  } else {
    // Set up picture polyfill by polling the document
    (function() {
      var isDomReady;
      var regReady = window.attachEvent ? /d$|^c/ : /d$|^c|^i/;

      var run = function() {
        var readyState = document.readyState || "";

        timerId = setTimeout(run, readyState === "loading" ? 200 : 999);
        if (document.body) {
          pf.fillImgs();
          isDomReady = isDomReady || regReady.test(readyState);
          if (isDomReady) {
            clearTimeout(timerId);
          }
        }
      };

      var timerId = setTimeout(run, document.body ? 9 : 99);

      // Also attach picturefill on resize and readystatechange
      // http://modernjavascript.blogspot.com/2013/08/building-better-debounce.html
      var debounce = function(func, wait) {
        var timeout, timestamp;
        var later = function() {
          var last = new Date() - timestamp;

          if (last < wait) {
            timeout = setTimeout(later, wait - last);
          } else {
            timeout = null;
            func();
          }
        };

        return function() {
          timestamp = new Date();

          if (!timeout) {
            timeout = setTimeout(later, wait);
          }
        };
      };
      var lastClientWidth = docElem.clientHeight;
      var onResize = function() {
        isVwDirty =
          Math.max(window.innerWidth || 0, docElem.clientWidth) !==
            units.width || docElem.clientHeight !== lastClientWidth;
        lastClientWidth = docElem.clientHeight;
        if (isVwDirty) {
          pf.fillImgs();
        }
      };

      on(window, "resize", debounce(onResize, 99));
      on(document, "readystatechange", run);
    })();
  }

  pf.picturefill = picturefill;
  //use this internally for easy monkey patching/performance testing
  pf.fillImgs = picturefill;
  pf.teardownRun = noop;

  /* expose methods for testing */
  picturefill._ = pf;

  window.picturefillCFG = {
    pf: pf,
    push: function(args) {
      var name = args.shift();
      if (typeof pf[name] === "function") {
        pf[name].apply(pf, args);
      } else {
        cfg[name] = args[0];
        if (alreadyRun) {
          pf.fillImgs({ reselect: true });
        }
      }
    }
  };

  while (setOptions && setOptions.length) {
    window.picturefillCFG.push(setOptions.shift());
  }

  /* expose picturefill */
  window.picturefill = picturefill;

  /* expose picturefill */
  if (typeof module === "object" && typeof module.exports === "object") {
    // CommonJS, just export
    module.exports = picturefill;
  } else if (true) {
    // AMD support
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return picturefill;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  // IE8 evals this sync, so it must be the last thing we do
  if (!pf.supPicture) {
    types["image/webp"] = detectTypeSupport(
      "image/webp",
      "data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA=="
    );
  }
})(window, document);


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* Web Font Loader v1.6.28 - (c) Adobe Systems, Google. License: Apache 2.0 */ (function() {
  function aa(a, b, c) {
    return a.call.apply(a.bind, arguments);
  }
  function ba(a, b, c) {
    if (!a) throw Error();
    if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);
      return function() {
        var c = Array.prototype.slice.call(arguments);
        Array.prototype.unshift.apply(c, d);
        return a.apply(b, c);
      };
    }
    return function() {
      return a.apply(b, arguments);
    };
  }
  function p(a, b, c) {
    p =
      Function.prototype.bind &&
      -1 != Function.prototype.bind.toString().indexOf("native code")
        ? aa
        : ba;
    return p.apply(null, arguments);
  }
  var q =
    Date.now ||
    function() {
      return +new Date();
    };
  function ca(a, b) {
    this.a = a;
    this.o = b || a;
    this.c = this.o.document;
  }
  var da = !!window.FontFace;
  function t(a, b, c, d) {
    b = a.c.createElement(b);
    if (c)
      for (var e in c)
        c.hasOwnProperty(e) &&
          ("style" == e ? (b.style.cssText = c[e]) : b.setAttribute(e, c[e]));
    d && b.appendChild(a.c.createTextNode(d));
    return b;
  }
  function u(a, b, c) {
    a = a.c.getElementsByTagName(b)[0];
    a || (a = document.documentElement);
    a.insertBefore(c, a.lastChild);
  }
  function v(a) {
    a.parentNode && a.parentNode.removeChild(a);
  }
  function w(a, b, c) {
    b = b || [];
    c = c || [];
    for (var d = a.className.split(/\s+/), e = 0; e < b.length; e += 1) {
      for (var f = !1, g = 0; g < d.length; g += 1)
        if (b[e] === d[g]) {
          f = !0;
          break;
        }
      f || d.push(b[e]);
    }
    b = [];
    for (e = 0; e < d.length; e += 1) {
      f = !1;
      for (g = 0; g < c.length; g += 1)
        if (d[e] === c[g]) {
          f = !0;
          break;
        }
      f || b.push(d[e]);
    }
    a.className = b
      .join(" ")
      .replace(/\s+/g, " ")
      .replace(/^\s+|\s+$/, "");
  }
  function y(a, b) {
    for (var c = a.className.split(/\s+/), d = 0, e = c.length; d < e; d++)
      if (c[d] == b) return !0;
    return !1;
  }
  function ea(a) {
    return a.o.location.hostname || a.a.location.hostname;
  }
  function z(a, b, c) {
    function d() {
      m && e && f && (m(g), (m = null));
    }
    b = t(a, "link", { rel: "stylesheet", href: b, media: "all" });
    var e = !1,
      f = !0,
      g = null,
      m = c || null;
    da
      ? ((b.onload = function() {
          e = !0;
          d();
        }),
        (b.onerror = function() {
          e = !0;
          g = Error("Stylesheet failed to load");
          d();
        }))
      : setTimeout(function() {
          e = !0;
          d();
        }, 0);
    u(a, "head", b);
  }
  function A(a, b, c, d) {
    var e = a.c.getElementsByTagName("head")[0];
    if (e) {
      var f = t(a, "script", { src: b }),
        g = !1;
      f.onload = f.onreadystatechange = function() {
        g ||
          (this.readyState &&
            "loaded" != this.readyState &&
            "complete" != this.readyState) ||
          ((g = !0),
          c && c(null),
          (f.onload = f.onreadystatechange = null),
          "HEAD" == f.parentNode.tagName && e.removeChild(f));
      };
      e.appendChild(f);
      setTimeout(function() {
        g || ((g = !0), c && c(Error("Script load timeout")));
      }, d || 5e3);
      return f;
    }
    return null;
  }
  function B() {
    this.a = 0;
    this.c = null;
  }
  function C(a) {
    a.a++;
    return function() {
      a.a--;
      D(a);
    };
  }
  function E(a, b) {
    a.c = b;
    D(a);
  }
  function D(a) {
    0 == a.a && a.c && (a.c(), (a.c = null));
  }
  function F(a) {
    this.a = a || "-";
  }
  F.prototype.c = function(a) {
    for (var b = [], c = 0; c < arguments.length; c++)
      b.push(arguments[c].replace(/[\W_]+/g, "").toLowerCase());
    return b.join(this.a);
  };
  function G(a, b) {
    this.c = a;
    this.f = 4;
    this.a = "n";
    var c = (b || "n4").match(/^([nio])([1-9])$/i);
    c && ((this.a = c[1]), (this.f = parseInt(c[2], 10)));
  }
  function fa(a) {
    return H(a) + " " + (a.f + "00") + " 300px " + I(a.c);
  }
  function I(a) {
    var b = [];
    a = a.split(/,\s*/);
    for (var c = 0; c < a.length; c++) {
      var d = a[c].replace(/['"]/g, "");
      -1 != d.indexOf(" ") || /^\d/.test(d) ? b.push("'" + d + "'") : b.push(d);
    }
    return b.join(",");
  }
  function J(a) {
    return a.a + a.f;
  }
  function H(a) {
    var b = "normal";
    "o" === a.a ? (b = "oblique") : "i" === a.a && (b = "italic");
    return b;
  }
  function ga(a) {
    var b = 4,
      c = "n",
      d = null;
    a &&
      ((d = a.match(/(normal|oblique|italic)/i)) &&
        d[1] &&
        (c = d[1].substr(0, 1).toLowerCase()),
      (d = a.match(/([1-9]00|normal|bold)/i)) &&
        d[1] &&
        (/bold/i.test(d[1])
          ? (b = 7)
          : /[1-9]00/.test(d[1]) && (b = parseInt(d[1].substr(0, 1), 10))));
    return c + b;
  }
  function ha(a, b) {
    this.c = a;
    this.f = a.o.document.documentElement;
    this.h = b;
    this.a = new F("-");
    this.j = !1 !== b.events;
    this.g = !1 !== b.classes;
  }
  function ia(a) {
    a.g && w(a.f, [a.a.c("wf", "loading")]);
    K(a, "loading");
  }
  function L(a) {
    if (a.g) {
      var b = y(a.f, a.a.c("wf", "active")),
        c = [],
        d = [a.a.c("wf", "loading")];
      b || c.push(a.a.c("wf", "inactive"));
      w(a.f, c, d);
    }
    K(a, "inactive");
  }
  function K(a, b, c) {
    if (a.j && a.h[b])
      if (c) a.h[b](c.c, J(c));
      else a.h[b]();
  }
  function ja() {
    this.c = {};
  }
  function ka(a, b, c) {
    var d = [],
      e;
    for (e in b)
      if (b.hasOwnProperty(e)) {
        var f = a.c[e];
        f && d.push(f(b[e], c));
      }
    return d;
  }
  function M(a, b) {
    this.c = a;
    this.f = b;
    this.a = t(this.c, "span", { "aria-hidden": "true" }, this.f);
  }
  function N(a) {
    u(a.c, "body", a.a);
  }
  function O(a) {
    return (
      "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" +
      I(a.c) +
      ";" +
      ("font-style:" + H(a) + ";font-weight:" + (a.f + "00") + ";")
    );
  }
  function P(a, b, c, d, e, f) {
    this.g = a;
    this.j = b;
    this.a = d;
    this.c = c;
    this.f = e || 3e3;
    this.h = f || void 0;
  }
  P.prototype.start = function() {
    var a = this.c.o.document,
      b = this,
      c = q(),
      d = new Promise(function(d, e) {
        function f() {
          q() - c >= b.f
            ? e()
            : a.fonts.load(fa(b.a), b.h).then(
                function(a) {
                  1 <= a.length ? d() : setTimeout(f, 25);
                },
                function() {
                  e();
                }
              );
        }
        f();
      }),
      e = null,
      f = new Promise(function(a, d) {
        e = setTimeout(d, b.f);
      });
    Promise.race([f, d]).then(
      function() {
        e && (clearTimeout(e), (e = null));
        b.g(b.a);
      },
      function() {
        b.j(b.a);
      }
    );
  };
  function Q(a, b, c, d, e, f, g) {
    this.v = a;
    this.B = b;
    this.c = c;
    this.a = d;
    this.s = g || "BESbswy";
    this.f = {};
    this.w = e || 3e3;
    this.u = f || null;
    this.m = this.j = this.h = this.g = null;
    this.g = new M(this.c, this.s);
    this.h = new M(this.c, this.s);
    this.j = new M(this.c, this.s);
    this.m = new M(this.c, this.s);
    a = new G(this.a.c + ",serif", J(this.a));
    a = O(a);
    this.g.a.style.cssText = a;
    a = new G(this.a.c + ",sans-serif", J(this.a));
    a = O(a);
    this.h.a.style.cssText = a;
    a = new G("serif", J(this.a));
    a = O(a);
    this.j.a.style.cssText = a;
    a = new G("sans-serif", J(this.a));
    a = O(a);
    this.m.a.style.cssText = a;
    N(this.g);
    N(this.h);
    N(this.j);
    N(this.m);
  }
  var R = { D: "serif", C: "sans-serif" },
    S = null;
  function T() {
    if (null === S) {
      var a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(
        window.navigator.userAgent
      );
      S =
        !!a &&
        (536 > parseInt(a[1], 10) ||
          (536 === parseInt(a[1], 10) && 11 >= parseInt(a[2], 10)));
    }
    return S;
  }
  Q.prototype.start = function() {
    this.f.serif = this.j.a.offsetWidth;
    this.f["sans-serif"] = this.m.a.offsetWidth;
    this.A = q();
    U(this);
  };
  function la(a, b, c) {
    for (var d in R)
      if (R.hasOwnProperty(d) && b === a.f[R[d]] && c === a.f[R[d]]) return !0;
    return !1;
  }
  function U(a) {
    var b = a.g.a.offsetWidth,
      c = a.h.a.offsetWidth,
      d;
    (d = b === a.f.serif && c === a.f["sans-serif"]) ||
      (d = T() && la(a, b, c));
    d
      ? q() - a.A >= a.w
        ? T() && la(a, b, c) && (null === a.u || a.u.hasOwnProperty(a.a.c))
          ? V(a, a.v)
          : V(a, a.B)
        : ma(a)
      : V(a, a.v);
  }
  function ma(a) {
    setTimeout(
      p(function() {
        U(this);
      }, a),
      50
    );
  }
  function V(a, b) {
    setTimeout(
      p(function() {
        v(this.g.a);
        v(this.h.a);
        v(this.j.a);
        v(this.m.a);
        b(this.a);
      }, a),
      0
    );
  }
  function W(a, b, c) {
    this.c = a;
    this.a = b;
    this.f = 0;
    this.m = this.j = !1;
    this.s = c;
  }
  var X = null;
  W.prototype.g = function(a) {
    var b = this.a;
    b.g &&
      w(
        b.f,
        [b.a.c("wf", a.c, J(a).toString(), "active")],
        [
          b.a.c("wf", a.c, J(a).toString(), "loading"),
          b.a.c("wf", a.c, J(a).toString(), "inactive")
        ]
      );
    K(b, "fontactive", a);
    this.m = !0;
    na(this);
  };
  W.prototype.h = function(a) {
    var b = this.a;
    if (b.g) {
      var c = y(b.f, b.a.c("wf", a.c, J(a).toString(), "active")),
        d = [],
        e = [b.a.c("wf", a.c, J(a).toString(), "loading")];
      c || d.push(b.a.c("wf", a.c, J(a).toString(), "inactive"));
      w(b.f, d, e);
    }
    K(b, "fontinactive", a);
    na(this);
  };
  function na(a) {
    0 == --a.f &&
      a.j &&
      (a.m
        ? ((a = a.a),
          a.g &&
            w(
              a.f,
              [a.a.c("wf", "active")],
              [a.a.c("wf", "loading"), a.a.c("wf", "inactive")]
            ),
          K(a, "active"))
        : L(a.a));
  }
  function oa(a) {
    this.j = a;
    this.a = new ja();
    this.h = 0;
    this.f = this.g = !0;
  }
  oa.prototype.load = function(a) {
    this.c = new ca(this.j, a.context || this.j);
    this.g = !1 !== a.events;
    this.f = !1 !== a.classes;
    pa(this, new ha(this.c, a), a);
  };
  function qa(a, b, c, d, e) {
    var f = 0 == --a.h;
    (a.f || a.g) &&
      setTimeout(function() {
        var a = e || null,
          m = d || null || {};
        if (0 === c.length && f) L(b.a);
        else {
          b.f += c.length;
          f && (b.j = f);
          var h,
            l = [];
          for (h = 0; h < c.length; h++) {
            var k = c[h],
              n = m[k.c],
              r = b.a,
              x = k;
            r.g && w(r.f, [r.a.c("wf", x.c, J(x).toString(), "loading")]);
            K(r, "fontloading", x);
            r = null;
            if (null === X)
              if (window.FontFace) {
                var x = /Gecko.*Firefox\/(\d+)/.exec(
                    window.navigator.userAgent
                  ),
                  xa =
                    /OS X.*Version\/10\..*Safari/.exec(
                      window.navigator.userAgent
                    ) && /Apple/.exec(window.navigator.vendor);
                X = x ? 42 < parseInt(x[1], 10) : xa ? !1 : !0;
              } else X = !1;
            X
              ? (r = new P(p(b.g, b), p(b.h, b), b.c, k, b.s, n))
              : (r = new Q(p(b.g, b), p(b.h, b), b.c, k, b.s, a, n));
            l.push(r);
          }
          for (h = 0; h < l.length; h++) l[h].start();
        }
      }, 0);
  }
  function pa(a, b, c) {
    var d = [],
      e = c.timeout;
    ia(b);
    var d = ka(a.a, c, a.c),
      f = new W(a.c, b, e);
    a.h = d.length;
    b = 0;
    for (c = d.length; b < c; b++)
      d[b].load(function(b, d, c) {
        qa(a, f, b, d, c);
      });
  }
  function ra(a, b) {
    this.c = a;
    this.a = b;
  }
  ra.prototype.load = function(a) {
    function b() {
      if (f["__mti_fntLst" + d]) {
        var c = f["__mti_fntLst" + d](),
          e = [],
          h;
        if (c)
          for (var l = 0; l < c.length; l++) {
            var k = c[l].fontfamily;
            void 0 != c[l].fontStyle && void 0 != c[l].fontWeight
              ? ((h = c[l].fontStyle + c[l].fontWeight), e.push(new G(k, h)))
              : e.push(new G(k));
          }
        a(e);
      } else
        setTimeout(function() {
          b();
        }, 50);
    }
    var c = this,
      d = c.a.projectId,
      e = c.a.version;
    if (d) {
      var f = c.c.o;
      A(
        this.c,
        (c.a.api || "https://fast.fonts.net/jsapi") +
          "/" +
          d +
          ".js" +
          (e ? "?v=" + e : ""),
        function(e) {
          e
            ? a([])
            : ((f["__MonotypeConfiguration__" + d] = function() {
                return c.a;
              }),
              b());
        }
      ).id =
        "__MonotypeAPIScript__" + d;
    } else a([]);
  };
  function sa(a, b) {
    this.c = a;
    this.a = b;
  }
  sa.prototype.load = function(a) {
    var b,
      c,
      d = this.a.urls || [],
      e = this.a.families || [],
      f = this.a.testStrings || {},
      g = new B();
    b = 0;
    for (c = d.length; b < c; b++) z(this.c, d[b], C(g));
    var m = [];
    b = 0;
    for (c = e.length; b < c; b++)
      if (((d = e[b].split(":")), d[1]))
        for (var h = d[1].split(","), l = 0; l < h.length; l += 1)
          m.push(new G(d[0], h[l]));
      else m.push(new G(d[0]));
    E(g, function() {
      a(m, f);
    });
  };
  function ta(a, b) {
    a ? (this.c = a) : (this.c = ua);
    this.a = [];
    this.f = [];
    this.g = b || "";
  }
  var ua = "https://fonts.googleapis.com/css";
  function va(a, b) {
    for (var c = b.length, d = 0; d < c; d++) {
      var e = b[d].split(":");
      3 == e.length && a.f.push(e.pop());
      var f = "";
      2 == e.length && "" != e[1] && (f = ":");
      a.a.push(e.join(f));
    }
  }
  function wa(a) {
    if (0 == a.a.length) throw Error("No fonts to load!");
    if (-1 != a.c.indexOf("kit=")) return a.c;
    for (var b = a.a.length, c = [], d = 0; d < b; d++)
      c.push(a.a[d].replace(/ /g, "+"));
    b = a.c + "?family=" + c.join("%7C");
    0 < a.f.length && (b += "&subset=" + a.f.join(","));
    0 < a.g.length && (b += "&text=" + encodeURIComponent(a.g));
    return b;
  }
  function ya(a) {
    this.f = a;
    this.a = [];
    this.c = {};
  }
  var za = {
      latin: "BESbswy",
      "latin-ext": "\u00e7\u00f6\u00fc\u011f\u015f",
      cyrillic: "\u0439\u044f\u0416",
      greek: "\u03b1\u03b2\u03a3",
      khmer: "\u1780\u1781\u1782",
      Hanuman: "\u1780\u1781\u1782"
    },
    Aa = {
      thin: "1",
      extralight: "2",
      "extra-light": "2",
      ultralight: "2",
      "ultra-light": "2",
      light: "3",
      regular: "4",
      book: "4",
      medium: "5",
      "semi-bold": "6",
      semibold: "6",
      "demi-bold": "6",
      demibold: "6",
      bold: "7",
      "extra-bold": "8",
      extrabold: "8",
      "ultra-bold": "8",
      ultrabold: "8",
      black: "9",
      heavy: "9",
      l: "3",
      r: "4",
      b: "7"
    },
    Ba = { i: "i", italic: "i", n: "n", normal: "n" },
    Ca = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
  function Da(a) {
    for (var b = a.f.length, c = 0; c < b; c++) {
      var d = a.f[c].split(":"),
        e = d[0].replace(/\+/g, " "),
        f = ["n4"];
      if (2 <= d.length) {
        var g;
        var m = d[1];
        g = [];
        if (m)
          for (var m = m.split(","), h = m.length, l = 0; l < h; l++) {
            var k;
            k = m[l];
            if (k.match(/^[\w-]+$/)) {
              var n = Ca.exec(k.toLowerCase());
              if (null == n) k = "";
              else {
                k = n[2];
                k = null == k || "" == k ? "n" : Ba[k];
                n = n[1];
                if (null == n || "" == n) n = "4";
                else
                  var r = Aa[n],
                    n = r ? r : isNaN(n) ? "4" : n.substr(0, 1);
                k = [k, n].join("");
              }
            } else k = "";
            k && g.push(k);
          }
        0 < g.length && (f = g);
        3 == d.length &&
          ((d = d[2]),
          (g = []),
          (d = d ? d.split(",") : g),
          0 < d.length && (d = za[d[0]]) && (a.c[e] = d));
      }
      a.c[e] || ((d = za[e]) && (a.c[e] = d));
      for (d = 0; d < f.length; d += 1) a.a.push(new G(e, f[d]));
    }
  }
  function Ea(a, b) {
    this.c = a;
    this.a = b;
  }
  var Fa = { Arimo: !0, Cousine: !0, Tinos: !0 };
  Ea.prototype.load = function(a) {
    var b = new B(),
      c = this.c,
      d = new ta(this.a.api, this.a.text),
      e = this.a.families;
    va(d, e);
    var f = new ya(e);
    Da(f);
    z(c, wa(d), C(b));
    E(b, function() {
      a(f.a, f.c, Fa);
    });
  };
  function Ga(a, b) {
    this.c = a;
    this.a = b;
  }
  Ga.prototype.load = function(a) {
    var b = this.a.id,
      c = this.c.o;
    b
      ? A(
          this.c,
          (this.a.api || "https://use.typekit.net") + "/" + b + ".js",
          function(b) {
            if (b) a([]);
            else if (c.Typekit && c.Typekit.config && c.Typekit.config.fn) {
              b = c.Typekit.config.fn;
              for (var e = [], f = 0; f < b.length; f += 2)
                for (var g = b[f], m = b[f + 1], h = 0; h < m.length; h++)
                  e.push(new G(g, m[h]));
              try {
                c.Typekit.load({ events: !1, classes: !1, async: !0 });
              } catch (l) {}
              a(e);
            }
          },
          2e3
        )
      : a([]);
  };
  function Ha(a, b) {
    this.c = a;
    this.f = b;
    this.a = [];
  }
  Ha.prototype.load = function(a) {
    var b = this.f.id,
      c = this.c.o,
      d = this;
    b
      ? (c.__webfontfontdeckmodule__ || (c.__webfontfontdeckmodule__ = {}),
        (c.__webfontfontdeckmodule__[b] = function(b, c) {
          for (var g = 0, m = c.fonts.length; g < m; ++g) {
            var h = c.fonts[g];
            d.a.push(
              new G(
                h.name,
                ga("font-weight:" + h.weight + ";font-style:" + h.style)
              )
            );
          }
          a(d.a);
        }),
        A(
          this.c,
          (this.f.api || "https://f.fontdeck.com/s/css/js/") +
            ea(this.c) +
            "/" +
            b +
            ".js",
          function(b) {
            b && a([]);
          }
        ))
      : a([]);
  };
  var Y = new oa(window);
  Y.a.c.custom = function(a, b) {
    return new sa(b, a);
  };
  Y.a.c.fontdeck = function(a, b) {
    return new Ha(b, a);
  };
  Y.a.c.monotype = function(a, b) {
    return new ra(b, a);
  };
  Y.a.c.typekit = function(a, b) {
    return new Ga(b, a);
  };
  Y.a.c.google = function(a, b) {
    return new Ea(b, a);
  };
  var Z = { load: p(Y.load, Y) };
   true
    ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return Z;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    : "undefined" !== typeof module && module.exports
      ? (module.exports = Z)
      : ((window.WebFont = Z),
        window.WebFontConfig && Y.load(window.WebFontConfig));
})();


/***/ }),
/* 63 */
/***/ (function(module, exports) {

/*! responsive-nav.js 1.0.39
 * https://github.com/viljamis/responsive-nav.js
 * http://responsive-nav.com
 *
 * Copyright (c) 2015 @viljamis
 * Available under the MIT license
 */

/* global Event */
(function(document, window, index) {
  // Index is used to keep multiple navs on the same page namespaced

  "use strict";

  var responsiveNav = function(el, options) {
    var computed = !!window.getComputedStyle;

    /**
     * getComputedStyle polyfill for old browsers
     */
    if (!computed) {
      window.getComputedStyle = function(el) {
        this.el = el;
        this.getPropertyValue = function(prop) {
          var re = /(\-([a-z]){1})/g;
          if (prop === "float") {
            prop = "styleFloat";
          }
          if (re.test(prop)) {
            prop = prop.replace(re, function() {
              return arguments[2].toUpperCase();
            });
          }
          return el.currentStyle[prop] ? el.currentStyle[prop] : null;
        };
        return this;
      };
    }
    /* exported addEvent, removeEvent, getChildren, setAttributes, addClass, removeClass, forEach */

    /**
     * Add Event
     * fn arg can be an object or a function, thanks to handleEvent
     * read more at: http://www.thecssninja.com/javascript/handleevent
     *
     * @param  {element}  element
     * @param  {event}    event
     * @param  {Function} fn
     * @param  {boolean}  bubbling
     */
    var addEvent = function(el, evt, fn, bubble) {
        if ("addEventListener" in el) {
          // BBOS6 doesn't support handleEvent, catch and polyfill
          try {
            el.addEventListener(evt, fn, bubble);
          } catch (e) {
            if (typeof fn === "object" && fn.handleEvent) {
              el.addEventListener(
                evt,
                function(e) {
                  // Bind fn as this and set first arg as event object
                  fn.handleEvent.call(fn, e);
                },
                bubble
              );
            } else {
              throw e;
            }
          }
        } else if ("attachEvent" in el) {
          // check if the callback is an object and contains handleEvent
          if (typeof fn === "object" && fn.handleEvent) {
            el.attachEvent("on" + evt, function() {
              // Bind fn as this
              fn.handleEvent.call(fn);
            });
          } else {
            el.attachEvent("on" + evt, fn);
          }
        }
      },
      /**
       * Remove Event
       *
       * @param  {element}  element
       * @param  {event}    event
       * @param  {Function} fn
       * @param  {boolean}  bubbling
       */
      removeEvent = function(el, evt, fn, bubble) {
        if ("removeEventListener" in el) {
          try {
            el.removeEventListener(evt, fn, bubble);
          } catch (e) {
            if (typeof fn === "object" && fn.handleEvent) {
              el.removeEventListener(
                evt,
                function(e) {
                  fn.handleEvent.call(fn, e);
                },
                bubble
              );
            } else {
              throw e;
            }
          }
        } else if ("detachEvent" in el) {
          if (typeof fn === "object" && fn.handleEvent) {
            el.detachEvent("on" + evt, function() {
              fn.handleEvent.call(fn);
            });
          } else {
            el.detachEvent("on" + evt, fn);
          }
        }
      },
      /**
       * Get the children of any element
       *
       * @param  {element}
       * @return {array} Returns matching elements in an array
       */
      getChildren = function(e) {
        if (e.children.length < 1) {
          throw new Error("The Nav container has no containing elements");
        }
        // Store all children in array
        var children = [];
        // Loop through children and store in array if child != TextNode
        for (var i = 0; i < e.children.length; i++) {
          if (e.children[i].nodeType === 1) {
            children.push(e.children[i]);
          }
        }
        return children;
      },
      /**
       * Sets multiple attributes at once
       *
       * @param {element} element
       * @param {attrs}   attrs
       */
      setAttributes = function(el, attrs) {
        for (var key in attrs) {
          el.setAttribute(key, attrs[key]);
        }
      },
      /**
       * Adds a class to any element
       *
       * @param {element} element
       * @param {string}  class
       */
      addClass = function(el, cls) {
        if (el.className.indexOf(cls) !== 0) {
          el.className += " " + cls;
          el.className = el.className.replace(/(^\s*)|(\s*$)/g, "");
        }
      },
      /**
       * Remove a class from any element
       *
       * @param  {element} element
       * @param  {string}  class
       */
      removeClass = function(el, cls) {
        var reg = new RegExp("(\\s|^)" + cls + "(\\s|$)");
        el.className = el.className
          .replace(reg, " ")
          .replace(/(^\s*)|(\s*$)/g, "");
      },
      /**
       * forEach method that passes back the stuff we need
       *
       * @param  {array}    array
       * @param  {Function} callback
       * @param  {scope}    scope
       */
      forEach = function(array, callback, scope) {
        for (var i = 0; i < array.length; i++) {
          callback.call(scope, i, array[i]);
        }
      };

    var nav,
      opts,
      navToggle,
      styleElement = document.createElement("style"),
      htmlEl = document.documentElement,
      hasAnimFinished,
      isMobile,
      navOpen;

    var ResponsiveNav = function(el, options) {
      var i;

      /**
       * Default options
       * @type {Object}
       */
      this.options = {
        animate: true, // Boolean: Use CSS3 transitions, true or false
        transition: 284, // Integer: Speed of the transition, in milliseconds
        label: "Menu", // String: Label for the navigation toggle
        insert: "before", // String: Insert the toggle before or after the navigation
        customToggle: "", // Selector: Specify the ID of a custom toggle
        closeOnNavClick: false, // Boolean: Close the navigation when one of the links are clicked
        openPos: "relative", // String: Position of the opened nav, relative or static
        navClass: "nav-collapse", // String: Default CSS class. If changed, you need to edit the CSS too!
        navActiveClass: "js-nav-active", // String: Class that is added to <html> element when nav is active
        jsClass: "js", // String: 'JS enabled' class which is added to <html> element
        init: function() {}, // Function: Init callback
        open: function() {}, // Function: Open callback
        close: function() {} // Function: Close callback
      };

      // User defined options
      for (i in options) {
        this.options[i] = options[i];
      }

      // Adds "js" class for <html>
      addClass(htmlEl, this.options.jsClass);

      // Wrapper
      this.wrapperEl = el.replace("#", "");

      // Try selecting ID first
      if (document.getElementById(this.wrapperEl)) {
        this.wrapper = document.getElementById(this.wrapperEl);

        // If element with an ID doesn't exist, use querySelector
      } else if (document.querySelector(this.wrapperEl)) {
        this.wrapper = document.querySelector(this.wrapperEl);

        // If element doesn't exists, stop here.
      } else {
        throw new Error(
          "The nav element you are trying to select doesn't exist"
        );
      }

      // Inner wrapper
      this.wrapper.inner = getChildren(this.wrapper);

      // For minification
      opts = this.options;
      nav = this.wrapper;

      // Init
      this._init(this);
    };

    ResponsiveNav.prototype = {
      /**
       * Unattaches events and removes any classes that were added
       */
      destroy: function() {
        this._removeStyles();
        removeClass(nav, "closed");
        removeClass(nav, "opened");
        removeClass(nav, opts.navClass);
        removeClass(nav, opts.navClass + "-" + this.index);
        removeClass(htmlEl, opts.navActiveClass);
        nav.removeAttribute("style");
        nav.removeAttribute("aria-hidden");

        removeEvent(window, "resize", this, false);
        removeEvent(window, "focus", this, false);
        removeEvent(document.body, "touchmove", this, false);
        removeEvent(navToggle, "touchstart", this, false);
        removeEvent(navToggle, "touchend", this, false);
        removeEvent(navToggle, "mouseup", this, false);
        removeEvent(navToggle, "keyup", this, false);
        removeEvent(navToggle, "click", this, false);

        if (!opts.customToggle) {
          navToggle.parentNode.removeChild(navToggle);
        } else {
          navToggle.removeAttribute("aria-hidden");
        }
      },

      /**
       * Toggles the navigation open/close
       */
      toggle: function() {
        if (hasAnimFinished === true) {
          if (!navOpen) {
            this.open();
          } else {
            this.close();
          }
        }
      },

      /**
       * Opens the navigation
       */
      open: function() {
        if (!navOpen) {
          removeClass(nav, "closed");
          addClass(nav, "opened");
          addClass(htmlEl, opts.navActiveClass);
          addClass(navToggle, "active");
          nav.style.position = opts.openPos;
          setAttributes(nav, { "aria-hidden": "false" });
          navOpen = true;
          opts.open();
        }
      },

      /**
       * Closes the navigation
       */
      close: function() {
        if (navOpen) {
          addClass(nav, "closed");
          removeClass(nav, "opened");
          removeClass(htmlEl, opts.navActiveClass);
          removeClass(navToggle, "active");
          setAttributes(nav, { "aria-hidden": "true" });

          // If animations are enabled, wait until they finish
          if (opts.animate) {
            hasAnimFinished = false;
            setTimeout(function() {
              nav.style.position = "absolute";
              hasAnimFinished = true;
            }, opts.transition + 10);

            // Animations aren't enabled, we can do these immediately
          } else {
            nav.style.position = "absolute";
          }

          navOpen = false;
          opts.close();
        }
      },

      /**
       * Resize is called on window resize and orientation change.
       * It initializes the CSS styles and height calculations.
       */
      resize: function() {
        // Resize watches navigation toggle's display state
        if (
          window
            .getComputedStyle(navToggle, null)
            .getPropertyValue("display") !== "none"
        ) {
          isMobile = true;
          setAttributes(navToggle, { "aria-hidden": "false" });

          // If the navigation is hidden
          if (nav.className.match(/(^|\s)closed(\s|$)/)) {
            setAttributes(nav, { "aria-hidden": "true" });
            nav.style.position = "absolute";
          }

          this._createStyles();
          this._calcHeight();
        } else {
          isMobile = false;
          setAttributes(navToggle, { "aria-hidden": "true" });
          setAttributes(nav, { "aria-hidden": "false" });
          nav.style.position = opts.openPos;
          this._removeStyles();
        }
      },

      /**
       * Takes care of all even handling
       *
       * @param  {event} event
       * @return {type} returns the type of event that should be used
       */
      handleEvent: function(e) {
        var evt = e || window.event;

        switch (evt.type) {
          case "touchstart":
            this._onTouchStart(evt);
            break;
          case "touchmove":
            this._onTouchMove(evt);
            break;
          case "touchend":
          case "mouseup":
            this._onTouchEnd(evt);
            break;
          case "click":
            this._preventDefault(evt);
            break;
          case "keyup":
            this._onKeyUp(evt);
            break;
          case "focus":
          case "resize":
            this.resize(evt);
            break;
        }
      },

      /**
       * Initializes the widget
       */
      _init: function() {
        this.index = index++;

        addClass(nav, opts.navClass);
        addClass(nav, opts.navClass + "-" + this.index);
        addClass(nav, "closed");
        hasAnimFinished = true;
        navOpen = false;

        this._closeOnNavClick();
        this._createToggle();
        this._transitions();
        this.resize();

        /**
         * On IE8 the resize event triggers too early for some reason
         * so it's called here again on init to make sure all the
         * calculated styles are correct.
         */
        var self = this;
        setTimeout(function() {
          self.resize();
        }, 20);

        addEvent(window, "resize", this, false);
        addEvent(window, "focus", this, false);
        addEvent(document.body, "touchmove", this, false);
        addEvent(navToggle, "touchstart", this, false);
        addEvent(navToggle, "touchend", this, false);
        addEvent(navToggle, "mouseup", this, false);
        addEvent(navToggle, "keyup", this, false);
        addEvent(navToggle, "click", this, false);

        /**
         * Init callback here
         */
        opts.init();
      },

      /**
       * Creates Styles to the <head>
       */
      _createStyles: function() {
        if (!styleElement.parentNode) {
          styleElement.type = "text/css";
          document.getElementsByTagName("head")[0].appendChild(styleElement);
        }
      },

      /**
       * Removes styles from the <head>
       */
      _removeStyles: function() {
        if (styleElement.parentNode) {
          styleElement.parentNode.removeChild(styleElement);
        }
      },

      /**
       * Creates Navigation Toggle
       */
      _createToggle: function() {
        // If there's no toggle, let's create one
        if (!opts.customToggle) {
          var toggle = document.createElement("a");
          toggle.innerHTML = opts.label;
          setAttributes(toggle, {
            href: "#",
            class: "nav-toggle"
          });

          // Determine where to insert the toggle
          if (opts.insert === "after") {
            nav.parentNode.insertBefore(toggle, nav.nextSibling);
          } else {
            nav.parentNode.insertBefore(toggle, nav);
          }

          navToggle = toggle;

          // There is a toggle already, let's use that one
        } else {
          var toggleEl = opts.customToggle.replace("#", "");

          if (document.getElementById(toggleEl)) {
            navToggle = document.getElementById(toggleEl);
          } else if (document.querySelector(toggleEl)) {
            navToggle = document.querySelector(toggleEl);
          } else {
            throw new Error(
              "The custom nav toggle you are trying to select doesn't exist"
            );
          }
        }
      },

      /**
       * Closes the navigation when a link inside is clicked.
       */
      _closeOnNavClick: function() {
        if (opts.closeOnNavClick) {
          var links = nav.getElementsByTagName("a"),
            self = this;
          forEach(links, function(i, el) {
            addEvent(
              links[i],
              "click",
              function() {
                if (isMobile) {
                  self.toggle();
                }
              },
              false
            );
          });
        }
      },

      /**
       * Prevents the default functionality.
       *
       * @param  {event} event
       */
      _preventDefault: function(e) {
        if (e.preventDefault) {
          if (e.stopImmediatePropagation) {
            e.stopImmediatePropagation();
          }
          e.preventDefault();
          e.stopPropagation();
          return false;

          // This is strictly for old IE
        } else {
          e.returnValue = false;
        }
      },

      /**
       * On touch start we get the location of the touch.
       *
       * @param  {event} event
       */
      _onTouchStart: function(e) {
        if (!Event.prototype.stopImmediatePropagation) {
          this._preventDefault(e);
        }
        this.startX = e.touches[0].clientX;
        this.startY = e.touches[0].clientY;
        this.touchHasMoved = false;

        /**
         * Remove mouseup event completely here to avoid
         * double triggering the event.
         */
        removeEvent(navToggle, "mouseup", this, false);
      },

      /**
       * Check if the user is scrolling instead of tapping.
       *
       * @param  {event} event
       */
      _onTouchMove: function(e) {
        if (
          Math.abs(e.touches[0].clientX - this.startX) > 10 ||
          Math.abs(e.touches[0].clientY - this.startY) > 10
        ) {
          this.touchHasMoved = true;
        }
      },

      /**
       * On touch end toggle the navigation.
       *
       * @param  {event} event
       */
      _onTouchEnd: function(e) {
        this._preventDefault(e);
        if (!isMobile) {
          return;
        }

        // If the user isn't scrolling
        if (!this.touchHasMoved) {
          // If the event type is touch
          if (e.type === "touchend") {
            this.toggle();
            return;

            // Event type was click, not touch
          } else {
            var evt = e || window.event;

            // If it isn't a right click, do toggling
            if (!(evt.which === 3 || evt.button === 2)) {
              this.toggle();
            }
          }
        }
      },

      /**
       * For keyboard accessibility, toggle the navigation on Enter
       * keypress too.
       *
       * @param  {event} event
       */
      _onKeyUp: function(e) {
        var evt = e || window.event;
        if (evt.keyCode === 13) {
          this.toggle();
        }
      },

      /**
       * Adds the needed CSS transitions if animations are enabled
       */
      _transitions: function() {
        if (opts.animate) {
          var objStyle = nav.style,
            transition = "max-height " + opts.transition + "ms";

          objStyle.WebkitTransition = objStyle.MozTransition = objStyle.OTransition = objStyle.transition = transition;
        }
      },

      /**
       * Calculates the height of the navigation and then creates
       * styles which are later added to the page <head>
       */
      _calcHeight: function() {
        var savedHeight = 0;
        for (var i = 0; i < nav.inner.length; i++) {
          savedHeight += nav.inner[i].offsetHeight;
        }

        var innerStyles =
          "." +
          opts.jsClass +
          " ." +
          opts.navClass +
          "-" +
          this.index +
          ".opened{max-height:" +
          savedHeight +
          "px !important} ." +
          opts.jsClass +
          " ." +
          opts.navClass +
          "-" +
          this.index +
          ".opened.dropdown-active {max-height:9999px !important}";

        if (styleElement.styleSheet) {
          styleElement.styleSheet.cssText = innerStyles;
        } else {
          styleElement.innerHTML = innerStyles;
        }

        innerStyles = "";
      }
    };

    /**
     * Return new Responsive Nav
     */
    return new ResponsiveNav(el, options);
  };

  if (typeof module !== "undefined" && module.exports) {
    module.exports = responsiveNav;
  } else {
    window.responsiveNav = responsiveNav;
  }
})(document, window, 0);


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(window, factory) {
  var globalInstall = function() {
    factory(window.lazySizes);
    window.removeEventListener("lazyunveilread", globalInstall, true);
  };

  factory = factory.bind(null, window, window.document);

  if (typeof module == "object" && module.exports) {
    factory(__webpack_require__(14));
  } else if (window.lazySizes) {
    globalInstall();
  } else {
    window.addEventListener("lazyunveilread", globalInstall, true);
  }
})(window, function(window, document, lazySizes) {
  "use strict";

  if (!window.addEventListener) {
    return;
  }

  var forEach = Array.prototype.forEach;

  var imageRatio, extend$, $;

  var regPicture = /^picture$/i;
  var aspectRatioAttr = "data-aspectratio";
  var aspectRatioSel = "img[" + aspectRatioAttr + "]";

  var matchesMedia = function(media) {
    if (window.matchMedia) {
      matchesMedia = function(media) {
        return !media || (matchMedia(media) || {}).matches;
      };
    } else if (window.Modernizr && Modernizr.mq) {
      return !media || Modernizr.mq(media);
    } else {
      return !media;
    }
    return matchesMedia(media);
  };

  var addClass = lazySizes.aC;
  var removeClass = lazySizes.rC;
  var lazySizesConfig = lazySizes.cfg;

  function AspectRatio() {
    this.ratioElems = document.getElementsByClassName("lazyaspectratio");
    this._setupEvents();
    this.processImages();
  }

  AspectRatio.prototype = {
    _setupEvents: function() {
      var module = this;

      var addRemoveAspectRatio = function(elem) {
        if (elem.naturalWidth < 36) {
          module.addAspectRatio(elem, true);
        } else {
          module.removeAspectRatio(elem, true);
        }
      };
      var onload = function() {
        module.processImages();
      };

      document.addEventListener(
        "load",
        function(e) {
          if (e.target.getAttribute && e.target.getAttribute(aspectRatioAttr)) {
            addRemoveAspectRatio(e.target);
          }
        },
        true
      );

      addEventListener(
        "resize",
        (function() {
          var timer;
          var resize = function() {
            forEach.call(module.ratioElems, addRemoveAspectRatio);
          };

          return function() {
            clearTimeout(timer);
            timer = setTimeout(resize, 99);
          };
        })()
      );

      document.addEventListener("DOMContentLoaded", onload);

      addEventListener("load", onload);
    },
    processImages: function(context) {
      var elements, i;

      if (!context) {
        context = document;
      }

      if ("length" in context && !context.nodeName) {
        elements = context;
      } else {
        elements = context.querySelectorAll(aspectRatioSel);
      }

      for (i = 0; i < elements.length; i++) {
        if (elements[i].naturalWidth > 36) {
          this.removeAspectRatio(elements[i]);
          continue;
        }
        this.addAspectRatio(elements[i]);
      }
    },
    getSelectedRatio: function(img) {
      var i, len, sources, customMedia, ratio;
      var parent = img.parentNode;
      if (parent && regPicture.test(parent.nodeName || "")) {
        sources = parent.getElementsByTagName("source");

        for (i = 0, len = sources.length; i < len; i++) {
          customMedia =
            sources[i].getAttribute("data-media") ||
            sources[i].getAttribute("media");

          if (lazySizesConfig.customMedia[customMedia]) {
            customMedia = lazySizesConfig.customMedia[customMedia];
          }

          if (matchesMedia(customMedia)) {
            ratio = sources[i].getAttribute(aspectRatioAttr);
            break;
          }
        }
      }

      return ratio || img.getAttribute(aspectRatioAttr) || "";
    },
    parseRatio: (function() {
      var regRatio = /^\s*([+\d\.]+)(\s*[\/x]\s*([+\d\.]+))?\s*$/;
      var ratioCache = {};
      return function(ratio) {
        if (!ratioCache[ratio] && ratio.match(regRatio)) {
          if (RegExp.$3) {
            ratioCache[ratio] = RegExp.$1 / RegExp.$3;
          } else {
            ratioCache[ratio] = RegExp.$1 * 1;
          }
        }

        return ratioCache[ratio];
      };
    })(),
    addAspectRatio: function(img, notNew) {
      var ratio;
      var width = img.offsetWidth;
      var height = img.offsetHeight;

      if (!notNew) {
        addClass(img, "lazyaspectratio");
      }

      if (width < 36 && height <= 0) {
        if (width || (height && window.console)) {
          console.log(
            "Define width or height of image, so we can calculate the other dimension"
          );
        }
        return;
      }

      ratio = this.getSelectedRatio(img);
      ratio = this.parseRatio(ratio);

      if (ratio) {
        if (width) {
          img.style.height = width / ratio + "px";
        } else {
          img.style.width = height * ratio + "px";
        }
      }
    },
    removeAspectRatio: function(img) {
      removeClass(img, "lazyaspectratio");
      img.style.height = "";
      img.style.width = "";
      img.removeAttribute(aspectRatioAttr);
    }
  };

  extend$ = function() {
    $ = window.jQuery || window.Zepto || window.shoestring || window.$;
    if ($ && $.fn && !$.fn.imageRatio && $.fn.filter && $.fn.add && $.fn.find) {
      $.fn.imageRatio = function() {
        imageRatio.processImages(
          this.find(aspectRatioSel).add(this.filter(aspectRatioSel))
        );
        return this;
      };
    } else {
      $ = false;
    }
  };

  extend$();
  setTimeout(extend$);

  imageRatio = new AspectRatio();

  window.imageRatio = imageRatio;

  if (typeof module == "object" && module.exports) {
    module.exports = imageRatio;
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (imageRatio),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
});


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

(function(window, factory) {
  var globalInstall = function() {
    factory(window.lazySizes);
    window.removeEventListener("lazyunveilread", globalInstall, true);
  };

  factory = factory.bind(null, window, window.document);

  if (typeof module == "object" && module.exports) {
    factory(__webpack_require__(14));
  } else if (window.lazySizes) {
    globalInstall();
  } else {
    window.addEventListener("lazyunveilread", globalInstall, true);
  }
})(window, function(window, document, lazySizes) {
  "use strict";
  if (!window.addEventListener) {
    return;
  }

  var regWhite = /\s+/g;
  var regSplitSet = /\s*\|\s+|\s+\|\s*/g;
  var regSource = /^(.+?)(?:\s+\[\s*(.+?)\s*\])?$/;
  var regBgUrlEscape = /\(|\)|'/;
  var allowedBackgroundSize = { contain: 1, cover: 1 };
  var proxyWidth = function(elem) {
    var width = lazySizes.gW(elem, elem.parentNode);

    if (!elem._lazysizesWidth || width > elem._lazysizesWidth) {
      elem._lazysizesWidth = width;
    }
    return elem._lazysizesWidth;
  };
  var getBgSize = function(elem) {
    var bgSize;

    bgSize = (
      getComputedStyle(elem) || { getPropertyValue: function() {} }
    ).getPropertyValue("background-size");

    if (
      !allowedBackgroundSize[bgSize] &&
      allowedBackgroundSize[elem.style.backgroundSize]
    ) {
      bgSize = elem.style.backgroundSize;
    }

    return bgSize;
  };
  var createPicture = function(sets, elem, img) {
    var picture = document.createElement("picture");
    var sizes = elem.getAttribute(lazySizesConfig.sizesAttr);
    var ratio = elem.getAttribute("data-ratio");
    var optimumx = elem.getAttribute("data-optimumx");

    if (elem._lazybgset && elem._lazybgset.parentNode == elem) {
      elem.removeChild(elem._lazybgset);
    }

    Object.defineProperty(img, "_lazybgset", {
      value: elem,
      writable: true
    });
    Object.defineProperty(elem, "_lazybgset", {
      value: picture,
      writable: true
    });

    sets = sets.replace(regWhite, " ").split(regSplitSet);

    picture.style.display = "none";
    img.className = lazySizesConfig.lazyClass;

    if (sets.length == 1 && !sizes) {
      sizes = "auto";
    }

    sets.forEach(function(set) {
      var source = document.createElement("source");

      if (sizes && sizes != "auto") {
        source.setAttribute("sizes", sizes);
      }

      if (set.match(regSource)) {
        source.setAttribute(lazySizesConfig.srcsetAttr, RegExp.$1);
        if (RegExp.$2) {
          source.setAttribute(
            "media",
            lazySizesConfig.customMedia[RegExp.$2] || RegExp.$2
          );
        }
      }
      picture.appendChild(source);
    });

    if (sizes) {
      img.setAttribute(lazySizesConfig.sizesAttr, sizes);
      elem.removeAttribute(lazySizesConfig.sizesAttr);
      elem.removeAttribute("sizes");
    }
    if (optimumx) {
      img.setAttribute("data-optimumx", optimumx);
    }
    if (ratio) {
      img.setAttribute("data-ratio", ratio);
    }

    picture.appendChild(img);

    elem.appendChild(picture);
  };

  var proxyLoad = function(e) {
    if (!e.target._lazybgset) {
      return;
    }

    var image = e.target;
    var elem = image._lazybgset;
    var bg = image.currentSrc || image.src;

    if (bg) {
      elem.style.backgroundImage =
        "url(" + (regBgUrlEscape.test(bg) ? JSON.stringify(bg) : bg) + ")";
    }

    if (image._lazybgsetLoading) {
      lazySizes.fire(elem, "_lazyloaded", {}, false, true);
      delete image._lazybgsetLoading;
    }
  };

  addEventListener("lazybeforeunveil", function(e) {
    var set, image, elem;

    if (e.defaultPrevented || !(set = e.target.getAttribute("data-bgset"))) {
      return;
    }

    elem = e.target;
    image = document.createElement("img");

    image.alt = "";

    image._lazybgsetLoading = true;
    e.detail.firesLoad = true;

    createPicture(set, elem, image);

    setTimeout(function() {
      lazySizes.loader.unveil(image);

      lazySizes.rAF(function() {
        lazySizes.fire(image, "_lazyloaded", {}, true, true);
        if (image.complete) {
          proxyLoad({ target: image });
        }
      });
    });
  });

  document.addEventListener("load", proxyLoad, true);

  window.addEventListener(
    "lazybeforesizes",
    function(e) {
      if (e.detail.instance != lazySizes) {
        return;
      }
      if (e.target._lazybgset && e.detail.dataAttr) {
        var elem = e.target._lazybgset;
        var bgSize = getBgSize(elem);

        if (allowedBackgroundSize[bgSize]) {
          e.target._lazysizesParentFit = bgSize;

          lazySizes.rAF(function() {
            e.target.setAttribute("data-parent-fit", bgSize);
            if (e.target._lazysizesParentFit) {
              delete e.target._lazysizesParentFit;
            }
          });
        }
      }
    },
    true
  );

  document.documentElement.addEventListener("lazybeforesizes", function(e) {
    if (
      e.defaultPrevented ||
      !e.target._lazybgset ||
      e.detail.instance != lazySizes
    ) {
      return;
    }
    e.detail.width = proxyWidth(e.target._lazybgset);
  });
});


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

/*
This plugin extends lazySizes to lazyLoad:
background images, videos/posters and scripts

Background-Image:
For background images, use data-bg attribute:
<div class="lazyload" data-bg="bg-img.jpg"></div>

 Video:
 For video/audio use data-poster and preload="none":
 <video class="lazyload" data-poster="poster.jpg" preload="none">
 <!-- sources -->
 </video>

 Scripts:
 For scripts use data-script:
 <div class="lazyload" data-script="module-name.js"></div>


 Script modules using require:
 For modules using require use data-require:
 <div class="lazyload" data-require="module-name"></div>
*/

(function(window, factory) {
  var globalInstall = function() {
    factory(window.lazySizes);
    window.removeEventListener("lazyunveilread", globalInstall, true);
  };

  factory = factory.bind(null, window, window.document);

  if (typeof module == "object" && module.exports) {
    factory(__webpack_require__(14));
  } else if (window.lazySizes) {
    globalInstall();
  } else {
    window.addEventListener("lazyunveilread", globalInstall, true);
  }
})(window, function(window, document, lazySizes) {
  /*jshint eqnull:true */
  "use strict";
  var bgLoad, regBgUrlEscape;
  var uniqueUrls = {};

  if (document.addEventListener) {
    regBgUrlEscape = /\(|\)|\s|'/;

    bgLoad = function(url, cb) {
      var img = document.createElement("img");
      img.onload = function() {
        img.onload = null;
        img.onerror = null;
        img = null;
        cb();
      };
      img.onerror = img.onload;

      img.src = url;

      if (img && img.complete && img.onload) {
        img.onload();
      }
    };

    addEventListener(
      "lazybeforeunveil",
      function(e) {
        if (e.detail.instance != lazySizes) {
          return;
        }

        var tmp, load, bg, poster;
        if (!e.defaultPrevented) {
          if (e.target.preload == "none") {
            e.target.preload = "auto";
          }

          tmp = e.target.getAttribute("data-link");
          if (tmp) {
            addStyleScript(tmp, true);
          }

          // handle data-script
          tmp = e.target.getAttribute("data-script");
          if (tmp) {
            addStyleScript(tmp);
          }

          // handle data-require
          tmp = e.target.getAttribute("data-require");
          if (tmp) {
            if (lazySizes.cfg.requireJs) {
              lazySizes.cfg.requireJs([tmp]);
            } else {
              addStyleScript(tmp);
            }
          }

          // handle data-bg
          bg = e.target.getAttribute("data-bg");
          if (bg) {
            e.detail.firesLoad = true;
            load = function() {
              e.target.style.backgroundImage =
                "url(" +
                (regBgUrlEscape.test(bg) ? JSON.stringify(bg) : bg) +
                ")";
              e.detail.firesLoad = false;
              lazySizes.fire(e.target, "_lazyloaded", {}, true, true);
            };

            bgLoad(bg, load);
          }

          // handle data-poster
          poster = e.target.getAttribute("data-poster");
          if (poster) {
            e.detail.firesLoad = true;
            load = function() {
              e.target.poster = poster;
              e.detail.firesLoad = false;
              lazySizes.fire(e.target, "_lazyloaded", {}, true, true);
            };

            bgLoad(poster, load);
          }
        }
      },
      false
    );
  }

  function addStyleScript(src, style) {
    if (uniqueUrls[src]) {
      return;
    }
    var elem = document.createElement(style ? "link" : "script");
    var insertElem = document.getElementsByTagName("script")[0];

    if (style) {
      elem.rel = "stylesheet";
      elem.href = src;
    } else {
      elem.src = src;
    }
    uniqueUrls[src] = true;
    uniqueUrls[elem.src || elem.href] = true;
    insertElem.parentNode.insertBefore(elem, insertElem);
  }
});


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * isMobile.js v0.4.1
 *
 * A simple library to detect Apple phones and tablets,
 * Android phones and tablets, other mobile devices (like blackberry, mini-opera and windows phone),
 * and any kind of seven inch device, via user agent sniffing.
 *
 * @author: Kai Mallea (kmallea@gmail.com)
 *
 * @license: http://creativecommons.org/publicdomain/zero/1.0/
 */
(function(global) {
  var apple_phone = /iPhone/i,
    apple_ipod = /iPod/i,
    apple_tablet = /iPad/i,
    android_phone = /(?=.*\bAndroid\b)(?=.*\bMobile\b)/i, // Match 'Android' AND 'Mobile'
    android_tablet = /Android/i,
    amazon_phone = /(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)/i,
    amazon_tablet = /(?=.*\bAndroid\b)(?=.*\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b)/i,
    windows_phone = /Windows Phone/i,
    windows_tablet = /(?=.*\bWindows\b)(?=.*\bARM\b)/i, // Match 'Windows' AND 'ARM'
    other_blackberry = /BlackBerry/i,
    other_blackberry_10 = /BB10/i,
    other_opera = /Opera Mini/i,
    other_chrome = /(CriOS|Chrome)(?=.*\bMobile\b)/i,
    other_firefox = /(?=.*\bFirefox\b)(?=.*\bMobile\b)/i, // Match 'Firefox' AND 'Mobile'
    seven_inch = new RegExp(
      "(?:" + // Non-capturing group
      "Nexus 7" + // Nexus 7
      "|" + // OR
      "BNTV250" + // B&N Nook Tablet 7 inch
      "|" + // OR
      "Kindle Fire" + // Kindle Fire
      "|" + // OR
      "Silk" + // Kindle Fire, Silk Accelerated
      "|" + // OR
      "GT-P1000" + // Galaxy Tab 7 inch
        ")", // End non-capturing group

      "i"
    ); // Case-insensitive matching

  var match = function(regex, userAgent) {
    return regex.test(userAgent);
  };

  var IsMobileClass = function(userAgent) {
    var ua = userAgent || navigator.userAgent;

    // Facebook mobile app's integrated browser adds a bunch of strings that
    // match everything. Strip it out if it exists.
    var tmp = ua.split("[FBAN");
    if (typeof tmp[1] !== "undefined") {
      ua = tmp[0];
    }

    // Twitter mobile app's integrated browser on iPad adds a "Twitter for
    // iPhone" string. Same probable happens on other tablet platforms.
    // This will confuse detection so strip it out if it exists.
    tmp = ua.split("Twitter");
    if (typeof tmp[1] !== "undefined") {
      ua = tmp[0];
    }

    this.apple = {
      phone: match(apple_phone, ua),
      ipod: match(apple_ipod, ua),
      tablet: !match(apple_phone, ua) && match(apple_tablet, ua),
      device:
        match(apple_phone, ua) ||
        match(apple_ipod, ua) ||
        match(apple_tablet, ua)
    };
    this.amazon = {
      phone: match(amazon_phone, ua),
      tablet: !match(amazon_phone, ua) && match(amazon_tablet, ua),
      device: match(amazon_phone, ua) || match(amazon_tablet, ua)
    };
    this.android = {
      phone: match(amazon_phone, ua) || match(android_phone, ua),
      tablet:
        !match(amazon_phone, ua) &&
        !match(android_phone, ua) &&
        (match(amazon_tablet, ua) || match(android_tablet, ua)),
      device:
        match(amazon_phone, ua) ||
        match(amazon_tablet, ua) ||
        match(android_phone, ua) ||
        match(android_tablet, ua)
    };
    this.windows = {
      phone: match(windows_phone, ua),
      tablet: match(windows_tablet, ua),
      device: match(windows_phone, ua) || match(windows_tablet, ua)
    };
    this.other = {
      blackberry: match(other_blackberry, ua),
      blackberry10: match(other_blackberry_10, ua),
      opera: match(other_opera, ua),
      firefox: match(other_firefox, ua),
      chrome: match(other_chrome, ua),
      device:
        match(other_blackberry, ua) ||
        match(other_blackberry_10, ua) ||
        match(other_opera, ua) ||
        match(other_firefox, ua) ||
        match(other_chrome, ua)
    };
    this.seven_inch = match(seven_inch, ua);
    this.any =
      this.apple.device ||
      this.android.device ||
      this.windows.device ||
      this.other.device ||
      this.seven_inch;

    // excludes 'other' devices and ipods, targeting touchscreen phones
    this.phone = this.apple.phone || this.android.phone || this.windows.phone;

    // excludes 7 inch devices, classifying as phone or tablet is left to the user
    this.tablet =
      this.apple.tablet || this.android.tablet || this.windows.tablet;

    if (typeof window === "undefined") {
      return this;
    }
  };

  var instantiate = function() {
    var IM = new IsMobileClass();
    IM.Class = IsMobileClass;
    return IM;
  };

  if (
    typeof module !== "undefined" &&
    module.exports &&
    typeof window === "undefined"
  ) {
    //node
    module.exports = IsMobileClass;
  } else if (
    typeof module !== "undefined" &&
    module.exports &&
    typeof window !== "undefined"
  ) {
    //browserify
    module.exports = instantiate();
  } else if (true) {
    //AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (global.isMobile = instantiate()),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    global.isMobile = instantiate();
  }
})(this);


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (root, name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (true) __webpack_require__(69)(name, definition)
  else root[name] = definition()
}(this, 'bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)os/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , samsungBrowser = /SamsungBrowser/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getSecondMatch(/edg([ea]|ios)\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result

    if (/opera/i.test(ua)) {
      //  an old Opera
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      }
    } else if (/opr\/|opios/i.test(ua)) {
      // a new Opera
      result = {
        name: 'Opera'
        , opera: t
        , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/SamsungBrowser/i.test(ua)) {
      result = {
        name: 'Samsung Internet for Android'
        , samsungBrowser: t
        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      }
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      }
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , osname: 'Windows Phone'
      , windowsphone: t
      }
      if (edgeVersion) {
        result.msedge = t
        result.version = edgeVersion
      }
      else {
        result.msie = t
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , osname: 'Chrome OS'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    } else if (/edg([ea]|ios)/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      }
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , osname: 'Sailfish OS'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
        result.osname = 'Firefox OS'
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , osname: 'BlackBerry OS'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , osname: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , osname: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , osname: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      }
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      }
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      }
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      }
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink"
        result.blink = t
      } else {
        result.name = result.name || "Webkit"
        result.webkit = t
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.windowsphone && (android || result.silk)) {
      result.android = t
      result.osname = 'Android'
    } else if (!result.windowsphone && iosdevice) {
      result[iosdevice] = t
      result.ios = t
      result.osname = 'iOS'
    } else if (mac) {
      result.mac = t
      result.osname = 'macOS'
    } else if (xbox) {
      result.xbox = t
      result.osname = 'Xbox'
    } else if (windows) {
      result.windows = t
      result.osname = 'Windows'
    } else if (linux) {
      result.linux = t
      result.osname = 'Linux'
    }

    function getWindowsVersion (s) {
      switch (s) {
        case 'NT': return 'NT'
        case 'XP': return 'XP'
        case 'NT 5.0': return '2000'
        case 'NT 5.1': return 'XP'
        case 'NT 5.2': return '2003'
        case 'NT 6.0': return 'Vista'
        case 'NT 6.1': return '7'
        case 'NT 6.2': return '8'
        case 'NT 6.3': return '8.1'
        case 'NT 10.0': return '10'
        default: return undefined
      }
    }

    // OS version extraction
    var osVersion = '';
    if (result.windows) {
      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i))
    } else if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (result.mac) {
      osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = !result.windows && osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.samsungBrowser && result.version >= 4) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        || (result.chromium && result.version >= 20)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        || (result.chromium && result.version < 20)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  function getVersionPrecision(version) {
    return version.split(".").length;
  }

  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  function map(arr, iterator) {
    var result = [], i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i++) {
      result.push(iterator(arr[i]));
    }
    return result;
  }

  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
   *
   * @param  {Array<String>} versions versions to compare
   * @return {Number} comparison result
   */
  function compareVersions(versions) {
    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
    var chunks = map(versions, function (version) {
      var delta = precision - getVersionPrecision(version);

      // 2) "9" -> "9.0" (for precision = 2)
      version = version + new Array(delta + 1).join(".0");

      // 3) "9.0" -> ["000000000"", "000000009"]
      return map(version.split("."), function (chunk) {
        return new Array(20 - chunk.length).join("0") + chunk;
      }).reverse();
    });

    // iterate in reverse order by reversed chunks array
    while (--precision >= 0) {
      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      else if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === 0) {
          // all version chunks are same
          return 0;
        }
      }
      else {
        return -1;
      }
    }
  }

  /**
   * Check if browser is unsupported
   *
   * @example
   *   bowser.isUnsupportedBrowser({
   *     msie: "10",
   *     firefox: "23",
   *     chrome: "29",
   *     safari: "5.1",
   *     opera: "16",
   *     phantom: "534"
   *   });
   *
   * @param  {Object}  minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function isUnsupportedBrowser(minVersions, strictMode, ua) {
    var _bowser = bowser;

    // make strictMode param optional with ua param usage
    if (typeof strictMode === 'string') {
      ua = strictMode;
      strictMode = void(0);
    }

    if (strictMode === void(0)) {
      strictMode = false;
    }
    if (ua) {
      _bowser = detect(ua);
    }

    var version = "" + _bowser.version;
    for (var browser in minVersions) {
      if (minVersions.hasOwnProperty(browser)) {
        if (_bowser[browser]) {
          if (typeof minVersions[browser] !== 'string') {
            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
          }

          // browser version and min supported version.
          return compareVersions([version, minVersions[browser]]) < 0;
        }
      }
    }

    return strictMode; // not found
  }

  /**
   * Check if browser is supported
   *
   * @param  {Object} minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function check(minVersions, strictMode, ua) {
    return !isUnsupportedBrowser(minVersions, strictMode, ua);
  }

  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
  bowser.compareVersions = compareVersions;
  bowser.check = check;

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  /*
   * Set our detect public method to the main bowser object
   * This is needed to implement bowser in server side
   */
  bowser.detect = detect;
  return bowser
});


/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = function() {
  throw new Error("define cannot be used indirect");
};


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "always", function() { return always; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "complement", function() { return complement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return F; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "not", function() { return not; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return T; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trim", function() { return trim; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addIndex", function() { return addIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjust", function() { return adjust; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "all", function() { return all; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allPass", function() { return allPass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "anyPass", function() { return anyPass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "any", function() { return any; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "append", function() { return append; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "both", function() { return both; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return concat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return contains; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "curry", function() { return curry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dec", function() { return dec; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultTo", function() { return defaultTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drop", function() { return drop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dropLast", function() { return dropLast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "either", function() { return either; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "endsWith", function() { return endsWith; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inc", function() { return inc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filter", function() { return filter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "find", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flip", function() { return flip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "has", function() { return has; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "head", function() { return head; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ifElse", function() { return ifElse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "is", function() { return is; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNil", function() { return isNil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "indexOf", function() { return indexOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "join", function() { return join; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lastIndexOf", function() { return lastIndexOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "last", function() { return last; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "match", function() { return match; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modulo", function() { return modulo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "none", function() { return none; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "omit", function() { return omit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "partialCurry", function() { return partialCurry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "path", function() { return path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pathOr", function() { return pathOr$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pick", function() { return pick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pickAll", function() { return pickAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return pipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pluck", function() { return pluck; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prepend", function() { return prepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prop", function() { return prop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propEq", function() { return propEq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reduce", function() { return reduce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reject", function() { return reject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return repeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replace", function() { return replace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sort", function() { return sort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortBy", function() { return sortBy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return split; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitEvery", function() { return splitEvery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startsWith", function() { return startsWith; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tap", function() { return tap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tail", function() { return tail; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "take", function() { return take; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "takeLast", function() { return takeLast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "test", function() { return test; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "times", function() { return times; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toLower", function() { return toLower; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toUpper", function() { return toUpper; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return toString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "type", function() { return type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uniq", function() { return uniq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uniqWith", function() { return uniqWith; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "update", function() { return update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "values", function() { return values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "without", function() { return without; });
function add(x, y) {
  if (y === undefined) {
    return yHolder => add(x, yHolder);
  }

  return x + y;
}

function addIndex(functor) {
  return function (fn, ...rest) {
    let cnt = 0;
    const newFn = (...args) => fn.apply(null, [...args, cnt++]);

    return functor.apply(null, [newFn, ...rest]);
  };
}

function adjust(fn, index, arr) {
  if (index === undefined) {
    return (indexHolder, arrHolder) => adjust(fn, indexHolder, arrHolder);
  } else if (arr === undefined) {
    return arrHolder => adjust(fn, index, arrHolder);
  }

  const clone = arr.concat();

  return clone.map((val, key) => {
    if (key === index) {
      return fn(arr[index]);
    }

    return val;
  });
}

function filterObject(fn, obj) {
  const willReturn = {};

  for (const prop in obj) {
    if (fn(obj[prop])) {
      willReturn[prop] = obj[prop];
    }
  }

  return willReturn;
}

function filter(fn, arr) {
  if (arr === undefined) {
    return arrHolder => filter(fn, arrHolder);
  }

  if (arr.length === undefined) {
    return filterObject(fn, arr);
  }
  let index = -1;
  let resIndex = 0;
  const len = arr.length;
  const willReturn = [];

  while (++index < len) {
    const value = arr[index];

    if (fn(value)) {
      willReturn[resIndex++] = value;
    }
  }

  return willReturn;
}

function all(condition, arr) {
  if (arr === undefined) {
    return arrHolder => all(condition, arrHolder);
  }

  return filter(condition, arr).length === arr.length;
}

function any(fn, arr) {
  if (arr === undefined) {
    return arrHolder => any(fn, arrHolder);
  }
  let counter = 0;

  while (counter < arr.length) {
    if (fn(arr[counter])) {
      return true;
    }
    counter++;
  }

  return false;
}

function allPass(conditions, x) {
  if (arguments.length === 1) {
    return xHolder => allPass(conditions, xHolder);
  }

  return !any(condition => !condition(x), conditions);
}

function anyPass(conditions, x) {
  if (arguments.length === 1) {
    return xHolder => anyPass(conditions, xHolder);
  }

  return any(condition => condition(x))(conditions);
}

function append(x, arr) {
  if (arr === undefined) {
    return arrHolder => append(x, arrHolder);
  }
  if (typeof arr === 'string') {
    return `${arr}${x}`;
  }
  const clone = arr.concat();

  clone.push(x);

  return clone;
}

function both(x, y) {
  if (y === undefined) {
    return yHolder => both(x, yHolder);
  }

  return input => x(input) && y(input);
}

//Taken from https://github.com/getify/Functional-Light-JS/blob/master/ch4.md
function compose(...fns) {
  return result => {
    const list = fns.slice();

    while (list.length > 0) {
      result = list.pop()(result);
    }

    return result;
  };
}

function concat(x, y) {
  if (y === undefined) {
    return yHolder => concat(x, yHolder);
  }

  return typeof x === 'string' ? `${x}${y}` : [...x, ...y];
}

function type(a) {
  const typeOf = typeof a;

  if (a === null) {
    return 'Null';
  } else if (a === undefined) {
    return 'Undefined';
  } else if (typeOf === 'boolean') {
    return 'Boolean';
  } else if (typeOf === 'number') {
    return 'Number';
  } else if (typeOf === 'string') {
    return 'String';
  } else if (Array.isArray(a)) {
    return 'Array';
  } else if (a instanceof RegExp) {
    return 'RegExp';
  }

  const asStr = a.toString();

  if (asStr.startsWith('async')) {
    return 'Async';
  } else if (asStr === '[object Promise]') {
    return 'Promise';
  } else if (asStr.includes('function') || asStr.includes('=>')) {
    return 'Function';
  }

  return 'Object';
}

function equals(a, b) {
  if (arguments.length === 1) {
    return bHolder => equals(a, bHolder);
  }

  if (a === b) {
    return true;
  }
  const aType = type(a);

  if (aType !== type(b)) {
    return false;
  }

  if (aType === 'Array') {
    const aClone = Array.from(a);
    const bClone = Array.from(b);

    return aClone.sort().toString() === bClone.sort().toString();
  }

  if (aType === 'Object') {
    const aKeys = Object.keys(a);

    if (aKeys.length === Object.keys(b).length) {
      if (aKeys.length === 0) {
        return true;
      }
      let flag = true;

      aKeys.forEach(val => {
        if (flag) {
          const aValType = type(a[val]);
          const bValType = type(b[val]);

          if (aValType === bValType) {
            if (aValType === 'Object') {
              if (Object.keys(a[val]).length === Object.keys(b[val]).length) {
                if (Object.keys(a[val]).length !== 0) {
                  if (!equals(a[val], b[val])) {
                    flag = false;
                  }
                }
              } else {
                flag = false;
              }
            } else if (!equals(a[val], b[val])) {
              flag = false;
            }
          } else {
            flag = false;
          }
        }
      });

      return flag;
    }
  }

  return false;
}

function contains(x, arr) {
  if (arr === undefined) {
    return arrHolder => contains(x, arrHolder);
  }
  let index = -1;
  let flag = false;

  while (++index < arr.length && !flag) {
    if (equals(arr[index], x)) {
      flag = true;
    }
  }

  return flag;
}

//taken from the last comment of https://gist.github.com/mkuklis/5294248

function curry(f, a = []) {
  return (...p) => (o => o.length >= f.length ? f(...o) : curry(f, o))([...a, ...p]);
}

var dec = (x => x - 1);

function defaultTo(defaultArgument, inputArgument) {
  if (arguments.length === 1) {
    return inputArgumentHolder => defaultTo(defaultArgument, inputArgumentHolder);
  }

  return inputArgument === undefined || inputArgument === null || Number.isNaN(inputArgument) === true ? defaultArgument : inputArgument;
}

function divide(x, y) {
  if (y === undefined) {
    return yHolder => divide(x, yHolder);
  }

  return x / y;
}

function drop(dropNumber, x) {
  if (x === undefined) {
    return xHolder => drop(dropNumber, xHolder);
  }

  return x.slice(dropNumber);
}

function dropLast(dropNumber, x) {
  if (x === undefined) {
    return xHolder => dropLast(dropNumber, xHolder);
  }

  return x.slice(0, -dropNumber);
}

function either(x, y) {
  if (y === undefined) {
    return yHolder => either(x, yHolder);
  }

  return input => x(input) || y(input);
}

function endsWith(x, y) {
  if (y === undefined) {
    return yHolder => endsWith(x, yHolder);
  }

  return y.endsWith(x);
}

var inc = (x => x + 1);

function find(fn, arr) {
  if (arr === undefined) {
    return arrHolder => find(fn, arrHolder);
  }

  return arr.find(fn);
}

function findIndex(fn, arr) {
  if (arr === undefined) {
    return arrHolder => findIndex(fn, arrHolder);
  }
  const len = arr.length;
  let index = -1;

  while (++index < len) {
    if (fn(arr[index])) {
      return index;
    }
  }

  return -1;
}

function flatten(arr, willReturn) {
  willReturn = willReturn === undefined ? [] : willReturn;

  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      flatten(arr[i], willReturn);
    } else {
      willReturn.push(arr[i]);
    }
  }

  return willReturn;
}

function flipExport(fn) {
  return (...input) => {
    if (input.length === 1) {
      return holder => fn(holder, input[0]);
    } else if (input.length === 2) {
      return fn(input[1], input[0]);
    }

    return undefined;
  };
}

function flip(fn, ...input) {
  return flipExport(fn);
}

function tap(fn, x) {
  if (x === undefined) {
    return xHolder => tap(fn, xHolder);
  }

  fn(x);

  return x;
}

function mapObject(fn, obj) {
  const willReturn = {};

  for (const prop in obj) {
    willReturn[prop] = fn(obj[prop]);
  }

  return willReturn;
}

function map(fn, arr) {
  if (arr === undefined) {
    return arrHolder => map(fn, arrHolder);
  }
  if (arr.length === undefined) {
    return mapObject(fn, arr);
  }
  let index = -1;
  const len = arr.length;
  const willReturn = Array(len);

  while (++index < len) {
    willReturn[index] = fn(arr[index]);
  }

  return willReturn;
}

function forEach(fn, arr) {
  if (arr === undefined) {
    return arrHolder => forEach(fn, arrHolder);
  }

  return map(tap(fn), arr);
}

function has(prop, obj) {
  if (obj === undefined) {
    return objHolder => has(prop, objHolder);
  }

  return obj[prop] !== undefined;
}

function head(a) {
  if (typeof a === 'string') {
    return a[0] || '';
  }

  return a[0];
}

function ifElse(condition, ifFn, elseFn) {
  if (ifFn === undefined) {
    return (ifFnHolder, elseFnHolder) => ifElse(condition, ifFnHolder, elseFnHolder);
  } else if (elseFn === undefined) {
    return elseFnHolder => ifElse(condition, ifFn, elseFnHolder);
  }

  return input => {
    const conditionResult = typeof condition === 'boolean' ? condition : condition(input);

    if (conditionResult === true) {
      return ifFn(input);
    }

    return elseFn(input);
  };
}

function is(xPrototype, x) {
  if (x === undefined) {
    return xHolder => is(xPrototype, xHolder);
  }

  return x instanceof xPrototype || x.constructor === xPrototype;
}

function isNil(x) {
  return x === undefined || x === null;
}

function includes(x, y) {
  if (y === undefined) {
    return yHolder => includes(x, yHolder);
  }

  return y.includes(x);
}

function indexOf(x, arr) {
  if (arr === undefined) {
    return arrHolder => indexOf(x, arrHolder);
  }
  let index = -1;
  const length = arr.length;

  while (++index < length) {
    if (arr[index] === x) {
      return index;
    }
  }

  return -1;
}

function baseSlice(array, start, end) {
  let index = -1;
  let length = array.length;

  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;

  const result = Array(length);

  while (++index < length) {
    result[index] = array[index + start];
  }

  return result;
}

function init(a) {
  if (typeof a === 'string') {
    return a.slice(0, -1);
  }

  return a.length ? baseSlice(a, 0, -1) : [];
}

function join(glue, arr) {
  if (arr === undefined) {
    return arrHolder => join(glue, arrHolder);
  }

  return arr.join(glue);
}

function lastIndexOf(x, arr) {
  if (arr === undefined) {
    return arrHolder => lastIndexOf(x, arrHolder);
  }
  let willReturn = -1;

  arr.map((value, key) => {
    if (equals(value, x)) {
      willReturn = key;
    }
  });

  return willReturn;
}

function last(a) {
  if (typeof a === 'string') {
    return a[a.length - 1] || '';
  }

  return a[a.length - 1];
}

function length(x) {
  return x.length;
}

function match(regex, x) {
  if (x === undefined) {
    return xHolder => match(regex, xHolder);
  }
  const willReturn = x.match(regex);

  return willReturn === null ? [] : willReturn;
}

function merge(obj, newProps) {
  if (newProps === undefined) {
    return newPropsHolder => merge(obj, newPropsHolder);
  }

  return Object.assign({}, obj, newProps);
}

function modulo(x, y) {
  if (y === undefined) {
    return yHolder => modulo(x, yHolder);
  }

  return x % y;
}

function multiply(x, y) {
  if (y === undefined) {
    return yHolder => multiply(x, yHolder);
  }

  return x * y;
}

function none(fn, arr) {
  if (arr === undefined) {
    return arrHolder => none(fn, arr);
  }

  return arr.filter(fn).length === 0;
}

function omit(keys, obj) {
  if (arguments.length === 1) {
    return objHolder => omit(keys, objHolder);
  }
  if (obj === null || obj === undefined) {
    return undefined;
  }

  const keysValue = typeof keys === 'string' ? keys = keys.split(',') : keys;

  const willReturn = {};

  for (const key in obj) {
    if (!keysValue.includes(key)) {
      willReturn[key] = obj[key];
    }
  }

  return willReturn;
}

function partialCurry(fn, inputArguments = {}) {
  return inputArgumentsHolder => {
    if (type(fn) === 'Async' || type(fn) === 'Promise') {
      return new Promise((resolve, reject) => {
        fn(merge(inputArgumentsHolder, inputArguments)).then(resolve).catch(reject);
      });
    }

    return fn(merge(inputArgumentsHolder, inputArguments));
  };
}

function path(pathArr, obj) {
  if (arguments.length === 1) {
    return objHolder => path(pathArr, objHolder);
  }
  if (obj === null || obj === undefined) {
    return undefined;
  }
  let willReturn = obj;
  let counter = 0;

  const pathArrValue = typeof pathArr === 'string' ? pathArr = pathArr.split('.') : pathArr;

  while (counter < pathArrValue.length) {
    if (willReturn === null || willReturn === undefined) {
      return undefined;
    }
    willReturn = willReturn[pathArrValue[counter]];
    counter++;
  }

  return willReturn;
}

function pathOr(defaultValue, inputPath, inputObject) {
  return defaultTo(defaultValue, path(inputPath, inputObject));
}

var pathOr$1 = curry(pathOr);

function pick(keys, obj) {
  if (arguments.length === 1) {
    return objHolder => pick(keys, objHolder);
  }
  if (obj === null || obj === undefined) {
    return undefined;
  }
  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;

  const willReturn = {};
  let counter = 0;

  while (counter < keysValue.length) {
    if (keysValue[counter] in obj) {
      willReturn[keysValue[counter]] = obj[keysValue[counter]];
    }
    counter++;
  }

  return willReturn;
}

function pickAll(keys, obj) {
  if (arguments.length === 1) {
    return objHolder => pickAll(keys, objHolder);
  }
  if (obj === null || obj === undefined) {
    return undefined;
  }
  const keysValue = typeof keys === 'string' ? keys.split(',') : keys;

  const willReturn = {};
  let counter = 0;

  while (counter < keysValue.length) {
    if (keysValue[counter] in obj) {
      willReturn[keysValue[counter]] = obj[keysValue[counter]];
    } else {
      willReturn[keysValue[counter]] = undefined;
    }
    counter++;
  }

  return willReturn;
}

function pipe(...fns) {
  return compose(...fns.reverse());
}

function pluck(keyToPluck, arr) {
  if (arr === undefined) {
    return arrHolder => pluck(keyToPluck, arrHolder);
  }
  const willReturn = [];

  map(val => {
    if (!(val[keyToPluck] === undefined)) {
      willReturn.push(val[keyToPluck]);
    }
  }, arr);

  return willReturn;
}

function prepend(x, arr) {
  if (arr === undefined) {
    return arrHolder => prepend(x, arrHolder);
  }
  if (typeof arr === 'string') {
    return `${x}${arr}`;
  }
  const clone = arr.concat();

  clone.unshift(x);

  return clone;
}

function prop(key, obj) {
  if (obj === undefined) {
    return objHolder => prop(key, objHolder);
  }

  return obj[key];
}

function propEq(key, x, obj) {
  if (x === undefined) {
    return (xHolder, objHolder) => propEq(key, xHolder, objHolder);
  } else if (obj === undefined) {
    return objHolder => propEq(key, x, objHolder);
  }

  return obj[key] === x;
}

function range(start, end) {
  if (end === undefined) {
    return endHolder => range(start, endHolder);
  }
  const willReturn = [];

  for (let i = start; i < end; i++) {
    willReturn.push(i);
  }

  return willReturn;
}

function reduce(fn, initialValue, arr) {
  if (initialValue === undefined) {
    return (initialValueHolder, arrHolder) => reduce(fn, initialValueHolder, arrHolder);
  } else if (arr === undefined) {
    return arrHolder => reduce(fn, initialValue, arrHolder);
  }

  return arr.reduce(fn, initialValue);
}

function reject(fn, arr) {
  if (arr === undefined) {
    return arrHolder => reject(fn, arrHolder);
  }

  return filter(x => !fn(x), arr);
}

function repeat(x, num) {
  if (num === undefined) {
    return numHolder => repeat(x, numHolder);
  }
  const willReturn = Array(num);

  return willReturn.fill(x);
}

function replace(regex, replacer, str) {
  if (replacer === undefined) {
    return (replacerHolder, strHolder) => replace(regex, replacerHolder, strHolder);
  } else if (str === undefined) {
    return strHolder => replace(regex, replacer, strHolder);
  }

  return str.replace(regex, replacer);
}

function reverse(arr) {
  const clone = arr.concat();

  return clone.reverse();
}

function sort(fn, arr) {
  if (arr === undefined) {
    return arrHolder => sort(fn, arrHolder);
  }
  const arrClone = arr.concat();

  return arrClone.sort(fn);
}

function sortBy(fn, arr) {
  if (arr === undefined) {
    return arrHolder => sortBy(fn, arrHolder);
  }
  const arrClone = arr.concat();

  return arrClone.sort((a, b) => {
    const fnA = fn(a);
    const fnB = fn(b);

    return fnA < fnB ? -1 : fnA > fnB ? 1 : 0;
  });
}

function split(glue, str) {
  if (str === undefined) {
    return strHolder => split(glue, strHolder);
  }

  return str.split(glue);
}

function splitEvery(num, x) {
  if (x === undefined) {
    return xHolder => splitEvery(num, xHolder);
  }

  const numValue = num > 1 ? num : 1;

  const willReturn = [];
  let counter = 0;

  while (counter < x.length) {
    willReturn.push(x.slice(counter, counter += numValue));
  }

  return willReturn;
}

function startsWith(x, y) {
  if (y === undefined) {
    return yHolder => startsWith(x, yHolder);
  }

  return y.startsWith(x);
}

function subtract(x, y) {
  if (y === undefined) {
    return yHolder => subtract(x, yHolder);
  }

  return x - y;
}

function tail(arr) {
  return drop(1, arr);
}

function take(num, x) {
  if (x === undefined) {
    return xHolder => take(num, xHolder);
  }
  if (typeof x === 'string') {
    return x.slice(0, num);
  }

  return baseSlice(x, 0, num);
}

function takeLast(num, x) {
  if (x === undefined) {
    return xHolder => takeLast(num, xHolder);
  }
  const len = x.length;

  let numValue = num > len ? len : num;

  if (typeof x === 'string') {
    return x.slice(len - numValue);
  }
  numValue = len - numValue;

  return baseSlice(x, numValue, len);
}

function test(regex, str) {
  if (str === undefined) {
    return strHolder => test(regex, strHolder);
  }

  return str.search(regex) !== -1;
}

function times(fn, num) {
  if (num === undefined) {
    return numHolder => times(fn, numHolder);
  }

  return map(fn, range(0, num));
}

function toLower(x) {
  return x.toLowerCase();
}

function toUpper(x) {
  return x.toUpperCase();
}

function toString(x) {
  return x.toString();
}

function uniq(arr) {
  let index = -1;
  const willReturn = [];

  while (++index < arr.length) {
    const value = arr[index];

    if (!contains(value, willReturn)) {
      willReturn.push(value);
    }
  }

  return willReturn;
}

function uniqWith(fn, arr) {
  if (arguments.length === 1) {
    return arrHolder => uniqWith(fn, arrHolder);
  }

  let index = -1;
  const willReturn = [];

  while (++index < arr.length) {
    const value = arr[index];
    const flag = any(willReturnInstance => fn(value, willReturnInstance), willReturn);

    if (!flag) {
      willReturn.push(value);
    }
  }

  return willReturn;
}

function update(index, newValue, arr) {
  if (newValue === undefined) {
    return (newValueHolder, arrHolder) => update(index, newValueHolder, arrHolder);
  } else if (arr === undefined) {
    return arrHolder => update(index, newValue, arrHolder);
  }
  const arrClone = arr.concat();

  return arrClone.fill(newValue, index, index + 1);
}

function values(obj) {
  const willReturn = [];

  for (const key in obj) {
    willReturn.push(obj[key]);
  }

  return willReturn;
}

function without(itemsToOmit, collection) {
  return reduce((accum, item) => !contains(item, itemsToOmit) ? accum.concat(item) : accum, [], collection);
}

const always = x => () => x;
const complement = fn => input => !fn(input);
const F = () => false;
const identity = x => x;
const not = x => !x;
const T = () => true;
const trim = x => x.trim();


//# sourceMappingURL=rambda.esm.js.map


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 * jQuery Easing v1.4.1 - http://gsgd.co.uk/sandbox/jquery/easing/
 * Open source under the BSD License.
 * Copyright  2008 George McGinley Smith
 * All rights reserved.
 * https://raw.github.com/gdsmith/jquery-easing/master/LICENSE
*/

(function(factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_RESULT__ = (function($) {
      return factory($);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof module === "object" && typeof module.exports === "object") {
    exports = factory(require("jquery"));
  } else {
    factory(jQuery);
  }
})(function($) {
  // Preserve the original jQuery "swing" easing as "jswing"
  $.easing.jswing = $.easing.swing;

  var pow = Math.pow,
    sqrt = Math.sqrt,
    sin = Math.sin,
    cos = Math.cos,
    PI = Math.PI,
    c1 = 1.70158,
    c2 = c1 * 1.525,
    c3 = c1 + 1,
    c4 = 2 * PI / 3,
    c5 = 2 * PI / 4.5;

  // x is the fraction of animation progress, in the range 0..1
  function bounceOut(x) {
    var n1 = 7.5625,
      d1 = 2.75;
    if (x < 1 / d1) {
      return n1 * x * x;
    } else if (x < 2 / d1) {
      return n1 * (x -= 1.5 / d1) * x + 0.75;
    } else if (x < 2.5 / d1) {
      return n1 * (x -= 2.25 / d1) * x + 0.9375;
    } else {
      return n1 * (x -= 2.625 / d1) * x + 0.984375;
    }
  }

  $.extend($.easing, {
    def: "easeOutQuad",
    swing: function(x) {
      return $.easing[$.easing.def](x);
    },
    easeInQuad: function(x) {
      return x * x;
    },
    easeOutQuad: function(x) {
      return 1 - (1 - x) * (1 - x);
    },
    easeInOutQuad: function(x) {
      return x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;
    },
    easeInCubic: function(x) {
      return x * x * x;
    },
    easeOutCubic: function(x) {
      return 1 - pow(1 - x, 3);
    },
    easeInOutCubic: function(x) {
      return x < 0.5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2;
    },
    easeInQuart: function(x) {
      return x * x * x * x;
    },
    easeOutQuart: function(x) {
      return 1 - pow(1 - x, 4);
    },
    easeInOutQuart: function(x) {
      return x < 0.5 ? 8 * x * x * x * x : 1 - pow(-2 * x + 2, 4) / 2;
    },
    easeInQuint: function(x) {
      return x * x * x * x * x;
    },
    easeOutQuint: function(x) {
      return 1 - pow(1 - x, 5);
    },
    easeInOutQuint: function(x) {
      return x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;
    },
    easeInSine: function(x) {
      return 1 - cos(x * PI / 2);
    },
    easeOutSine: function(x) {
      return sin(x * PI / 2);
    },
    easeInOutSine: function(x) {
      return -(cos(PI * x) - 1) / 2;
    },
    easeInExpo: function(x) {
      return x === 0 ? 0 : pow(2, 10 * x - 10);
    },
    easeOutExpo: function(x) {
      return x === 1 ? 1 : 1 - pow(2, -10 * x);
    },
    easeInOutExpo: function(x) {
      return x === 0
        ? 0
        : x === 1
          ? 1
          : x < 0.5 ? pow(2, 20 * x - 10) / 2 : (2 - pow(2, -20 * x + 10)) / 2;
    },
    easeInCirc: function(x) {
      return 1 - sqrt(1 - pow(x, 2));
    },
    easeOutCirc: function(x) {
      return sqrt(1 - pow(x - 1, 2));
    },
    easeInOutCirc: function(x) {
      return x < 0.5
        ? (1 - sqrt(1 - pow(2 * x, 2))) / 2
        : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;
    },
    easeInElastic: function(x) {
      return x === 0
        ? 0
        : x === 1 ? 1 : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4);
    },
    easeOutElastic: function(x) {
      return x === 0
        ? 0
        : x === 1 ? 1 : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1;
    },
    easeInOutElastic: function(x) {
      return x === 0
        ? 0
        : x === 1
          ? 1
          : x < 0.5
            ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2
            : pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5) / 2 + 1;
    },
    easeInBack: function(x) {
      return c3 * x * x * x - c1 * x * x;
    },
    easeOutBack: function(x) {
      return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);
    },
    easeInOutBack: function(x) {
      return x < 0.5
        ? pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2
        : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;
    },
    easeInBounce: function(x) {
      return 1 - bounceOut(1 - x);
    },
    easeOutBounce: bounceOut,
    easeInOutBounce: function(x) {
      return x < 0.5
        ? (1 - bounceOut(1 - 2 * x)) / 2
        : (1 + bounceOut(2 * x - 1)) / 2;
    }
  });
});


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery Smooth Scroll - v2.2.0 - 2017-05-05
 * https://github.com/kswedberg/jquery-smooth-scroll
 * Copyright (c) 2017 Karl Swedberg
 * Licensed MIT
 */

(function(factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof module === "object" && module.exports) {
    // CommonJS
    factory(require("jquery"));
  } else {
    // Browser globals
    factory(jQuery);
  }
})(function($) {
  var version = "2.2.0";
  var optionOverrides = {};
  var defaults = {
    exclude: [],
    excludeWithin: [],
    offset: 0,

    // one of 'top' or 'left'
    direction: "top",

    // if set, bind click events through delegation
    //  supported since jQuery 1.4.2
    delegateSelector: null,

    // jQuery set of elements you wish to scroll (for $.smoothScroll).
    //  if null (default), $('html, body').firstScrollable() is used.
    scrollElement: null,

    // only use if you want to override default behavior
    scrollTarget: null,

    // automatically focus the target element after scrolling to it
    autoFocus: false,

    // fn(opts) function to be called before scrolling occurs.
    // `this` is the element(s) being scrolled
    beforeScroll: function() {},

    // fn(opts) function to be called after scrolling occurs.
    // `this` is the triggering element
    afterScroll: function() {},

    // easing name. jQuery comes with "swing" and "linear." For others, you'll need an easing plugin
    // from jQuery UI or elsewhere
    easing: "swing",

    // speed can be a number or 'auto'
    // if 'auto', the speed will be calculated based on the formula:
    // (current scroll position - target scroll position) / autoCoeffic
    speed: 400,

    // coefficient for "auto" speed
    autoCoefficient: 2,

    // $.fn.smoothScroll only: whether to prevent the default click action
    preventDefault: true
  };

  var getScrollable = function(opts) {
    var scrollable = [];
    var scrolled = false;
    var dir = opts.dir && opts.dir === "left" ? "scrollLeft" : "scrollTop";

    this.each(function() {
      var el = $(this);

      if (this === document || this === window) {
        return;
      }

      if (
        document.scrollingElement &&
        (this === document.documentElement || this === document.body)
      ) {
        scrollable.push(document.scrollingElement);

        return false;
      }

      if (el[dir]() > 0) {
        scrollable.push(this);
      } else {
        // if scroll(Top|Left) === 0, nudge the element 1px and see if it moves
        el[dir](1);
        scrolled = el[dir]() > 0;

        if (scrolled) {
          scrollable.push(this);
        }
        // then put it back, of course
        el[dir](0);
      }
    });

    if (!scrollable.length) {
      this.each(function() {
        // If no scrollable elements and <html> has scroll-behavior:smooth because
        // "When this property is specified on the root element, it applies to the viewport instead."
        // and "The scroll-behavior property of the  body element is *not* propagated to the viewport."
        //  https://drafts.csswg.org/cssom-view/#propdef-scroll-behavior
        if (
          this === document.documentElement &&
          $(this).css("scrollBehavior") === "smooth"
        ) {
          scrollable = [this];
        }

        // If still no scrollable elements, fall back to <body>,
        // if it's in the jQuery collection
        // (doing this because Safari sets scrollTop async,
        // so can't set it to 1 and immediately get the value.)
        if (!scrollable.length && this.nodeName === "BODY") {
          scrollable = [this];
        }
      });
    }

    // Use the first scrollable element if we're calling firstScrollable()
    if (opts.el === "first" && scrollable.length > 1) {
      scrollable = [scrollable[0]];
    }

    return scrollable;
  };

  var rRelative = /^([\-\+]=)(\d+)/;

  $.fn.extend({
    scrollable: function(dir) {
      var scrl = getScrollable.call(this, { dir: dir });

      return this.pushStack(scrl);
    },
    firstScrollable: function(dir) {
      var scrl = getScrollable.call(this, { el: "first", dir: dir });

      return this.pushStack(scrl);
    },

    smoothScroll: function(options, extra) {
      options = options || {};

      if (options === "options") {
        if (!extra) {
          return this.first().data("ssOpts");
        }

        return this.each(function() {
          var $this = $(this);
          var opts = $.extend($this.data("ssOpts") || {}, extra);

          $(this).data("ssOpts", opts);
        });
      }

      var opts = $.extend({}, $.fn.smoothScroll.defaults, options);

      var clickHandler = function(event) {
        var escapeSelector = function(str) {
          return str.replace(/(:|\.|\/)/g, "\\$1");
        };

        var link = this;
        var $link = $(this);
        var thisOpts = $.extend({}, opts, $link.data("ssOpts") || {});
        var exclude = opts.exclude;
        var excludeWithin = thisOpts.excludeWithin;
        var elCounter = 0;
        var ewlCounter = 0;
        var include = true;
        var clickOpts = {};
        var locationPath = $.smoothScroll.filterPath(location.pathname);
        var linkPath = $.smoothScroll.filterPath(link.pathname);
        var hostMatch = location.hostname === link.hostname || !link.hostname;
        var pathMatch = thisOpts.scrollTarget || linkPath === locationPath;
        var thisHash = escapeSelector(link.hash);

        if (thisHash && !$(thisHash).length) {
          include = false;
        }

        if (!thisOpts.scrollTarget && (!hostMatch || !pathMatch || !thisHash)) {
          include = false;
        } else {
          while (include && elCounter < exclude.length) {
            if ($link.is(escapeSelector(exclude[elCounter++]))) {
              include = false;
            }
          }

          while (include && ewlCounter < excludeWithin.length) {
            if ($link.closest(excludeWithin[ewlCounter++]).length) {
              include = false;
            }
          }
        }

        if (include) {
          if (thisOpts.preventDefault) {
            event.preventDefault();
          }

          $.extend(clickOpts, thisOpts, {
            scrollTarget: thisOpts.scrollTarget || thisHash,
            link: link
          });

          $.smoothScroll(clickOpts);
        }
      };

      if (options.delegateSelector !== null) {
        this.off("click.smoothscroll", options.delegateSelector).on(
          "click.smoothscroll",
          options.delegateSelector,
          clickHandler
        );
      } else {
        this.off("click.smoothscroll").on("click.smoothscroll", clickHandler);
      }

      return this;
    }
  });

  var getExplicitOffset = function(val) {
    var explicit = { relative: "" };
    var parts = typeof val === "string" && rRelative.exec(val);

    if (typeof val === "number") {
      explicit.px = val;
    } else if (parts) {
      explicit.relative = parts[1];
      explicit.px = parseFloat(parts[2]) || 0;
    }

    return explicit;
  };

  var onAfterScroll = function(opts) {
    var $tgt = $(opts.scrollTarget);

    if (opts.autoFocus && $tgt.length) {
      $tgt[0].focus();

      if (!$tgt.is(document.activeElement)) {
        $tgt.prop({ tabIndex: -1 });
        $tgt[0].focus();
      }
    }

    opts.afterScroll.call(opts.link, opts);
  };

  $.smoothScroll = function(options, px) {
    if (options === "options" && typeof px === "object") {
      return $.extend(optionOverrides, px);
    }
    var opts, $scroller, speed, delta;
    var explicitOffset = getExplicitOffset(options);
    var scrollTargetOffset = {};
    var scrollerOffset = 0;
    var offPos = "offset";
    var scrollDir = "scrollTop";
    var aniProps = {};
    var aniOpts = {};

    if (explicitOffset.px) {
      opts = $.extend(
        { link: null },
        $.fn.smoothScroll.defaults,
        optionOverrides
      );
    } else {
      opts = $.extend(
        { link: null },
        $.fn.smoothScroll.defaults,
        options || {},
        optionOverrides
      );

      if (opts.scrollElement) {
        offPos = "position";

        if (opts.scrollElement.css("position") === "static") {
          opts.scrollElement.css("position", "relative");
        }
      }

      if (px) {
        explicitOffset = getExplicitOffset(px);
      }
    }

    scrollDir = opts.direction === "left" ? "scrollLeft" : scrollDir;

    if (opts.scrollElement) {
      $scroller = opts.scrollElement;

      if (
        !explicitOffset.px &&
        !/^(?:HTML|BODY)$/.test($scroller[0].nodeName)
      ) {
        scrollerOffset = $scroller[scrollDir]();
      }
    } else {
      $scroller = $("html, body").firstScrollable(opts.direction);
    }

    // beforeScroll callback function must fire before calculating offset
    opts.beforeScroll.call($scroller, opts);

    scrollTargetOffset = explicitOffset.px
      ? explicitOffset
      : {
          relative: "",
          px:
            ($(opts.scrollTarget)[offPos]() &&
              $(opts.scrollTarget)[offPos]()[opts.direction]) ||
            0
        };

    aniProps[scrollDir] =
      scrollTargetOffset.relative +
      (scrollTargetOffset.px + scrollerOffset + opts.offset);

    speed = opts.speed;

    // automatically calculate the speed of the scroll based on distance / coefficient
    if (speed === "auto") {
      // $scroller[scrollDir]() is position before scroll, aniProps[scrollDir] is position after
      // When delta is greater, speed will be greater.
      delta = Math.abs(aniProps[scrollDir] - $scroller[scrollDir]());

      // Divide the delta by the coefficient
      speed = delta / opts.autoCoefficient;
    }

    aniOpts = {
      duration: speed,
      easing: opts.easing,
      complete: function() {
        onAfterScroll(opts);
      }
    };

    if (opts.step) {
      aniOpts.step = opts.step;
    }

    if ($scroller.length) {
      $scroller.stop().animate(aniProps, aniOpts);
    } else {
      onAfterScroll(opts);
    }
  };

  $.smoothScroll.version = version;
  $.smoothScroll.filterPath = function(string) {
    string = string || "";

    return string
      .replace(/^\//, "")
      .replace(/(?:index|default).[a-zA-Z]{3,4}$/, "")
      .replace(/\/$/, "");
  };

  // default options
  $.fn.smoothScroll.defaults = defaults;
});


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(5)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports === "object") {
    module.exports = factory(require("jquery"));
  } else {
    root.jquery_dotdotdot_js = factory(root.jQuery);
  }
})(this, function(jQuery) {
  /*
 *	jQuery dotdotdot 3.1.0
 *	@requires jQuery 1.7.0 or later
 *
 *	dotdotdot.frebsite.nl
 *
 *	Copyright (c) Fred Heusschen
 *	www.frebsite.nl
 *
 *	License: CC-BY-NC-4.0
 *	http://creativecommons.org/licenses/by-nc/4.0/
 */
  !(function(t) {
    "use strict";
    function e() {
      (h = t(window)),
        (s = {}),
        (r = {}),
        (o = {}),
        t.each([s, r, o], function(t, e) {
          e.add = function(t) {
            t = t.split(" ");
            for (var n = 0, i = t.length; n < i; n++) e[t[n]] = e.ddd(t[n]);
          };
        }),
        (s.ddd = function(t) {
          return "ddd-" + t;
        }),
        s.add("truncated keep text"),
        (r.ddd = function(t) {
          return "ddd-" + t;
        }),
        r.add("text"),
        (o.ddd = function(t) {
          return t + ".ddd";
        }),
        o.add("resize"),
        (e = function() {});
    }
    var n = "dotdotdot",
      i = "3.1.0";
    if (!(t[n] && t[n].version > i)) {
      (t[n] = function(t, e) {
        (this.$dot = t),
          (this.api = [
            "getInstance",
            "truncate",
            "restore",
            "destroy",
            "watch",
            "unwatch"
          ]),
          (this.opts = e);
        var i = this.$dot.data(n);
        return (
          i && i.destroy(),
          this.init(),
          this.truncate(),
          this.opts.watch && this.watch(),
          this
        );
      }),
        (t[n].version = i),
        (t[n].uniqueId = 0),
        (t[n].defaults = {
          ellipsis: " ",
          callback: function(t) {},
          truncate: "word",
          tolerance: 0,
          keep: null,
          watch: "window",
          height: null
        }),
        (t[n].prototype = {
          init: function() {
            (this.watchTimeout = null),
              (this.watchInterval = null),
              (this.uniqueId = t[n].uniqueId++),
              (this.originalContent = this.$dot.contents()),
              (this.originalStyle = this.$dot.attr("style") || ""),
              "break-word" !== this.$dot.css("word-wrap") &&
                this.$dot.css("word-wrap", "break-word"),
              "nowrap" === this.$dot.css("white-space") &&
                this.$dot.css("white-space", "normal"),
              null === this.opts.height &&
                (this.opts.height = this._getMaxHeight());
          },
          getInstance: function() {
            return this;
          },
          truncate: function() {
            var e = this;
            (this.$inner = this.$dot
              .wrapInner("<div />")
              .children()
              .css({
                display: "block",
                height: "auto",
                width: "auto",
                border: "none",
                padding: 0,
                margin: 0
              })),
              this.$inner
                .contents()
                .detach()
                .end()
                .append(this.originalContent.clone(!0)),
              this.$inner.find("script, style").addClass(s.keep),
              this.opts.keep &&
                this.$inner.find(this.opts.keep).addClass(s.keep),
              this.$inner
                .find("*")
                .not("." + s.keep)
                .add(this.$inner)
                .contents()
                .each(function() {
                  var n = this,
                    i = t(this);
                  if (3 == n.nodeType) {
                    if (
                      i
                        .parent()
                        .is("table, thead, tfoot, tr, dl, ul, ol, video")
                    )
                      return void i.remove();
                    if (i.parent().contents().length > 1) {
                      var r = t(
                        '<span class="' +
                          s.text +
                          '">' +
                          e.__getTextContent(n) +
                          "</span>"
                      ).css({
                        display: "inline",
                        height: "auto",
                        width: "auto",
                        border: "none",
                        padding: 0,
                        margin: 0
                      });
                      i.replaceWith(r);
                    }
                  } else 8 == n.nodeType && i.remove();
                }),
              (this.maxHeight = this._getMaxHeight());
            var n = this._truncateNode(this.$dot);
            return (
              this.$dot[n ? "addClass" : "removeClass"](s.truncated),
              this.$inner.find("." + s.text).each(function() {
                t(this).replaceWith(t(this).contents());
              }),
              this.$inner.find("." + s.keep).removeClass(s.keep),
              this.$inner.replaceWith(this.$inner.contents()),
              (this.$inner = null),
              this.opts.callback.call(this.$dot[0], n),
              n
            );
          },
          restore: function() {
            this.unwatch(),
              this.$dot
                .contents()
                .detach()
                .end()
                .append(this.originalContent)
                .attr("style", this.originalStyle)
                .removeClass(s.truncated);
          },
          destroy: function() {
            this.restore(), this.$dot.data(n, null);
          },
          watch: function() {
            var t = this;
            this.unwatch();
            var e = {};
            "window" == this.opts.watch
              ? h.on(o.resize + t.uniqueId, function(n) {
                  t.watchTimeout && clearTimeout(t.watchTimeout),
                    (t.watchTimeout = setTimeout(function() {
                      e = t._watchSizes(e, h, "width", "height");
                    }, 100));
                })
              : (this.watchInterval = setInterval(function() {
                  e = t._watchSizes(e, t.$dot, "innerWidth", "innerHeight");
                }, 500));
          },
          unwatch: function() {
            h.off(o.resize + this.uniqueId),
              this.watchInterval && clearInterval(this.watchInterval),
              this.watchTimeout && clearTimeout(this.watchTimeout);
          },
          _api: function() {
            var e = this,
              n = {};
            return (
              t.each(this.api, function(t) {
                var i = this;
                n[i] = function() {
                  var t = e[i].apply(e, arguments);
                  return "undefined" == typeof t ? n : t;
                };
              }),
              n
            );
          },
          _truncateNode: function(e) {
            var n = this,
              i = !1,
              r = !1;
            return (
              t(
                e
                  .children()
                  .get()
                  .reverse()
              )
                .not("." + s.keep)
                .each(function() {
                  var e = (t(this).contents()[0], t(this));
                  if (!i && !e.hasClass(s.keep)) {
                    if (e.children().length) i = n._truncateNode(e);
                    else if (!n._fits() || r) {
                      var o = t("<span>").css("display", "none");
                      if ((e.replaceWith(o), e.detach(), n._fits())) {
                        if ("node" == n.opts.truncate) return !0;
                        o.replaceWith(e),
                          (i = n._truncateWord(e)),
                          i || ((r = !0), e.detach());
                      } else o.remove();
                    }
                    e.contents().length || e.remove();
                  }
                }),
              i
            );
          },
          _truncateWord: function(t) {
            var e = t.contents()[0];
            if (!e) return !1;
            for (
              var n = this,
                i = this.__getTextContent(e),
                s = i.indexOf(" ") !== -1 ? " " : "",
                r = i.split(s),
                o = "",
                h = r.length;
              h >= 0;
              h--
            ) {
              if (((o = r.slice(0, h).join(s)), 0 == h))
                return (
                  "letter" == n.opts.truncate &&
                  (n.__setTextContent(e, r.slice(0, h + 1).join(s)),
                  n._truncateLetter(e))
                );
              if (
                o.length &&
                (n.__setTextContent(e, n._addEllipsis(o)), n._fits())
              )
                return (
                  "letter" != n.opts.truncate ||
                  (n.__setTextContent(e, r.slice(0, h + 1).join(s)),
                  n._truncateLetter(e))
                );
            }
            return !1;
          },
          _truncateLetter: function(t) {
            for (
              var e = this,
                n = this.__getTextContent(t),
                i = n.split(""),
                s = "",
                r = i.length;
              r >= 0;
              r--
            )
              if (
                ((s = i.slice(0, r).join("")),
                s.length &&
                  (e.__setTextContent(t, e._addEllipsis(s)), e._fits()))
              )
                return !0;
            return !1;
          },
          _fits: function() {
            return (
              this.$inner.innerHeight() <= this.maxHeight + this.opts.tolerance
            );
          },
          _addEllipsis: function(e) {
            for (
              var n = [" ", "", ",", ";", ".", "!", "?"];
              t.inArray(e.slice(-1), n) > -1;

            )
              e = e.slice(0, -1);
            return (e += this.opts.ellipsis);
          },
          _getMaxHeight: function() {
            if ("number" == typeof this.opts.height) return this.opts.height;
            for (
              var t = ["maxHeight", "height"], e = 0, n = 0;
              n < t.length;
              n++
            )
              if (
                ((e = window.getComputedStyle(this.$dot[0])[t[n]]),
                "px" == e.slice(-2))
              ) {
                e = parseFloat(e);
                break;
              }
            var t = [];
            switch (this.$dot.css("boxSizing")) {
              case "border-box":
                t.push("borderTopWidth"), t.push("borderBottomWidth");
              case "padding-box":
                t.push("paddingTop"), t.push("paddingBottom");
            }
            for (var n = 0; n < t.length; n++) {
              var i = window.getComputedStyle(this.$dot[0])[t[n]];
              "px" == i.slice(-2) && (e -= parseFloat(i));
            }
            return Math.max(e, 0);
          },
          _watchSizes: function(t, e, n, i) {
            if (this.$dot.is(":visible")) {
              var s = { width: e[n](), height: e[i]() };
              return (
                (t.width == s.width && t.height == s.height) || this.truncate(),
                s
              );
            }
            return t;
          },
          __getTextContent: function(t) {
            for (
              var e = ["nodeValue", "textContent", "innerText"], n = 0;
              n < e.length;
              n++
            )
              if ("string" == typeof t[e[n]]) return t[e[n]];
            return "";
          },
          __setTextContent: function(t, e) {
            for (
              var n = ["nodeValue", "textContent", "innerText"], i = 0;
              i < n.length;
              i++
            )
              t[n[i]] = e;
          }
        }),
        (t.fn[n] = function(i) {
          return (
            e(),
            (i = t.extend(!0, {}, t[n].defaults, i)),
            this.each(function() {
              t(this).data(n, new t[n](t(this), i)._api());
            })
          );
        });
      var s, r, o, h;
    }
  })(jQuery);
  return true;
});


/***/ }),
/* 74 */
/***/ (function(module, exports) {

/**
 * jquery-match-height master by @liabru
 * http://brm.io/jquery-match-height/
 * License: MIT
 */

(function($, window, document) {
  /*
    *  internal
    */

  var _previousResizeWidth = -1,
    _updateTimeout = -1;

  /*
    *  _parse
    *  value parse utility function
    */

  var _parse = function(value) {
    // parse value and convert NaN to 0
    return parseFloat(value) || 0;
  };

  /*
    *  _rows
    *  utility function returns array of jQuery selections representing each row
    *  (as displayed after float wrapping applied by browser)
    */

  var _rows = function(elements) {
    var tolerance = 1,
      $elements = $(elements),
      lastTop = null,
      rows = [];

    // group elements by their top position
    $elements.each(function() {
      var $that = $(this),
        top = $that.offset().top - _parse($that.css("margin-top")),
        lastRow = rows.length > 0 ? rows[rows.length - 1] : null;

      if (lastRow === null) {
        // first item on the row, so just push it
        rows.push($that);
      } else {
        // if the row top is the same, add to the row group
        if (Math.floor(Math.abs(lastTop - top)) <= tolerance) {
          rows[rows.length - 1] = lastRow.add($that);
        } else {
          // otherwise start a new row group
          rows.push($that);
        }
      }

      // keep track of the last row top
      lastTop = top;
    });

    return rows;
  };

  /*
    *  _parseOptions
    *  handle plugin options
    */

  var _parseOptions = function(options) {
    var opts = {
      byRow: true,
      property: "height",
      target: null,
      remove: false
    };

    if (typeof options === "object") {
      return $.extend(opts, options);
    }

    if (typeof options === "boolean") {
      opts.byRow = options;
    } else if (options === "remove") {
      opts.remove = true;
    }

    return opts;
  };

  /*
    *  matchHeight
    *  plugin definition
    */

  var matchHeight = ($.fn.matchHeight = function(options) {
    var opts = _parseOptions(options);

    // handle remove
    if (opts.remove) {
      var that = this;

      // remove fixed height from all selected elements
      this.css(opts.property, "");

      // remove selected elements from all groups
      $.each(matchHeight._groups, function(key, group) {
        group.elements = group.elements.not(that);
      });

      // TODO: cleanup empty groups

      return this;
    }

    if (this.length <= 1 && !opts.target) {
      return this;
    }

    // keep track of this group so we can re-apply later on load and resize events
    matchHeight._groups.push({
      elements: this,
      options: opts
    });

    // match each element's height to the tallest element in the selection
    matchHeight._apply(this, opts);

    return this;
  });

  /*
    *  plugin global options
    */

  matchHeight.version = "master";
  matchHeight._groups = [];
  matchHeight._throttle = 80;
  matchHeight._maintainScroll = false;
  matchHeight._beforeUpdate = null;
  matchHeight._afterUpdate = null;
  matchHeight._rows = _rows;
  matchHeight._parse = _parse;
  matchHeight._parseOptions = _parseOptions;

  /*
    *  matchHeight._apply
    *  apply matchHeight to given elements
    */

  matchHeight._apply = function(elements, options) {
    var opts = _parseOptions(options),
      $elements = $(elements),
      rows = [$elements];

    // take note of scroll position
    var scrollTop = $(window).scrollTop(),
      htmlHeight = $("html").outerHeight(true);

    // get hidden parents
    var $hiddenParents = $elements.parents().filter(":hidden");

    // cache the original inline style
    $hiddenParents.each(function() {
      var $that = $(this);
      $that.data("style-cache", $that.attr("style"));
    });

    // temporarily must force hidden parents visible
    $hiddenParents.css("display", "block");

    // get rows if using byRow, otherwise assume one row
    if (opts.byRow && !opts.target) {
      // must first force an arbitrary equal height so floating elements break evenly
      $elements.each(function() {
        var $that = $(this),
          display = $that.css("display");

        // temporarily force a usable display value
        if (
          display !== "inline-block" &&
          display !== "flex" &&
          display !== "inline-flex"
        ) {
          display = "block";
        }

        // cache the original inline style
        $that.data("style-cache", $that.attr("style"));

        $that.css({
          display: display,
          "padding-top": "0",
          "padding-bottom": "0",
          "margin-top": "0",
          "margin-bottom": "0",
          "border-top-width": "0",
          "border-bottom-width": "0",
          height: "100px",
          overflow: "hidden"
        });
      });

      // get the array of rows (based on element top position)
      rows = _rows($elements);

      // revert original inline styles
      $elements.each(function() {
        var $that = $(this);
        $that.attr("style", $that.data("style-cache") || "");
      });
    }

    $.each(rows, function(key, row) {
      var $row = $(row),
        targetHeight = 0;

      if (!opts.target) {
        // skip apply to rows with only one item
        if (opts.byRow && $row.length <= 1) {
          $row.css(opts.property, "");
          return;
        }

        // iterate the row and find the max height
        $row.each(function() {
          var $that = $(this),
            style = $that.attr("style"),
            display = $that.css("display");

          // temporarily force a usable display value
          if (
            display !== "inline-block" &&
            display !== "flex" &&
            display !== "inline-flex"
          ) {
            display = "block";
          }

          // ensure we get the correct actual height (and not a previously set height value)
          var css = { display: display };
          css[opts.property] = "";
          $that.css(css);

          // find the max height (including padding, but not margin)
          if ($that.outerHeight(false) > targetHeight) {
            targetHeight = $that.outerHeight(false);
          }

          // revert styles
          if (style) {
            $that.attr("style", style);
          } else {
            $that.css("display", "");
          }
        });
      } else {
        // if target set, use the height of the target element
        targetHeight = opts.target.outerHeight(false);
      }

      // iterate the row and apply the height to all elements
      $row.each(function() {
        var $that = $(this),
          verticalPadding = 0;

        // don't apply to a target
        if (opts.target && $that.is(opts.target)) {
          return;
        }

        // handle padding and border correctly (required when not using border-box)
        if ($that.css("box-sizing") !== "border-box") {
          verticalPadding +=
            _parse($that.css("border-top-width")) +
            _parse($that.css("border-bottom-width"));
          verticalPadding +=
            _parse($that.css("padding-top")) +
            _parse($that.css("padding-bottom"));
        }

        // set the height (accounting for padding and border)
        $that.css(opts.property, targetHeight - verticalPadding + "px");
      });
    });

    // revert hidden parents
    $hiddenParents.each(function() {
      var $that = $(this);
      $that.attr("style", $that.data("style-cache") || null);
    });

    // restore scroll position if enabled
    if (matchHeight._maintainScroll) {
      $(window).scrollTop(scrollTop / htmlHeight * $("html").outerHeight(true));
    }

    return this;
  };

  /*
    *  matchHeight._applyDataApi
    *  applies matchHeight to all elements with a data-match-height attribute
    */

  matchHeight._applyDataApi = function() {
    var groups = {};

    // generate groups by their groupId set by elements using data-match-height
    $("[data-match-height], [data-mh]").each(function() {
      var $this = $(this),
        groupId = $this.attr("data-mh") || $this.attr("data-match-height");

      if (groupId in groups) {
        groups[groupId] = groups[groupId].add($this);
      } else {
        groups[groupId] = $this;
      }
    });

    // apply matchHeight to each group
    $.each(groups, function() {
      this.matchHeight(true);
    });
  };

  /*
    *  matchHeight._update
    *  updates matchHeight on all current groups with their correct options
    */

  var _update = function(event) {
    if (matchHeight._beforeUpdate) {
      matchHeight._beforeUpdate(event, matchHeight._groups);
    }

    $.each(matchHeight._groups, function() {
      matchHeight._apply(this.elements, this.options);
    });

    if (matchHeight._afterUpdate) {
      matchHeight._afterUpdate(event, matchHeight._groups);
    }
  };

  matchHeight._update = function(throttle, event) {
    // prevent update if fired from a resize event
    // where the viewport width hasn't actually changed
    // fixes an event looping bug in IE8
    if (event && event.type === "resize") {
      var windowWidth = $(window).width();
      if (windowWidth === _previousResizeWidth) {
        return;
      }
      _previousResizeWidth = windowWidth;
    }

    // throttle updates
    if (!throttle) {
      _update(event);
    } else if (_updateTimeout === -1) {
      _updateTimeout = setTimeout(function() {
        _update(event);
        _updateTimeout = -1;
      }, matchHeight._throttle);
    }
  };

  /*
    *  bind events
    */

  // apply on DOM ready event
  $(matchHeight._applyDataApi);

  // update heights on load and resize events
  $(window).bind("load", function(event) {
    matchHeight._update(false, event);
  });

  // throttled update heights on resize events
  $(window).bind("resize orientationchange", function(event) {
    matchHeight._update(true, event);
  });
})(jQuery, window, document);


/***/ }),
/* 75 */
/***/ (function(module, exports) {

/**
 * Load svg via ajax
 * @param  {string} url path to svg sprite
 * @generator: webpack-svgstore-plugin
 * @see: https://www.npmjs.com/package/webpack-svgstore-plugin
 * @return {[type]}     [description]
 */
var svgXHR = function(options) {
  var url = false;
  var baseUrl = undefined;

  options && options.filename ? (url = options.filename) : null;

  if (!url) return false;
  var _ajax = new XMLHttpRequest();
  var _fullPath;

  if (typeof XDomainRequest !== "undefined") {
    _ajax = new XDomainRequest();
  }

  if (typeof baseUrl === "undefined") {
    if (typeof window.baseUrl !== "undefined") {
      baseUrl = window.baseUrl;
    } else {
      baseUrl =
        window.location.protocol +
        "//" +
        window.location.hostname +
        (window.location.port ? ":" + window.location.port : "");
    }
  }

  _fullPath = (baseUrl + "/" + url).replace(/([^:]\/)\/+/g, "$1");
  _ajax.open("GET", _fullPath, true);
  _ajax.onprogress = function() {};
  _ajax.onload = function() {
    if (!_ajax.responseText || _ajax.responseText.substr(0, 4) !== "<svg") {
      throw Error("Invalid SVG Response");
    }
    if (_ajax.status < 200 || _ajax.status >= 300) {
      return;
    }
    var div = document.createElement("div");
    div.innerHTML = _ajax.responseText;
    document.body.insertBefore(div, document.body.childNodes[0]);
  };
  _ajax.send();
};

module.exports = svgXHR;


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzM0MmQyMjNlNWZjM2VlZjViY2EiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mYWlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xhenlzaXplcy9sYXp5c2l6ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9qcy9zY3JpcHRzLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90YWdnZWRUZW1wbGF0ZUxpdGVyYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2NvcmUtanMvb2JqZWN0L2ZyZWV6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9mcmVlemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi8ubW9kZXJuaXpycmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZGVudC9kaXN0L2RlZGVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGljdHVyZWZpbGwvZGlzdC9waWN0dXJlZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2ViZm9udGxvYWRlci93ZWJmb250bG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXNwb25zaXZlLW5hdi9jbGllbnQvZGlzdC9yZXNwb25zaXZlLW5hdi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGF6eXNpemVzL3BsdWdpbnMvYXNwZWN0cmF0aW8vbHMuYXNwZWN0cmF0aW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xhenlzaXplcy9wbHVnaW5zL2Jnc2V0L2xzLmJnc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sYXp5c2l6ZXMvcGx1Z2lucy91bnZlaWxob29rcy9scy51bnZlaWxob29rcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNtb2JpbGVqcy9pc01vYmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm93c2VyL3NyYy9ib3dzZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWJkYS9kaXN0L3JhbWJkYS5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS5lYXNpbmcvanF1ZXJ5LmVhc2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXNtb290aC1zY3JvbGwvanF1ZXJ5LnNtb290aC1zY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS5kb3Rkb3Rkb3QvZGlzdC9qcXVlcnkuZG90ZG90ZG90LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktbWF0Y2gtaGVpZ2h0LWJyb3dzZXJpZnkvanF1ZXJ5Lm1hdGNoSGVpZ2h0LmpzIiwid2VicGFjazovLy8od2VicGFjayktc3Znc3RvcmUtcGx1Z2luL3NyYy9oZWxwZXJzL3N2Z3hoci5qcyJdLCJuYW1lcyI6WyJ3aW5kb3ciLCIkIiwialF1ZXJ5IiwiUiIsImdsb2JhbCIsImlzTW9iaWxlIiwiYm93c2VyIiwicmVxdWlyZSIsIl9fc3ZnX18iLCJkZXRlY3QiLCJkZXNrdG9wIiwiYW55IiwibW9iaWxlIiwicGhvbmUiLCJ0YWJsZXQiLCJjaHJvbWUiLCJ2ZXJzaW9uIiwiZmlyZWZveCIsInNhZmFyaSIsIm1zaWUiLCJtc2VkZ2UiLCJpUGhvbmUiLCJhcHBsZSIsImFuZHJvaWRwaG9uZSIsImFuZHJvaWQiLCJpT1MiLCJkZXZpY2UiLCJhbmRyb2lkT1MiLCJjb25zb2xlIiwibG9nIiwib2JqZWN0Zml0Iiwic2VjdHNlY3QiLCJhZGRDbGFzcyIsImFyeSIsImFwcGVuZCIsImxvYWQiLCJnb29nbGUiLCJmYW1pbGllcyIsImF0dHIiLCJoaURQSSIsImRldmljZVBpeGVsUmF0aW8iLCJ0cmFuc2l0aW9uIiwibGFiZWwiLCJpbml0Iiwic2hvdyIsImV2ZW50IiwiYWRkIiwibGVuZ3RoIiwiZG90ZG90ZG90Iiwid2F0Y2giLCJ0cnVuY2F0ZSIsImNhbGxiYWNrIiwiaXNUcnVuY2F0ZWQiLCJoIiwicGFyc2VJbnQiLCJvdXRlckhlaWdodCIsIm9uIiwib2Zmc2V0IiwicGFyZW50IiwiaGFzQ2xhc3MiLCJ0YXJnZXQiLCJzbW9vdGhTY3JvbGwiLCJlYXNpbmciLCJzcGVlZCIsInNjcm9sbFRhcmdldCIsImhlYWRlckgiLCJ1cmwiLCJsb2NhdGlvbiIsImluZGV4T2YiLCJ1cmxzcCIsInNwbGl0IiwiaGFzaCIsInRndCIsInNldFRpbWVvdXQiLCJwb3MiLCJ0b3AiLCJhbmltYXRlIiwic2Nyb2xsVG9wIiwibWF0Y2hIZWlnaHQiLCJieVJvdyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOzs7Ozs7O0FDVEQsOEJBQThCLG1CQUFtQjtBQUNqRCx1Q0FBdUM7Ozs7Ozs7QUNEdkM7QUFDQTtBQUNBOzs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekIsaUJBQWlCLFFBQVE7QUFDekIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVEsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakMsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQjs7QUFFdEIsZ0JBQWdCOztBQUVoQjtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQsZ0JBQWdCLG9CQUFvQjtBQUNwQyxnQkFBZ0Isc0NBQXNDO0FBQ3RELGdCQUFnQjtBQUNoQixTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVFQUF1RTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFOztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEYsK0NBQStDLDJCQUEyQjtBQUMxRTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0NBQStDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELGtCQUFrQix3Q0FBd0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixNQUFNO0FBQ3ZCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLEdBQUc7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDhDQUE4QztBQUM5QyxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELHNDQUFzQztBQUN6RiwrQ0FBK0MsdUNBQXVDO0FBQ3RGLCtDQUErQyxzQ0FBc0M7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QywwQ0FBMEM7QUFDMUMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLGFBQWE7QUFDMUMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLE9BQU87QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0IsMkJBQTJCLGNBQWM7QUFDekMscUJBQXFCLFdBQVcsWUFBWTtBQUM1QyxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVLFNBQVMsTUFBTSxhQUFhO0FBQ3RELGlCQUFpQixlQUFlO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrREFBK0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxnQkFBZ0Isa0JBQWtCO0FBQ2xDLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSxtQkFBbUI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFDQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsYUFBYTtBQUNiOztBQUVBLGtCQUFrQjtBQUNsQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQixZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSwyQkFBMkI7QUFDM0IsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLGdFQUFnRSxlQUFlO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGVBQWUsc0RBQXNEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0EsT0FBTyw2REFBNkQ7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQUE7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDcjNVRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOzs7Ozs7O0FDUnpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEI7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Qzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOzs7Ozs7O0FDVkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUNBQW1DO0FBQ25ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7O0FDdnpCRCx5Qzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ0pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTkEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBQSxPQUFPQyxDQUFQO0FBQ0FELE9BQU9FLE1BQVA7QUFDQUYsT0FBT0csQ0FBUCxHQUFXQSxDQUFYO0FBQ0FDLE9BQU9DLFFBQVA7QUFDQUQsT0FBT0UsTUFBUDs7QUFFQSxtQkFBQUMsQ0FBUSxFQUFSOztBQUNBLG1CQUFBQSxDQUFRLEVBQVI7O0FBQ0EsbUJBQUFBLENBQVEsRUFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxFQUFSOztBQUVBLElBQU0sbUZBQU47O0FBSUEsbUJBQUFBLENBQVEsRUFBUixFQUFzREMsT0FBdEQ7O0FBRUEsSUFBTUMsU0FBUztBQUNiQyxXQUFTLENBQUNMLFNBQVNNLEdBRE47QUFFYkMsVUFBUVAsU0FBU00sR0FGSjtBQUdiRSxTQUFPUixTQUFTUSxLQUhIO0FBSWJDLFVBQVFULFNBQVNTLE1BSko7QUFLYkMsVUFBUyxnQkFBT0EsTUFBUixHQUFrQixnQkFBT0MsT0FBekIsR0FBbUMsS0FMOUI7QUFNYkMsV0FBVSxnQkFBT0EsT0FBUixHQUFtQixnQkFBT0QsT0FBMUIsR0FBb0MsS0FOaEM7QUFPYkUsVUFBUyxnQkFBT0EsTUFBUixHQUFrQixnQkFBT0YsT0FBekIsR0FBbUMsS0FQOUI7QUFRYkcsUUFBTyxnQkFBT0EsSUFBUixHQUFnQixnQkFBT0gsT0FBdkIsR0FBaUMsS0FSMUI7QUFTYkksVUFBUyxnQkFBT0EsTUFBUixHQUFrQixnQkFBT0osT0FBekIsR0FBbUMsS0FUOUI7QUFVYkssVUFBUWhCLFNBQVNpQixLQUFULENBQWVULEtBVlY7QUFXYlUsZ0JBQWNsQixTQUFTbUIsT0FBVCxDQUFpQlgsS0FYbEI7QUFZYlksT0FBS3BCLFNBQVNpQixLQUFULENBQWVJLE1BWlA7QUFhYkMsYUFBV3RCLFNBQVNtQixPQUFULENBQWlCRTtBQWJmLENBQWY7QUFlQUUsUUFBUUMsR0FBUixDQUFZcEIsTUFBWjs7QUFFQSxJQUFJLENBQUMsbUJBQVVxQixTQUFmLEVBQTBCO0FBQ3hCRixVQUFRQyxHQUFSLENBQVksZUFBWjtBQUNELENBRkQsTUFFTztBQUNMRCxVQUFRQyxHQUFSLENBQVksV0FBWjtBQUNELEMsQ0FFRDs7O0FBQ0EsSUFBTUUsZ0RBQU47QUFJQUgsUUFBUUMsR0FBUixDQUFZRSxRQUFaLEUsQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE5QixFQUFFLE1BQUYsRUFBVStCLFFBQVYsQ0FBbUIsVUFBbkI7QUFFQSxJQUFNQyxNQUFNOUIsRUFBRStCLE1BQUYsQ0FBUyxLQUFULEVBQWdCLENBQUMsS0FBRCxFQUFRLEtBQVIsQ0FBaEIsQ0FBWjtBQUNBTixRQUFRQyxHQUFSLENBQVlJLEdBQVo7QUFFQTs7OztBQUdBLHVCQUFRRSxJQUFSLENBQWE7QUFDWEMsVUFBUTtBQUNOQyxjQUFVLENBQUMscUJBQUQsRUFBd0IsZUFBeEIsRUFBeUMsa0JBQXpDLEVBQTZELHNCQUE3RDtBQURKO0FBREcsQ0FBYjs7QUFNQW5DLE9BQU8sWUFBTTtBQUNYOzs7QUFHQSxNQUFJRyxTQUFTUyxNQUFiLEVBQXFCO0FBQ25CWixXQUFPLFdBQVAsRUFBb0JvQyxJQUFwQixDQUF5QixTQUF6QixFQUFvQyxZQUFwQztBQUNEO0FBQ0Q7Ozs7O0FBR0EsTUFBTUMsUUFBUSxDQUFDLEVBQUcsc0JBQXNCdkMsTUFBdEIsSUFBZ0N3QyxtQkFBbUIsQ0FBdEQsQ0FBZixDQVZXLENBV1g7O0FBQ0E7Ozs7QUFHQSw4QkFBYyxNQUFkLEVBQXNCO0FBQUU7QUFDdEI7QUFDQUMsZ0JBQVksR0FGUTtBQUVIO0FBQ2pCO0FBQ0FDLFdBQU8sNkJBSmE7QUFJa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUMsUUFab0Isa0JBWWI7QUFDTHpDLGFBQU8sTUFBUCxFQUFlMEMsSUFBZjtBQUNEO0FBZG1CLEdBQXRCLENBY0s7QUFDSDtBQUNBO0FBaEJGO0FBa0JBOzs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7QUFZQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0QsQ0FyRUQ7QUF1RUExQyxPQUFPMkMsS0FBUCxDQUFhQyxHQUFiLENBQWlCOUMsTUFBakIsRUFBeUIsTUFBekIsRUFBaUMsWUFBTTtBQUNyQzs7O0FBR0EsTUFBSUUsT0FBTyxhQUFQLEVBQXNCNkMsTUFBMUIsRUFBa0M7QUFDaEM3QyxXQUFPLGFBQVAsRUFBc0I4QyxTQUF0QixDQUFnQztBQUM5QkMsYUFBTyxRQUR1QjtBQUU5QkMsZ0JBQVUsUUFGb0I7QUFHOUJDLGNBSDhCLG9CQUdyQkMsV0FIcUIsRUFHUjtBQUNwQmxELGVBQU8sSUFBUCxFQUFhOEIsUUFBYixDQUFzQixPQUF0QjtBQUNEO0FBTDZCLEtBQWhDO0FBT0Q7QUFDRDs7Ozs7QUFHQSxNQUFNcUIsSUFBSUMsb0JBQWFwRCxPQUFPLFNBQVAsRUFBa0JxRCxXQUFsQixDQUE4QixJQUE5QixDQUFiLEdBQW9ELEVBQXBELENBQVY7QUFDQXJELFNBQU8sY0FBUCxFQUF1QnNELEVBQXZCLENBQTBCLE9BQTFCLEVBQW1DLFlBQVk7QUFDN0MsUUFBTUMsU0FBVXZELE9BQU8sSUFBUCxFQUFhd0QsTUFBYixHQUFzQkMsUUFBdEIsQ0FBK0IsU0FBL0IsQ0FBRCxHQUE4QyxDQUE5QyxHQUFrRE4sQ0FBakU7QUFDQSxRQUFNTyxTQUFTMUQsT0FBTyxJQUFQLEVBQWFvQyxJQUFiLENBQWtCLE1BQWxCLENBQWY7QUFDQXJDLE1BQUU0RCxZQUFGLENBQWU7QUFDYkMsY0FBUSxjQURLO0FBRWJDLGFBQU8sR0FGTTtBQUdiTixvQkFIYTtBQUliTyxvQkFBY0o7QUFKRCxLQUFmO0FBTUEsV0FBTyxLQUFQO0FBQ0QsR0FWRDtBQVdBLE1BQU1LLFVBQVUvRCxPQUFPLFNBQVAsRUFBa0JxRCxXQUFsQixDQUE4QixJQUE5QixDQUFoQixDQTVCcUMsQ0E2QnJDOztBQUNBLE1BQU1XLE1BQU1oRSxPQUFPRixPQUFPbUUsUUFBZCxFQUF3QjdCLElBQXhCLENBQTZCLE1BQTdCLENBQVo7O0FBQ0EsTUFBSTRCLElBQUlFLE9BQUosQ0FBWSxNQUFaLE1BQXdCLENBQUMsQ0FBN0IsRUFBZ0MsQ0FDOUI7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFNQyxRQUFRSCxJQUFJSSxLQUFKLENBQVUsTUFBVixDQUFkO0FBQ0EsUUFBTUMsa0JBQVdGLE1BQU1BLE1BQU10QixNQUFOLEdBQWUsQ0FBckIsQ0FBWCxDQUFOO0FBQ0EsUUFBTXlCLE1BQU10RSxPQUFPcUUsSUFBUCxDQUFaO0FBQ0FFLGVBQVcsWUFBTTtBQUNmLFVBQU1DLE1BQU1GLElBQUlmLE1BQUosR0FBYWtCLEdBQWIsR0FBbUJWLE9BQS9CLENBRGUsQ0FDeUI7O0FBQ3hDL0QsYUFBTyxZQUFQLEVBQXFCMEUsT0FBckIsQ0FBNkI7QUFDM0JDLG1CQUFXSDtBQURnQixPQUE3QixFQUVHLElBRkgsRUFFUyxjQUZUO0FBR0QsS0FMRCxFQUtHLEdBTEg7QUFNRDtBQUNGLENBNUNEO0FBOENBeEUsT0FBT0YsTUFBUCxFQUFld0QsRUFBZixDQUFrQiwrQkFBbEIsRUFBbUQsWUFBTTtBQUN2RDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7O0FBR0F0RCxTQUFPLFdBQVAsRUFBb0I0RSxXQUFwQjtBQUNBNUUsU0FBTyxLQUFQLEVBQWM0RSxXQUFkLENBQTBCO0FBQUVDLFdBQU87QUFBVCxHQUExQixFQXpEdUQsQ0EwRHZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNELENBbkVELEU7Ozs7Ozs7QUMxTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7O0FDbkJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUM7Ozs7OztBQzdCQSx5Qzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNSRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUEEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTtBQUNmO0FBQ0E7Ozs7Ozs7QUNmQSxjQUFjOzs7Ozs7O0FDQWQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSx3Qzs7Ozs7O0FDWkEseUM7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUNKRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEOzs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHVDQUF1QztBQUN2Qzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSEEseUM7Ozs7OztBQ0FBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDUkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUM3REQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQixvQkFBb0IsYUFBYSxrQkFBa0IsdUNBQXVDLHFIQUFxSCwyQkFBMkIsK0NBQStDLHlDQUF5QyxXQUFXLHlOQUF5TixjQUFjLHNEQUFzRCxxREFBcUQsNkNBQTZDLDZCQUE2QixnR0FBZ0csZ0JBQWdCLDJCQUEyQixhQUFhLGdMQUFnTCxhQUFhLGFBQWEsNENBQTRDLG9CQUFvQiwyQ0FBMkMsdUJBQXVCLElBQUksaURBQWlELG9aQUFvWixjQUFjLDBDQUEwQywwQkFBMEIseUJBQXlCLGtCQUFrQixNQUFNLDJCQUEyQiwrQkFBK0IsZ0JBQWdCLHlDQUF5QyxXQUFXLDRCQUE0QixvR0FBb0csNkNBQTZDLFNBQVMsZ0JBQWdCLGVBQWUsa0NBQWtDLEtBQUssSUFBSSx1Q0FBdUMsU0FBUywwQkFBMEIsYUFBYSxJQUFJLCtCQUErQiw4Q0FBOEMsYUFBYSxvQkFBb0IsRUFBRSxFQUFFLGNBQWMsdUNBQXVDLEVBQUUsU0FBUyxjQUFjLG9EQUFvRCx5QkFBeUIsbUJBQW1CLG9CQUFvQixhQUFhLHFDQUFxQyw4Q0FBOEMsYUFBYSw4QkFBOEIsaURBQWlELG1CQUFtQixxREFBcUQsbUJBQW1CLElBQUksOERBQThELGdEQUFnRCxJQUFJLGFBQWEsVUFBVSwwQ0FBMEMsY0FBYyxnQkFBZ0Isa0JBQWtCLDZCQUE2QixrQkFBa0IsTUFBTSxzRkFBc0YsU0FBUyxzQkFBc0IsZ0ZBQWdGLGtHQUFrRyxrQkFBa0Isb0JBQW9CLFlBQVksMEJBQTBCLGdFQUFnRSx3QkFBd0IsV0FBVyxzQkFBc0IsUUFBUSxJQUFJLHlCQUF5QixRQUFRLHNCQUFzQixFQUFFLDBCQUEwQixRQUFRLGVBQWUsR0FBRyx3QkFBd0IsOENBQThDLDRIQUE0SCxtQkFBbUIsT0FBTyxxQkFBcUIsNkJBQTZCLGNBQWMsRUFBRSxPQUFPLG9CQUFvQixnQ0FBZ0MsZUFBZSxFQUFFLDBEQUEwRCxrQ0FBa0Msa0JBQWtCLG9DQUFvQyxrQ0FBa0MsZUFBZSx1RkFBdUYsWUFBWSxJQUFJLEtBQUssMENBQTBDLDJDQUEyQyxVQUFVLFdBQVcsaUNBQWlDLHFGQUFxRixnREFBZ0QsdUJBQXVCLG9MQUFvTCxZQUFZLHNCQUFzQixzQkFBc0Isc0JBQXNCO0FBQ2o2SjtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUMsTUFBTSx5QkFBeUI7QUFDL0IsQ0FBQyxVOzs7Ozs7O0FDVEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQzFEQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU8sa0JBQWtCLGNBQWMsVUFBVSxZQUFZLGNBQWMsVUFBVSxnQkFBZ0I7QUFDNUgsd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDZCQUE2QjtBQUM1Qzs7QUFFQTtBQUNBOztBQUVBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsMkJBQTJCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUFBO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUN2bUREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9ELDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkNBQTJDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQixZQUFZLGFBQWEsZ0JBQWdCLFdBQVcsWUFBWSxtQkFBbUIsU0FBUyxVQUFVLG9CQUFvQixtQkFBbUI7QUFDcEw7QUFDQSxRQUFRO0FBQ1IsZ0NBQWdDLGlDQUFpQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsVUFBVSwyQ0FBMkM7QUFDckQ7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25ELHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFBQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQ3J4QkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsRUFBRTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixNQUFNO0FBQ3hCLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEIsa0JBQWtCLFNBQVM7QUFDM0Isa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7O0FBRTdEO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZCQUE2Qjs7QUFFakU7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUMzcUJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDNU5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7Ozs7OztBQ3hNRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7QUN0SkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDMUpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7QUFDQSxjQUFjLGNBQWM7QUFDNUIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7OztBQzNtQkQ7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksRUFBRSxFQUFFO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLEVBQUUsRUFBRSxFQUFFO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFLEVBQUUsSUFBSTtBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVRO0FBQ1I7Ozs7Ozs7QUMzK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUFBO0FBQ0wsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7Ozs7Ozs7QUNsS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7O0FBRXREO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkNBQTJDLHdCQUF3Qjs7QUFFbkU7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGFBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUyxhQUFhO0FBQ3RCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsSUFBSTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7O0FDMVhEO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7Ozs7OztBQ3pYRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7Ozs7O0FDOVhEO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiJzY3JpcHRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMzEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGMzNDJkMjIzZTVmYzNlZWY1YmNhIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZShcIi4vX2ZhaWxzXCIpKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJhXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiA3O1xuICAgICAgfVxuICAgIH0pLmEgIT0gN1xuICApO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgY29yZSA9IChtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogXCIyLjUuMVwiIH0pO1xuaWYgKHR5cGVvZiBfX2UgPT0gXCJudW1iZXJcIikgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09IFwib2JqZWN0XCIgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKFwiLi9fYW4tb2JqZWN0XCIpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZShcIi4vX2llOC1kb20tZGVmaW5lXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZShcIi4vX3RvLXByaW1pdGl2ZVwiKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZShcIi4vX2Rlc2NyaXB0b3JzXCIpXG4gID8gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICAgICAgYW5PYmplY3QoTyk7XG4gICAgICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gICAgICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgICAgIGlmIChJRThfRE9NX0RFRklORSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvKiBlbXB0eSAqL1xuICAgICAgICB9XG4gICAgICBpZiAoXCJnZXRcIiBpbiBBdHRyaWJ1dGVzIHx8IFwic2V0XCIgaW4gQXR0cmlidXRlcylcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhXCIpO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIHJldHVybiBPO1xuICAgIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMi4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wMy0yMFQxODo1OVpcbiAqL1xuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG4gICAgLy8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cbiAgICAvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuICAgIC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuICAgIC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG4gICAgLy8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuICAgIC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnRcbiAgICAgID8gZmFjdG9yeShnbG9iYWwsIHRydWUpXG4gICAgICA6IGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICBpZiAoIXcuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWN0b3J5KHcpO1xuICAgICAgICB9O1xuICB9IGVsc2Uge1xuICAgIGZhY3RvcnkoZ2xvYmFsKTtcbiAgfVxuXG4gIC8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24od2luZG93LCBub0dsb2JhbCkge1xuICAvLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbiAgLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4gIC8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4gIC8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgYXJyID0gW107XG5cbiAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuICB2YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbiAgdmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbiAgdmFyIHB1c2ggPSBhcnIucHVzaDtcblxuICB2YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG4gIHZhciBjbGFzczJ0eXBlID0ge307XG5cbiAgdmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxuICB2YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICB2YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxuICB2YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuICB2YXIgc3VwcG9ydCA9IHt9O1xuXG4gIGZ1bmN0aW9uIERPTUV2YWwoY29kZSwgZG9jKSB7XG4gICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG4gICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXG4gICAgc2NyaXB0LnRleHQgPSBjb2RlO1xuICAgIGRvYy5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICB9XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbiAgLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuICB2YXIgdmVyc2lvbiA9IFwiMy4yLjFcIixcbiAgICAvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuICAgIGpRdWVyeSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICAvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcbiAgICAgIC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG4gICAgICByZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KHNlbGVjdG9yLCBjb250ZXh0KTtcbiAgICB9LFxuICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuICAgIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLFxuICAgIC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuICAgIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG4gICAgcmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nLFxuICAgIC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbiAgICBmY2FtZWxDYXNlID0gZnVuY3Rpb24oYWxsLCBsZXR0ZXIpIHtcbiAgICAgIHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbiAgICB9O1xuXG4gIGpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuICAgIGpxdWVyeTogdmVyc2lvbixcblxuICAgIGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cbiAgICAvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcbiAgICBsZW5ndGg6IDAsXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzbGljZS5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG4gICAgLy8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcbiAgICBnZXQ6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuICAgICAgaWYgKG51bSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG4gICAgICByZXR1cm4gbnVtIDwgMCA/IHRoaXNbbnVtICsgdGhpcy5sZW5ndGhdIDogdGhpc1tudW1dO1xuICAgIH0sXG5cbiAgICAvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG4gICAgLy8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG4gICAgcHVzaFN0YWNrOiBmdW5jdGlvbihlbGVtcykge1xuICAgICAgLy8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcbiAgICAgIHZhciByZXQgPSBqUXVlcnkubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyk7XG5cbiAgICAgIC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG4gICAgICByZXQucHJldk9iamVjdCA9IHRoaXM7XG5cbiAgICAgIC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuICAgIGVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4galF1ZXJ5LmVhY2godGhpcywgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBtYXA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXG4gICAgICAgIGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24oZWxlbSwgaSkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKGVsZW0sIGksIGVsZW0pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH0sXG5cbiAgICBmaXJzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcSgwKTtcbiAgICB9LFxuXG4gICAgbGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcSgtMSk7XG4gICAgfSxcblxuICAgIGVxOiBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIGogPSAraSArIChpIDwgMCA/IGxlbiA6IDApO1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGogPj0gMCAmJiBqIDwgbGVuID8gW3RoaXNbal1dIDogW10pO1xuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgfSxcblxuICAgIC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICAvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cbiAgICBwdXNoOiBwdXNoLFxuICAgIHNvcnQ6IGFyci5zb3J0LFxuICAgIHNwbGljZTogYXJyLnNwbGljZVxuICB9O1xuXG4gIGpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wdGlvbnMsXG4gICAgICBuYW1lLFxuICAgICAgc3JjLFxuICAgICAgY29weSxcbiAgICAgIGNvcHlJc0FycmF5LFxuICAgICAgY2xvbmUsXG4gICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICBpID0gMSxcbiAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICBkZWVwID0gZmFsc2U7XG5cbiAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBkZWVwID0gdGFyZ2V0O1xuXG4gICAgICAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV0gfHwge307XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgIHRhcmdldCA9IHt9O1xuICAgIH1cblxuICAgIC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgIGlmIChpID09PSBsZW5ndGgpIHtcbiAgICAgIHRhcmdldCA9IHRoaXM7XG4gICAgICBpLS07XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgaWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcbiAgICAgICAgZm9yIChuYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBzcmMgPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgY29weSA9IG9wdGlvbnNbbmFtZV07XG5cbiAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgaWYgKHRhcmdldCA9PT0gY29weSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZGVlcCAmJlxuICAgICAgICAgICAgY29weSAmJlxuICAgICAgICAgICAgKGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY29weSkpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5KSB7XG4gICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGpRdWVyeS5leHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgfSBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIGpRdWVyeS5leHRlbmQoe1xuICAgIC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuICAgIGV4cGFuZG86IFwialF1ZXJ5XCIgKyAodmVyc2lvbiArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSxcblxuICAgIC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG4gICAgaXNSZWFkeTogdHJ1ZSxcblxuICAgIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH0sXG5cbiAgICBub29wOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH0sXG5cbiAgICBpc1dpbmRvdzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuICAgIH0sXG5cbiAgICBpc051bWVyaWM6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgLy8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cbiAgICAgIC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcbiAgICAgIC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG4gICAgICB2YXIgdHlwZSA9IGpRdWVyeS50eXBlKG9iaik7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAodHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiKSAmJlxuICAgICAgICAvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcbiAgICAgICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuICAgICAgICAvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAgICAgICAgIWlzTmFOKG9iaiAtIHBhcnNlRmxvYXQob2JqKSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIHByb3RvLCBDdG9yO1xuXG4gICAgICAvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcbiAgICAgIC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuICAgICAgaWYgKCFvYmogfHwgdG9TdHJpbmcuY2FsbChvYmopICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcHJvdG8gPSBnZXRQcm90byhvYmopO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG4gICAgICBpZiAoIXByb3RvKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuICAgICAgQ3RvciA9IGhhc093bi5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBmblRvU3RyaW5nLmNhbGwoQ3RvcikgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcbiAgICAgIHZhciBuYW1lO1xuXG4gICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICB0eXBlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb2JqICsgXCJcIjtcbiAgICAgIH1cblxuICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBjbGFzczJ0eXBlW3RvU3RyaW5nLmNhbGwob2JqKV0gfHwgXCJvYmplY3RcIlxuICAgICAgICA6IHR5cGVvZiBvYmo7XG4gICAgfSxcblxuICAgIC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG4gICAgZ2xvYmFsRXZhbDogZnVuY3Rpb24oY29kZSkge1xuICAgICAgRE9NRXZhbChjb2RlKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcbiAgICAvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG4gICAgY2FtZWxDYXNlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShybXNQcmVmaXgsIFwibXMtXCIpLnJlcGxhY2UocmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSk7XG4gICAgfSxcblxuICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsZW5ndGgsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgICBsZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqW2ldLCBpLCBvYmpbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwob2JqW2ldLCBpLCBvYmpbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuICAgIHRyaW06IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0ID09IG51bGwgPyBcIlwiIDogKHRleHQgKyBcIlwiKS5yZXBsYWNlKHJ0cmltLCBcIlwiKTtcbiAgICB9LFxuXG4gICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuICAgIG1ha2VBcnJheTogZnVuY3Rpb24oYXJyLCByZXN1bHRzKSB7XG4gICAgICB2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgaWYgKGFyciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZShPYmplY3QoYXJyKSkpIHtcbiAgICAgICAgICBqUXVlcnkubWVyZ2UocmV0LCB0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID8gW2Fycl0gOiBhcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1c2guY2FsbChyZXQsIGFycik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgaW5BcnJheTogZnVuY3Rpb24oZWxlbSwgYXJyLCBpKSB7XG4gICAgICByZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbChhcnIsIGVsZW0sIGkpO1xuICAgIH0sXG5cbiAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgbWVyZ2U6IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgIHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIGkgPSBmaXJzdC5sZW5ndGg7XG5cbiAgICAgIGZvciAoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgZmlyc3RbaSsrXSA9IHNlY29uZFtqXTtcbiAgICAgIH1cblxuICAgICAgZmlyc3QubGVuZ3RoID0gaTtcblxuICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH0sXG5cbiAgICBncmVwOiBmdW5jdGlvbihlbGVtcywgY2FsbGJhY2ssIGludmVydCkge1xuICAgICAgdmFyIGNhbGxiYWNrSW52ZXJzZSxcbiAgICAgICAgbWF0Y2hlcyA9IFtdLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuICAgICAgICBjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cbiAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcbiAgICAgIC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayhlbGVtc1tpXSwgaSk7XG4gICAgICAgIGlmIChjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0KSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKGVsZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9LFxuXG4gICAgLy8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG4gICAgbWFwOiBmdW5jdGlvbihlbGVtcywgY2FsbGJhY2ssIGFyZykge1xuICAgICAgdmFyIGxlbmd0aCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICByZXQgPSBbXTtcblxuICAgICAgLy8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcbiAgICAgIGlmIChpc0FycmF5TGlrZShlbGVtcykpIHtcbiAgICAgICAgbGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBlbGVtcykge1xuICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbXNbaV0sIGksIGFyZyk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG4gICAgICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCByZXQpO1xuICAgIH0sXG5cbiAgICAvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcbiAgICBndWlkOiAxLFxuXG4gICAgLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4gICAgLy8gYXJndW1lbnRzLlxuICAgIHByb3h5OiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgdmFyIHRtcCwgYXJncywgcHJveHk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0bXAgPSBmbltjb250ZXh0XTtcbiAgICAgICAgY29udGV4dCA9IGZuO1xuICAgICAgICBmbiA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgLy8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcbiAgICAgIC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG4gICAgICBpZiAoIWpRdWVyeS5pc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW11bGF0ZWQgYmluZFxuICAgICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgIHByb3h5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgfTtcblxuICAgICAgLy8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG4gICAgICBwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH0sXG5cbiAgICBub3c6IERhdGUubm93LFxuXG4gICAgLy8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG4gICAgLy8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cbiAgICBzdXBwb3J0OiBzdXBwb3J0XG4gIH0pO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBqUXVlcnkuZm5bU3ltYm9sLml0ZXJhdG9yXSA9IGFycltTeW1ib2wuaXRlcmF0b3JdO1xuICB9XG5cbiAgLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG4gIGpRdWVyeS5lYWNoKFxuICAgIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdChcbiAgICAgIFwiIFwiXG4gICAgKSxcbiAgICBmdW5jdGlvbihpLCBuYW1lKSB7XG4gICAgICBjbGFzczJ0eXBlW1wiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIl0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICApO1xuXG4gIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xuICAgIC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcbiAgICAvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG4gICAgLy8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG4gICAgLy8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuICAgIHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuICAgICAgdHlwZSA9IGpRdWVyeS50eXBlKG9iaik7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyhvYmopKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGUgPT09IFwiYXJyYXlcIiB8fFxuICAgICAgbGVuZ3RoID09PSAwIHx8XG4gICAgICAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmIGxlbmd0aCAtIDEgaW4gb2JqKVxuICAgICk7XG4gIH1cbiAgdmFyIFNpenpsZSA9XG4gICAgLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA4LTA4XG4gKi9cbiAgICAoZnVuY3Rpb24od2luZG93KSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgc3VwcG9ydCxcbiAgICAgICAgRXhwcixcbiAgICAgICAgZ2V0VGV4dCxcbiAgICAgICAgaXNYTUwsXG4gICAgICAgIHRva2VuaXplLFxuICAgICAgICBjb21waWxlLFxuICAgICAgICBzZWxlY3QsXG4gICAgICAgIG91dGVybW9zdENvbnRleHQsXG4gICAgICAgIHNvcnRJbnB1dCxcbiAgICAgICAgaGFzRHVwbGljYXRlLFxuICAgICAgICAvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG4gICAgICAgIHNldERvY3VtZW50LFxuICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgZG9jRWxlbSxcbiAgICAgICAgZG9jdW1lbnRJc0hUTUwsXG4gICAgICAgIHJidWdneVFTQSxcbiAgICAgICAgcmJ1Z2d5TWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgY29udGFpbnMsXG4gICAgICAgIC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcbiAgICAgICAgZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcbiAgICAgICAgcHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuICAgICAgICBkaXJydW5zID0gMCxcbiAgICAgICAgZG9uZSA9IDAsXG4gICAgICAgIGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgICAgICB0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcbiAgICAgICAgY29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gICAgICAgIHNvcnRPcmRlciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEluc3RhbmNlIG1ldGhvZHNcbiAgICAgICAgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgICAgIGFyciA9IFtdLFxuICAgICAgICBwb3AgPSBhcnIucG9wLFxuICAgICAgICBwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuICAgICAgICBwdXNoID0gYXJyLnB1c2gsXG4gICAgICAgIHNsaWNlID0gYXJyLnNsaWNlLFxuICAgICAgICAvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAgICAgICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24obGlzdCwgZWxlbSkge1xuICAgICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaXN0W2ldID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIGJvb2xlYW5zID1cbiAgICAgICAgICBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG4gICAgICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuICAgICAgICB3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcbiAgICAgICAgaWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcbiAgICAgICAgLy8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG4gICAgICAgIGF0dHJpYnV0ZXMgPVxuICAgICAgICAgIFwiXFxcXFtcIiArXG4gICAgICAgICAgd2hpdGVzcGFjZSArXG4gICAgICAgICAgXCIqKFwiICtcbiAgICAgICAgICBpZGVudGlmaWVyICtcbiAgICAgICAgICBcIikoPzpcIiArXG4gICAgICAgICAgd2hpdGVzcGFjZSArXG4gICAgICAgICAgLy8gT3BlcmF0b3IgKGNhcHR1cmUgMilcbiAgICAgICAgICBcIiooWypeJHwhfl0/PSlcIiArXG4gICAgICAgICAgd2hpdGVzcGFjZSArXG4gICAgICAgICAgLy8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcbiAgICAgICAgICBcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICtcbiAgICAgICAgICBpZGVudGlmaWVyICtcbiAgICAgICAgICBcIikpfClcIiArXG4gICAgICAgICAgd2hpdGVzcGFjZSArXG4gICAgICAgICAgXCIqXFxcXF1cIixcbiAgICAgICAgcHNldWRvcyA9XG4gICAgICAgICAgXCI6KFwiICtcbiAgICAgICAgICBpZGVudGlmaWVyICtcbiAgICAgICAgICBcIikoPzpcXFxcKChcIiArXG4gICAgICAgICAgLy8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcbiAgICAgICAgICAvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcbiAgICAgICAgICBcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcbiAgICAgICAgICAvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcbiAgICAgICAgICBcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArXG4gICAgICAgICAgYXR0cmlidXRlcyArXG4gICAgICAgICAgXCIpKil8XCIgK1xuICAgICAgICAgIC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcbiAgICAgICAgICBcIi4qXCIgK1xuICAgICAgICAgIFwiKVxcXFwpfClcIixcbiAgICAgICAgLy8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuICAgICAgICByd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAod2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiksXG4gICAgICAgIHJ0cmltID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLFxuICAgICAgICAgIFwiZ1wiXG4gICAgICAgICksXG4gICAgICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcbiAgICAgICAgcmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCJcbiAgICAgICAgKSxcbiAgICAgICAgcmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLFxuICAgICAgICAgIFwiZ1wiXG4gICAgICAgICksXG4gICAgICAgIHJwc2V1ZG8gPSBuZXcgUmVnRXhwKHBzZXVkb3MpLFxuICAgICAgICByaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIpLFxuICAgICAgICBtYXRjaEV4cHIgPSB7XG4gICAgICAgICAgSUQ6IG5ldyBSZWdFeHAoXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiksXG4gICAgICAgICAgQ0xBU1M6IG5ldyBSZWdFeHAoXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIpLFxuICAgICAgICAgIFRBRzogbmV3IFJlZ0V4cChcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiKSxcbiAgICAgICAgICBBVFRSOiBuZXcgUmVnRXhwKFwiXlwiICsgYXR0cmlidXRlcyksXG4gICAgICAgICAgUFNFVURPOiBuZXcgUmVnRXhwKFwiXlwiICsgcHNldWRvcyksXG4gICAgICAgICAgQ0hJTEQ6IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArXG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICBcIiooPzooWystXXwpXCIgK1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgXCIqKFxcXFxkKyl8KSlcIiArXG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICBcIipcXFxcKXwpXCIsXG4gICAgICAgICAgICBcImlcIlxuICAgICAgICAgICksXG4gICAgICAgICAgYm9vbDogbmV3IFJlZ0V4cChcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiksXG4gICAgICAgICAgLy8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG4gICAgICAgICAgLy8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuICAgICAgICAgIG5lZWRzQ29udGV4dDogbmV3IFJlZ0V4cChcbiAgICAgICAgICAgIFwiXlwiICtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSArXG4gICAgICAgICAgICAgIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgK1xuICAgICAgICAgICAgICBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgK1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlICtcbiAgICAgICAgICAgICAgXCIqXFxcXCl8KSg/PVteLV18JClcIixcbiAgICAgICAgICAgIFwiaVwiXG4gICAgICAgICAgKVxuICAgICAgICB9LFxuICAgICAgICByaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcbiAgICAgICAgcmhlYWRlciA9IC9eaFxcZCQvaSxcbiAgICAgICAgcm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG4gICAgICAgIC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuICAgICAgICBycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG4gICAgICAgIHJzaWJsaW5nID0gL1srfl0vLFxuICAgICAgICAvLyBDU1MgZXNjYXBlc1xuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG4gICAgICAgIHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLFxuICAgICAgICAgIFwiaWdcIlxuICAgICAgICApLFxuICAgICAgICBmdW5lc2NhcGUgPSBmdW5jdGlvbihfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSkge1xuICAgICAgICAgIHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG4gICAgICAgICAgLy8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcbiAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG4gICAgICAgICAgLy8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG4gICAgICAgICAgcmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2VcbiAgICAgICAgICAgID8gZXNjYXBlZFxuICAgICAgICAgICAgOiBoaWdoIDwgMFxuICAgICAgICAgICAgICA/IC8vIEJNUCBjb2RlcG9pbnRcbiAgICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGhpZ2ggKyAweDEwMDAwKVxuICAgICAgICAgICAgICA6IC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuICAgICAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAgICAgICAoaGlnaCA+PiAxMCkgfCAweGQ4MDAsXG4gICAgICAgICAgICAgICAgICAoaGlnaCAmIDB4M2ZmKSB8IDB4ZGMwMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuICAgICAgICByY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG4gICAgICAgIGZjc3Nlc2NhcGUgPSBmdW5jdGlvbihjaCwgYXNDb2RlUG9pbnQpIHtcbiAgICAgICAgICBpZiAoYXNDb2RlUG9pbnQpIHtcbiAgICAgICAgICAgIC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcMFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcdUZGRkRcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGNoLnNsaWNlKDAsIC0xKSArXG4gICAgICAgICAgICAgIFwiXFxcXFwiICtcbiAgICAgICAgICAgICAgY2guY2hhckNvZGVBdChjaC5sZW5ndGggLSAxKS50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG4gICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgY2g7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFVzZWQgZm9yIGlmcmFtZXNcbiAgICAgICAgLy8gU2VlIHNldERvY3VtZW50KClcbiAgICAgICAgLy8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG4gICAgICAgIC8vIGVycm9yIGluIElFXG4gICAgICAgIHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZXREb2N1bWVudCgpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcbiAgICAgICAgICBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG4gICAgICAgICk7XG5cbiAgICAgIC8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG4gICAgICB0cnkge1xuICAgICAgICBwdXNoLmFwcGx5KFxuICAgICAgICAgIChhcnIgPSBzbGljZS5jYWxsKHByZWZlcnJlZERvYy5jaGlsZE5vZGVzKSksXG4gICAgICAgICAgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcbiAgICAgICAgKTtcbiAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZDw0LjBcbiAgICAgICAgLy8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuICAgICAgICBhcnJbcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHVzaCA9IHtcbiAgICAgICAgICBhcHBseTogYXJyLmxlbmd0aFxuICAgICAgICAgICAgPyAvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICBmdW5jdGlvbih0YXJnZXQsIGVscykge1xuICAgICAgICAgICAgICAgIHB1c2hfbmF0aXZlLmFwcGx5KHRhcmdldCwgc2xpY2UuY2FsbChlbHMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcbiAgICAgICAgICAgICAgZnVuY3Rpb24odGFyZ2V0LCBlbHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRhcmdldFtqKytdID0gZWxzW2krK10pKSB7fVxuICAgICAgICAgICAgICAgIHRhcmdldC5sZW5ndGggPSBqIC0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBTaXp6bGUoc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcbiAgICAgICAgdmFyIG0sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBlbGVtLFxuICAgICAgICAgIG5pZCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBncm91cHMsXG4gICAgICAgICAgbmV3U2VsZWN0b3IsXG4gICAgICAgICAgbmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuICAgICAgICAgIC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcbiAgICAgICAgICBub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgIXNlbGVjdG9yIHx8XG4gICAgICAgICAgKG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG4gICAgICAgIGlmICghc2VlZCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MpICE9PVxuICAgICAgICAgICAgZG9jdW1lbnRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHNldERvY3VtZW50KGNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuICAgICAgICAgIGlmIChkb2N1bWVudElzSFRNTCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2RcbiAgICAgICAgICAgIC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcbiAgICAgICAgICAgIGlmIChub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKHNlbGVjdG9yKSkpIHtcbiAgICAgICAgICAgICAgLy8gSUQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgaWYgKChtID0gbWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9jdW1lbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChtKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5pZCA9PT0gbSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQobSkpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKGNvbnRleHQsIGVsZW0pICYmXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uaWQgPT09IG1cbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFR5cGUgc2VsZWN0b3JcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3RvcikpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xhc3Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAobSA9IG1hdGNoWzNdKSAmJlxuICAgICAgICAgICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuICAgICAgICAgICAgICAgIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShtKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzdXBwb3J0LnFzYSAmJlxuICAgICAgICAgICAgICAhY29tcGlsZXJDYWNoZVtzZWxlY3RvciArIFwiIFwiXSAmJlxuICAgICAgICAgICAgICAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3Qoc2VsZWN0b3IpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cbiAgICAgICAgICAgICAgICAvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcbiAgICAgICAgICAgICAgICAvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OFxuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKFwiaWRcIikpKSB7XG4gICAgICAgICAgICAgICAgICBuaWQgPSBuaWQucmVwbGFjZShyY3NzZXNjYXBlLCBmY3NzZXNjYXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCAobmlkID0gZXhwYW5kbykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGdyb3VwcyA9IHRva2VuaXplKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBpID0gZ3JvdXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICBncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3Rvcihncm91cHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcblxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgPVxuICAgICAgICAgICAgICAgICAgKHJzaWJsaW5nLnRlc3Qoc2VsZWN0b3IpICYmXG4gICAgICAgICAgICAgICAgICAgIHRlc3RDb250ZXh0KGNvbnRleHQucGFyZW50Tm9kZSkpIHx8XG4gICAgICAgICAgICAgICAgICBjb250ZXh0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG5ld1NlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgbmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKG5ld1NlbGVjdG9yKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChxc2FFcnJvcikge1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBpZiAobmlkID09PSBleHBhbmRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsIG90aGVyc1xuICAgICAgICByZXR1cm4gc2VsZWN0KHNlbGVjdG9yLnJlcGxhY2UocnRyaW0sIFwiJDFcIiksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICAgICAgICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gICAgICAgKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBjYWNoZShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcbiAgICAgICAgICBpZiAoa2V5cy5wdXNoKGtleSArIFwiIFwiKSA+IEV4cHIuY2FjaGVMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleXMuc2hpZnQoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoY2FjaGVba2V5ICsgXCIgXCJdID0gdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gbWFya0Z1bmN0aW9uKGZuKSB7XG4gICAgICAgIGZuW2V4cGFuZG9dID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGFzc2VydChmbikge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gISFmbihlbCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuICAgICAgICAgIGVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBhZGRIYW5kbGUoYXR0cnMsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcbiAgICAgICAgICBpID0gYXJyLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgRXhwci5hdHRySGFuZGxlW2FycltpXV0gPSBoYW5kbGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBhXG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBzaWJsaW5nQ2hlY2soYSwgYikge1xuICAgICAgICB2YXIgY3VyID0gYiAmJiBhLFxuICAgICAgICAgIGRpZmYgPVxuICAgICAgICAgICAgY3VyICYmXG4gICAgICAgICAgICBhLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICBiLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICBhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuICAgICAgICAvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICB3aGlsZSAoKGN1ciA9IGN1ci5uZXh0U2libGluZykpIHtcbiAgICAgICAgICAgIGlmIChjdXIgPT09IGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhID8gMSA6IC0xO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyh0eXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKGRpc2FibGVkKSB7XG4gICAgICAgIC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgIC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG4gICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG4gICAgICAgICAgaWYgKFwiZm9ybVwiIGluIGVsZW0pIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcbiAgICAgICAgICAgIC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG4gICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG4gICAgICAgICAgICAvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuICAgICAgICAgICAgLy8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuICAgICAgICAgICAgLy8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG4gICAgICAgICAgICAvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG4gICAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG4gICAgICAgICAgICAgIGlmIChcImxhYmVsXCIgaW4gZWxlbSkge1xuICAgICAgICAgICAgICAgIGlmIChcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuICAgICAgICAgICAgICAvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcbiAgICAgICAgICAgICAgICAvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuICAgICAgICAgICAgICAgIC8qIGpzaGludCAtVzAxOCAqL1xuICAgICAgICAgICAgICAgIChlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWRBbmNlc3RvcihlbGVtKSA9PT0gZGlzYWJsZWQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuICAgICAgICAgICAgLy8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuICAgICAgICAgICAgLy8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG4gICAgICAgICAgICAvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgICAgICB9IGVsc2UgaWYgKFwibGFiZWxcIiBpbiBlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmbikge1xuICAgICAgICByZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKGFyZ3VtZW50KSB7XG4gICAgICAgICAgYXJndW1lbnQgPSArYXJndW1lbnQ7XG4gICAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbihzZWVkLCBtYXRjaGVzKSB7XG4gICAgICAgICAgICB2YXIgaixcbiAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzID0gZm4oW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCksXG4gICAgICAgICAgICAgIGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgaWYgKHNlZWRbKGogPSBtYXRjaEluZGV4ZXNbaV0pXSkge1xuICAgICAgICAgICAgICAgIHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICAgICAgICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHRlc3RDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBjb250ZXh0ICYmXG4gICAgICAgICAgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG4gICAgICBzdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZXRlY3RzIFhNTCBub2Rlc1xuICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAgICAgICAqL1xuICAgICAgaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3RcbiAgICAgICAgLy8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG4gICAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPVxuICAgICAgICAgIGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgICAqL1xuICAgICAgc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBoYXNDb21wYXJlLFxuICAgICAgICAgIHN1YldpbmRvdyxcbiAgICAgICAgICBkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgaWYgKGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcbiAgICAgICAgZG9jdW1lbnQgPSBkb2M7XG4gICAgICAgIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKGRvY3VtZW50KTtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG4gICAgICAgIC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcbiAgICAgICAgICAoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmXG4gICAgICAgICAgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG4gICAgICAgICAgaWYgKHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG4gICAgICAgICAgfSBlbHNlIGlmIChzdWJXaW5kb3cuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIHN1YldpbmRvdy5hdHRhY2hFdmVudChcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuICAgICAgICBzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICBlbC5jbGFzc05hbWUgPSBcImlcIjtcbiAgICAgICAgICByZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuICAgICAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSk7XG4gICAgICAgICAgcmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdChcbiAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUU8MTBcbiAgICAgICAgLy8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG4gICAgICAgIC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuICAgICAgICAvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3RcbiAgICAgICAgc3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChlbCkuaWQgPSBleHBhbmRvO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHxcbiAgICAgICAgICAgICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShleHBhbmRvKS5sZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcbiAgICAgICAgaWYgKHN1cHBvcnQuZ2V0QnlJZCkge1xuICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKGlkLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPyBbZWxlbV0gOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcbiAgICAgICAgICBFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKGlkLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGUsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBlbGVtcyxcbiAgICAgICAgICAgICAgICBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcbiAgICAgICAgICAgICAgICBlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1zW2krK10pKSB7XG4gICAgICAgICAgICAgICAgICBub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGFnXG4gICAgICAgIEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWVcbiAgICAgICAgICA/IGZ1bmN0aW9uKHRhZywgY29udGV4dCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xuXG4gICAgICAgICAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5xc2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHRhZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGZ1bmN0aW9uKHRhZywgY29udGV4dCkge1xuICAgICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgICB0bXAgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcblxuICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG4gICAgICAgICAgICAgIGlmICh0YWcgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gcmVzdWx0c1tpKytdKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2xhc3NcbiAgICAgICAgRXhwci5maW5kW1wiQ0xBU1NcIl0gPVxuICAgICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuICAgICAgICAgIGZ1bmN0aW9uKGNsYXNzTmFtZSwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgLyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICAgICAgLy8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG4gICAgICAgIC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG4gICAgICAgIHJidWdneU1hdGNoZXMgPSBbXTtcblxuICAgICAgICAvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuICAgICAgICAvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3JcbiAgICAgICAgLy8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuICAgICAgICAvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG4gICAgICAgIHJidWdneVFTQSA9IFtdO1xuXG4gICAgICAgIGlmICgoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCkpKSB7XG4gICAgICAgICAgLy8gQnVpbGQgUVNBIHJlZ2V4XG4gICAgICAgICAgLy8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuICAgICAgICAgIGFzc2VydChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgLy8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuICAgICAgICAgICAgLy8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG4gICAgICAgICAgICAvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcbiAgICAgICAgICAgIC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcbiAgICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZWwpLmlubmVySFRNTCA9XG4gICAgICAgICAgICAgIFwiPGEgaWQ9J1wiICtcbiAgICAgICAgICAgICAgZXhwYW5kbyArXG4gICAgICAgICAgICAgIFwiJz48L2E+XCIgK1xuICAgICAgICAgICAgICBcIjxzZWxlY3QgaWQ9J1wiICtcbiAgICAgICAgICAgICAgZXhwYW5kbyArXG4gICAgICAgICAgICAgIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcbiAgICAgICAgICAgICAgXCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG4gICAgICAgICAgICAvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG4gICAgICAgICAgICAvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOFxuICAgICAgICAgICAgLy8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXG4gICAgICAgICAgICAgICAgXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcbiAgICAgICAgICAgIGlmICghZWwucXVlcnlTZWxlY3RvckFsbChcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG4gICAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuICAgICAgICAgICAgaWYgKCFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG4gICAgICAgICAgICAvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG4gICAgICAgICAgICBpZiAoIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9XG4gICAgICAgICAgICAgIFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG4gICAgICAgICAgICAgIFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcbiAgICAgICAgICAgIC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGlucHV0KS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwiRFwiKTtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU4XG4gICAgICAgICAgICAvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGlmIChlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG4gICAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU5LTExK1xuICAgICAgICAgICAgLy8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG4gICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGVsKS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3NcbiAgICAgICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdChcbiAgICAgICAgICAgIChtYXRjaGVzID1cbiAgICAgICAgICAgICAgZG9jRWxlbS5tYXRjaGVzIHx8XG4gICAgICAgICAgICAgIGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgIGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgIGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICBkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKVxuICAgICAgICAgICkpXG4gICAgICAgICkge1xuICAgICAgICAgIGFzc2VydChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgICAgICAvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuICAgICAgICAgICAgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbChlbCwgXCIqXCIpO1xuXG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG4gICAgICAgICAgICBtYXRjaGVzLmNhbGwoZWwsIFwiW3MhPScnXTp4XCIpO1xuICAgICAgICAgICAgcmJ1Z2d5TWF0Y2hlcy5wdXNoKFwiIT1cIiwgcHNldWRvcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpKTtcbiAgICAgICAgcmJ1Z2d5TWF0Y2hlcyA9XG4gICAgICAgICAgcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cChyYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpKTtcblxuICAgICAgICAvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4gICAgICAgIGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbik7XG5cbiAgICAgICAgLy8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG4gICAgICAgIC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuICAgICAgICAvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuICAgICAgICBjb250YWlucyA9XG4gICAgICAgICAgaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoZG9jRWxlbS5jb250YWlucylcbiAgICAgICAgICAgID8gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG4gICAgICAgICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgYSA9PT0gYnVwIHx8XG4gICAgICAgICAgICAgICAgICAhIShcbiAgICAgICAgICAgICAgICAgICAgYnVwICYmXG4gICAgICAgICAgICAgICAgICAgIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAoYWRvd24uY29udGFpbnNcbiAgICAgICAgICAgICAgICAgICAgICA/IGFkb3duLmNvbnRhaW5zKGJ1cClcbiAgICAgICAgICAgICAgICAgICAgICA6IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYnVwKSAmIDE2KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoKGIgPSBiLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiID09PSBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgIC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4gICAgICAgIC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcbiAgICAgICAgc29ydE9yZGVyID0gaGFzQ29tcGFyZVxuICAgICAgICAgID8gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuICAgICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICAgICAgICAgIHZhciBjb21wYXJlID1cbiAgICAgICAgICAgICAgICAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuICAgICAgICAgICAgICBpZiAoY29tcGFyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuICAgICAgICAgICAgICBjb21wYXJlID1cbiAgICAgICAgICAgICAgICAoYS5vd25lckRvY3VtZW50IHx8IGEpID09PSAoYi5vd25lckRvY3VtZW50IHx8IGIpXG4gICAgICAgICAgICAgICAgICA/IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYilcbiAgICAgICAgICAgICAgICAgIDogLy8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIDE7XG5cbiAgICAgICAgICAgICAgLy8gRGlzY29ubmVjdGVkIG5vZGVzXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjb21wYXJlICYgMSB8fFxuICAgICAgICAgICAgICAgICghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiZcbiAgICAgICAgICAgICAgICAgIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkgPT09IGNvbXBhcmUpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIGEgPT09IGRvY3VtZW50IHx8XG4gICAgICAgICAgICAgICAgICAoYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgYiA9PT0gZG9jdW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgIChiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJlxuICAgICAgICAgICAgICAgICAgICBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gc29ydElucHV0XG4gICAgICAgICAgICAgICAgICA/IGluZGV4T2Yoc29ydElucHV0LCBhKSAtIGluZGV4T2Yoc29ydElucHV0LCBiKVxuICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG4gICAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBjdXIsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgYXVwID0gYS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIGJ1cCA9IGIucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICBhcCA9IFthXSxcbiAgICAgICAgICAgICAgICBicCA9IFtiXTtcblxuICAgICAgICAgICAgICAvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICBpZiAoIWF1cCB8fCAhYnVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgICA6IGIgPT09IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICA6IGF1cFxuICAgICAgICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICAgICAgICA6IGJ1cFxuICAgICAgICAgICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNvcnRJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGluZGV4T2Yoc29ydElucHV0LCBhKSAtIGluZGV4T2Yoc29ydElucHV0LCBiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF1cCA9PT0gYnVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayhhLCBiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG4gICAgICAgICAgICAgIGN1ciA9IGE7XG4gICAgICAgICAgICAgIHdoaWxlICgoY3VyID0gY3VyLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgYXAudW5zaGlmdChjdXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1ciA9IGI7XG4gICAgICAgICAgICAgIHdoaWxlICgoY3VyID0gY3VyLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgYnAudW5zaGlmdChjdXIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcbiAgICAgICAgICAgICAgd2hpbGUgKGFwW2ldID09PSBicFtpXSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICAgICAgPyAvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3JcbiAgICAgICAgICAgICAgICAgIHNpYmxpbmdDaGVjayhhcFtpXSwgYnBbaV0pXG4gICAgICAgICAgICAgICAgOiAvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3RcbiAgICAgICAgICAgICAgICAgIGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6IGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDogMDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgfTtcblxuICAgICAgU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbihleHByLCBlbGVtZW50cykge1xuICAgICAgICByZXR1cm4gU2l6emxlKGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihlbGVtLCBleHByKSB7XG4gICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgICAgICBpZiAoKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBzZXREb2N1bWVudChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuICAgICAgICBleHByID0gZXhwci5yZXBsYWNlKHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJlxuICAgICAgICAgIGRvY3VtZW50SXNIVE1MICYmXG4gICAgICAgICAgIWNvbXBpbGVyQ2FjaGVbZXhwciArIFwiIFwiXSAmJlxuICAgICAgICAgICghcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KGV4cHIpKSAmJlxuICAgICAgICAgICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdChleHByKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXQgPSBtYXRjaGVzLmNhbGwoZWxlbSwgZXhwcik7XG5cbiAgICAgICAgICAgIC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcmV0IHx8XG4gICAgICAgICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcbiAgICAgICAgICAgICAgLy8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgaW4gSUUgOVxuICAgICAgICAgICAgICAoZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU2l6emxlKGV4cHIsIGRvY3VtZW50LCBudWxsLCBbZWxlbV0pLmxlbmd0aCA+IDA7XG4gICAgICB9O1xuXG4gICAgICBTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbihjb250ZXh0LCBlbGVtKSB7XG4gICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuICAgICAgICBpZiAoKGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0KSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBzZXREb2N1bWVudChjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGFpbnMoY29udGV4dCwgZWxlbSk7XG4gICAgICB9O1xuXG4gICAgICBTaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKGVsZW0sIG5hbWUpIHtcbiAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG4gICAgICAgIGlmICgoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgIHNldERvY3VtZW50KGVsZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZuID0gRXhwci5hdHRySGFuZGxlW25hbWUudG9Mb3dlckNhc2UoKV0sXG4gICAgICAgICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG4gICAgICAgICAgdmFsID1cbiAgICAgICAgICAgIGZuICYmIGhhc093bi5jYWxsKEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgICA/IGZuKGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTClcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB2YWxcbiAgICAgICAgICA6IHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUxcbiAgICAgICAgICAgID8gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSlcbiAgICAgICAgICAgIDogKHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZFxuICAgICAgICAgICAgICA/IHZhbC52YWx1ZVxuICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBTaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgIHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZShyY3NzZXNjYXBlLCBmY3NzZXNjYXBlKTtcbiAgICAgIH07XG5cbiAgICAgIFNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyk7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAgICAgICAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gICAgICAgKi9cbiAgICAgIFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICBkdXBsaWNhdGVzID0gW10sXG4gICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgLy8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuICAgICAgICBoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuICAgICAgICBzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoMCk7XG4gICAgICAgIHJlc3VsdHMuc29ydChzb3J0T3JkZXIpO1xuXG4gICAgICAgIGlmIChoYXNEdXBsaWNhdGUpIHtcbiAgICAgICAgICB3aGlsZSAoKGVsZW0gPSByZXN1bHRzW2krK10pKSB7XG4gICAgICAgICAgICBpZiAoZWxlbSA9PT0gcmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICBqID0gZHVwbGljYXRlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICByZXN1bHRzLnNwbGljZShkdXBsaWNhdGVzW2pdLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcbiAgICAgICAgc29ydElucHV0ID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICAgICAgICovXG4gICAgICBnZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIHZhciBub2RlLFxuICAgICAgICAgIHJldCA9IFwiXCIsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG4gICAgICAgIGlmICghbm9kZVR5cGUpIHtcbiAgICAgICAgICAvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuICAgICAgICAgIHdoaWxlICgobm9kZSA9IGVsZW1baSsrXSkpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG4gICAgICAgICAgICByZXQgKz0gZ2V0VGV4dChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuICAgICAgICAgIC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG4gICAgICAgICAgaWYgKHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG4gICAgICAgICAgICBmb3IgKGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KGVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcblxuICAgICAgRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG4gICAgICAgIC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuICAgICAgICBjYWNoZUxlbmd0aDogNTAsXG5cbiAgICAgICAgY3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cbiAgICAgICAgbWF0Y2g6IG1hdGNoRXhwcixcblxuICAgICAgICBhdHRySGFuZGxlOiB7fSxcblxuICAgICAgICBmaW5kOiB7fSxcblxuICAgICAgICByZWxhdGl2ZToge1xuICAgICAgICAgIFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG4gICAgICAgICAgXCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuICAgICAgICAgIFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcbiAgICAgICAgICBcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByZUZpbHRlcjoge1xuICAgICAgICAgIEFUVFI6IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuXG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuICAgICAgICAgICAgbWF0Y2hbM10gPSAobWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIikucmVwbGFjZShcbiAgICAgICAgICAgICAgcnVuZXNjYXBlLFxuICAgICAgICAgICAgICBmdW5lc2NhcGVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFsyXSA9PT0gXCJ+PVwiKSB7XG4gICAgICAgICAgICAgIG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMCwgNCk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIENISUxEOiBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgICAgLyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cbiAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoWzFdLnNsaWNlKDAsIDMpID09PSBcIm50aFwiKSB7XG4gICAgICAgICAgICAgIC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG4gICAgICAgICAgICAgIGlmICghbWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IobWF0Y2hbMF0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG4gICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcbiAgICAgICAgICAgICAgbWF0Y2hbNF0gPSArKG1hdGNoWzRdXG4gICAgICAgICAgICAgICAgPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKVxuICAgICAgICAgICAgICAgIDogMiAqIChtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIpKTtcbiAgICAgICAgICAgICAgbWF0Y2hbNV0gPSArKG1hdGNoWzddICsgbWF0Y2hbOF0gfHwgbWF0Y2hbM10gPT09IFwib2RkXCIpO1xuXG4gICAgICAgICAgICAgIC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IobWF0Y2hbMF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIFBTRVVETzogZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBleGNlc3MsXG4gICAgICAgICAgICAgIHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdChtYXRjaFswXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgbWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG4gICAgICAgICAgICAgIC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICB1bnF1b3RlZCAmJlxuICAgICAgICAgICAgICBycHNldWRvLnRlc3QodW5xdW90ZWQpICYmXG4gICAgICAgICAgICAgIC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG4gICAgICAgICAgICAgIChleGNlc3MgPSB0b2tlbml6ZSh1bnF1b3RlZCwgdHJ1ZSkpICYmXG4gICAgICAgICAgICAgIC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuICAgICAgICAgICAgICAoZXhjZXNzID1cbiAgICAgICAgICAgICAgICB1bnF1b3RlZC5pbmRleE9mKFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MpIC1cbiAgICAgICAgICAgICAgICB1bnF1b3RlZC5sZW5ndGgpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcbiAgICAgICAgICAgICAgbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSgwLCBleGNlc3MpO1xuICAgICAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKDAsIGV4Y2Vzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICBUQUc6IGZ1bmN0aW9uKG5vZGVOYW1lU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3JcbiAgICAgICAgICAgICAgLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpXG4gICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiXG4gICAgICAgICAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIENMQVNTOiBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVtjbGFzc05hbWUgKyBcIiBcIl07XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHBhdHRlcm4gfHxcbiAgICAgICAgICAgICAgKChwYXR0ZXJuID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIlxuICAgICAgICAgICAgICApKSAmJlxuICAgICAgICAgICAgICAgIGNsYXNzQ2FjaGUoY2xhc3NOYW1lLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KFxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIEFUVFI6IGZ1bmN0aW9uKG5hbWUsIG9wZXJhdG9yLCBjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKGVsZW0sIG5hbWUpO1xuXG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghb3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBcIlwiO1xuXG4gICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCJcbiAgICAgICAgICAgICAgICA/IHJlc3VsdCA9PT0gY2hlY2tcbiAgICAgICAgICAgICAgICA6IG9wZXJhdG9yID09PSBcIiE9XCJcbiAgICAgICAgICAgICAgICAgID8gcmVzdWx0ICE9PSBjaGVja1xuICAgICAgICAgICAgICAgICAgOiBvcGVyYXRvciA9PT0gXCJePVwiXG4gICAgICAgICAgICAgICAgICAgID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoY2hlY2spID09PSAwXG4gICAgICAgICAgICAgICAgICAgIDogb3BlcmF0b3IgPT09IFwiKj1cIlxuICAgICAgICAgICAgICAgICAgICAgID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoY2hlY2spID4gLTFcbiAgICAgICAgICAgICAgICAgICAgICA6IG9wZXJhdG9yID09PSBcIiQ9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKC1jaGVjay5sZW5ndGgpID09PSBjaGVja1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcGVyYXRvciA9PT0gXCJ+PVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlcGxhY2UocndoaXRlc3BhY2UsIFwiIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuaW5kZXhPZihjaGVjaykgPiAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG9wZXJhdG9yID09PSBcInw9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdCA9PT0gY2hlY2sgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zbGljZSgwLCBjaGVjay5sZW5ndGggKyAxKSA9PT0gY2hlY2sgKyBcIi1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBDSElMRDogZnVuY3Rpb24odHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0KSB7XG4gICAgICAgICAgICB2YXIgc2ltcGxlID0gdHlwZS5zbGljZSgwLCAzKSAhPT0gXCJudGhcIixcbiAgICAgICAgICAgICAgZm9yd2FyZCA9IHR5cGUuc2xpY2UoLTQpICE9PSBcImxhc3RcIixcbiAgICAgICAgICAgICAgb2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cbiAgICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwXG4gICAgICAgICAgICAgID8gLy8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBkaXIgPVxuICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgIHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuICAgICAgICAgICAgICAgICAgICBkaWZmID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlW2Rpcl0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZlR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5vZGUubm9kZVR5cGUgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGlyID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IFtmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZCAmJiB1c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IG5vZGVbZXhwYW5kb10gfHwgKG5vZGVbZXhwYW5kb10gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZVtub2RlLnVuaXF1ZUlEXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IHVuaXF1ZUNhY2hlW3R5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbMl07XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1tub2RlSW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlW2Rpcl0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQucG9wKCkpXG4gICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGVbdHlwZV0gPSBbZGlycnVucywgbm9kZUluZGV4LCBkaWZmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID0gbm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlID0gdW5pcXVlQ2FjaGVbdHlwZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgLy8geG1sIDpudGgtY2hpbGQoLi4uKVxuICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChub2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlW2Rpcl0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LnBvcCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAob2ZUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBub2RlLm5vZGVUeXBlID09PSAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZGlmZlxuICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG91dGVyQ2FjaGVbbm9kZS51bmlxdWVJRF0gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlW3R5cGVdID0gW2RpcnJ1bnMsIGRpZmZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuICAgICAgICAgICAgICAgICAgICBkaWZmIC09IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgZGlmZiA9PT0gZmlyc3QgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIFBTRVVETzogZnVuY3Rpb24ocHNldWRvLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgLy8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG4gICAgICAgICAgICAvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuICAgICAgICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgICAgIGZuID1cbiAgICAgICAgICAgICAgICBFeHByLnBzZXVkb3NbcHNldWRvXSB8fFxuICAgICAgICAgICAgICAgIEV4cHIuc2V0RmlsdGVyc1twc2V1ZG8udG9Mb3dlckNhc2UoKV0gfHxcbiAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvKTtcblxuICAgICAgICAgICAgLy8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuICAgICAgICAgICAgLy8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcbiAgICAgICAgICAgIGlmIChmbltleHBhbmRvXSkge1xuICAgICAgICAgICAgICByZXR1cm4gZm4oYXJndW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcbiAgICAgICAgICAgIGlmIChmbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBbcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50XTtcbiAgICAgICAgICAgICAgcmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShwc2V1ZG8udG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICAgICAgICA/IG1hcmtGdW5jdGlvbihmdW5jdGlvbihzZWVkLCBtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHgsXG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGZuKHNlZWQsIGFyZ3VtZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpbmRleE9mKHNlZWQsIG1hdGNoZWRbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgIHNlZWRbaWR4XSA9ICEobWF0Y2hlc1tpZHhdID0gbWF0Y2hlZFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihlbGVtLCAwLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHNldWRvczoge1xuICAgICAgICAgIC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuICAgICAgICAgIG5vdDogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcbiAgICAgICAgICAgIC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gW10sXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgICAgICAgbWF0Y2hlciA9IGNvbXBpbGUoc2VsZWN0b3IucmVwbGFjZShydHJpbSwgXCIkMVwiKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyW2V4cGFuZG9dXG4gICAgICAgICAgICAgID8gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IG1hdGNoZXIoc2VlZCwgbnVsbCwgeG1sLCBbXSksXG4gICAgICAgICAgICAgICAgICAgIGkgPSBzZWVkLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSB1bm1hdGNoZWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgOiBmdW5jdGlvbihlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgICAgIGlucHV0WzBdID0gZWxlbTtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZXIoaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuICAgICAgICAgICAgICAgICAgaW5wdXRbMF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksXG5cbiAgICAgICAgICBoYXM6IG1hcmtGdW5jdGlvbihmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZShzZWxlY3RvciwgZWxlbSkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksXG5cbiAgICAgICAgICBjb250YWluczogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KGVsZW0pKS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICkgPiAtMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuICAgICAgICAgIC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG4gICAgICAgICAgLy8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcbiAgICAgICAgICAvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuICAgICAgICAgIC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICAgIC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG4gICAgICAgICAgbGFuZzogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgICAgIC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcbiAgICAgICAgICAgIGlmICghcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpKSB7XG4gICAgICAgICAgICAgIFNpenpsZS5lcnJvcihcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYW5nID0gbGFuZy5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1MYW5nO1xuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUxcbiAgICAgICAgICAgICAgICAgICAgPyBlbGVtLmxhbmdcbiAgICAgICAgICAgICAgICAgICAgOiBlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZihsYW5nICsgXCItXCIpID09PSAwXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSB3aGlsZSAoKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgLy8gTWlzY2VsbGFuZW91c1xuICAgICAgICAgIHRhcmdldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgdmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG4gICAgICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKDEpID09PSBlbGVtLmlkO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICByb290OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJlxuICAgICAgICAgICAgICAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gQm9vbGVhbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgZW5hYmxlZDogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oZmFsc2UpLFxuICAgICAgICAgIGRpc2FibGVkOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyh0cnVlKSxcblxuICAgICAgICAgIGNoZWNrZWQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcbiAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fFxuICAgICAgICAgICAgICAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2VsZWN0ZWQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgIC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcbiAgICAgICAgICAgIC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcbiAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBDb250ZW50c1xuICAgICAgICAgIGVtcHR5OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuICAgICAgICAgICAgLy8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuICAgICAgICAgICAgLy8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcbiAgICAgICAgICAgIC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cbiAgICAgICAgICAgIGZvciAoZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPCA2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcGFyZW50OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKGVsZW0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBFbGVtZW50L2lucHV0IHR5cGVzXG4gICAgICAgICAgaGVhZGVyOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gcmhlYWRlci50ZXN0KGVsZW0ubm9kZU5hbWUpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHJpbnB1dHMudGVzdChlbGVtLm5vZGVOYW1lKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgYnV0dG9uOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiKSB8fCBuYW1lID09PSBcImJ1dHRvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB0ZXh0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgICB2YXIgYXR0cjtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG4gICAgICAgICAgICAgIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OFxuICAgICAgICAgICAgICAvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuICAgICAgICAgICAgICAoKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuICAgICAgICAgIGZpcnN0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFswXTtcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIGxhc3Q6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24obWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGVuZ3RoIC0gMV07XG4gICAgICAgICAgfSksXG5cbiAgICAgICAgICBlcTogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbihtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudF07XG4gICAgICAgICAgfSksXG5cbiAgICAgICAgICBldmVuOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKG1hdGNoSW5kZXhlcywgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIG9kZDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbihtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XG4gICAgICAgICAgfSksXG5cbiAgICAgICAgICBsdDogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbihtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcbiAgICAgICAgICAgIGZvciAoOyAtLWkgPj0gMDsgKSB7XG4gICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICB9KSxcblxuICAgICAgICAgIGd0OiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xuICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuICAgICAgICAgICAgZm9yICg7ICsraSA8IGxlbmd0aDsgKSB7XG4gICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBFeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuICAgICAgLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbiAgICAgIGZvciAoaSBpbiB7XG4gICAgICAgIHJhZGlvOiB0cnVlLFxuICAgICAgICBjaGVja2JveDogdHJ1ZSxcbiAgICAgICAgZmlsZTogdHJ1ZSxcbiAgICAgICAgcGFzc3dvcmQ6IHRydWUsXG4gICAgICAgIGltYWdlOiB0cnVlXG4gICAgICB9KSB7XG4gICAgICAgIEV4cHIucHNldWRvc1tpXSA9IGNyZWF0ZUlucHV0UHNldWRvKGkpO1xuICAgICAgfVxuICAgICAgZm9yIChpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9KSB7XG4gICAgICAgIEV4cHIucHNldWRvc1tpXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyhpKTtcbiAgICAgIH1cblxuICAgICAgLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG4gICAgICBmdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbiAgICAgIHNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuICAgICAgRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxuICAgICAgdG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbihzZWxlY3RvciwgcGFyc2VPbmx5KSB7XG4gICAgICAgIHZhciBtYXRjaGVkLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHNvRmFyLFxuICAgICAgICAgIGdyb3VwcyxcbiAgICAgICAgICBwcmVGaWx0ZXJzLFxuICAgICAgICAgIGNhY2hlZCA9IHRva2VuQ2FjaGVbc2VsZWN0b3IgKyBcIiBcIl07XG5cbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgc29GYXIgPSBzZWxlY3RvcjtcbiAgICAgICAgZ3JvdXBzID0gW107XG4gICAgICAgIHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuICAgICAgICB3aGlsZSAoc29GYXIpIHtcbiAgICAgICAgICAvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG4gICAgICAgICAgaWYgKCFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKHNvRmFyKSkpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuICAgICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoWzBdLmxlbmd0aCkgfHwgc29GYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncm91cHMucHVzaCgodG9rZW5zID0gW10pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBDb21iaW5hdG9yc1xuICAgICAgICAgIGlmICgobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyhzb0ZhcikpKSB7XG4gICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoZWQsXG4gICAgICAgICAgICAgIC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuICAgICAgICAgICAgICB0eXBlOiBtYXRjaFswXS5yZXBsYWNlKHJ0cmltLCBcIiBcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaGVkLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRmlsdGVyc1xuICAgICAgICAgIGZvciAodHlwZSBpbiBFeHByLmZpbHRlcikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAobWF0Y2ggPSBtYXRjaEV4cHJbdHlwZV0uZXhlYyhzb0ZhcikpICYmXG4gICAgICAgICAgICAgICghcHJlRmlsdGVyc1t0eXBlXSB8fCAobWF0Y2ggPSBwcmVGaWx0ZXJzW3R5cGVdKG1hdGNoKSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IG1hdGNoXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuICAgICAgICAvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG4gICAgICAgIHJldHVybiBwYXJzZU9ubHlcbiAgICAgICAgICA/IHNvRmFyLmxlbmd0aFxuICAgICAgICAgIDogc29GYXJcbiAgICAgICAgICAgID8gU2l6emxlLmVycm9yKHNlbGVjdG9yKVxuICAgICAgICAgICAgOiAvLyBDYWNoZSB0aGUgdG9rZW5zXG4gICAgICAgICAgICAgIHRva2VuQ2FjaGUoc2VsZWN0b3IsIGdyb3Vwcykuc2xpY2UoMCk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiB0b1NlbGVjdG9yKHRva2Vucykge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICBzZWxlY3RvciA9IFwiXCI7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRDb21iaW5hdG9yKG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UpIHtcbiAgICAgICAgdmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuICAgICAgICAgIHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG4gICAgICAgICAga2V5ID0gc2tpcCB8fCBkaXIsXG4gICAgICAgICAgY2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcbiAgICAgICAgICBkb25lTmFtZSA9IGRvbmUrKztcblxuICAgICAgICByZXR1cm4gY29tYmluYXRvci5maXJzdFxuICAgICAgICAgID8gLy8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG4gICAgICAgICAgICBmdW5jdGlvbihlbGVtLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gZWxlbVtkaXJdKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuICAgICAgICAgICAgZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICAgIHZhciBvbGRDYWNoZSxcbiAgICAgICAgICAgICAgICB1bmlxdWVDYWNoZSxcbiAgICAgICAgICAgICAgICBvdXRlckNhY2hlLFxuICAgICAgICAgICAgICAgIG5ld0NhY2hlID0gW2RpcnJ1bnMsIGRvbmVOYW1lXTtcblxuICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcbiAgICAgICAgICAgICAgaWYgKHhtbCkge1xuICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IGVsZW1bZXhwYW5kb10gfHwgKGVsZW1bZXhwYW5kb10gPSB7fSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPDkgb25seVxuICAgICAgICAgICAgICAgICAgICAvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlQ2FjaGUgPVxuICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGVbZWxlbS51bmlxdWVJRF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAob3V0ZXJDYWNoZVtlbGVtLnVuaXF1ZUlEXSA9IHt9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbVtkaXJdIHx8IGVsZW07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVba2V5XSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBvbGRDYWNoZVswXSA9PT0gZGlycnVucyAmJlxuICAgICAgICAgICAgICAgICAgICAgIG9sZENhY2hlWzFdID09PSBkb25lTmFtZVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobmV3Q2FjaGVbMl0gPSBvbGRDYWNoZVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUNhY2hlW2tleV0gPSBuZXdDYWNoZTtcblxuICAgICAgICAgICAgICAgICAgICAgIC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgobmV3Q2FjaGVbMl0gPSBtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDFcbiAgICAgICAgICA/IGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIHhtbCkge1xuICAgICAgICAgICAgICB2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlcnNbaV0oZWxlbSwgY29udGV4dCwgeG1sKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IG1hdGNoZXJzWzBdO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cykge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgU2l6emxlKHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbmRlbnNlKHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCkge1xuICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICBuZXdVbm1hdGNoZWQgPSBbXSxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuICAgICAgICAgIG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoKGVsZW0gPSB1bm1hdGNoZWRbaV0pKSB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xuICAgICAgICAgICAgICBuZXdVbm1hdGNoZWQucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgICAgIG1hcC5wdXNoKGkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1VubWF0Y2hlZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2V0TWF0Y2hlcihcbiAgICAgICAgcHJlRmlsdGVyLFxuICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgcG9zdEZpbHRlcixcbiAgICAgICAgcG9zdEZpbmRlcixcbiAgICAgICAgcG9zdFNlbGVjdG9yXG4gICAgICApIHtcbiAgICAgICAgaWYgKHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbZXhwYW5kb10pIHtcbiAgICAgICAgICBwb3N0RmlsdGVyID0gc2V0TWF0Y2hlcihwb3N0RmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlcltleHBhbmRvXSkge1xuICAgICAgICAgIHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKHBvc3RGaW5kZXIsIHBvc3RTZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbihzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwpIHtcbiAgICAgICAgICB2YXIgdGVtcCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBlbGVtLFxuICAgICAgICAgICAgcHJlTWFwID0gW10sXG4gICAgICAgICAgICBwb3N0TWFwID0gW10sXG4gICAgICAgICAgICBwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuICAgICAgICAgICAgLy8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcbiAgICAgICAgICAgIGVsZW1zID1cbiAgICAgICAgICAgICAgc2VlZCB8fFxuICAgICAgICAgICAgICBtdWx0aXBsZUNvbnRleHRzKFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yIHx8IFwiKlwiLFxuICAgICAgICAgICAgICAgIGNvbnRleHQubm9kZVR5cGUgPyBbY29udGV4dF0gOiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cbiAgICAgICAgICAgIG1hdGNoZXJJbiA9XG4gICAgICAgICAgICAgIHByZUZpbHRlciAmJiAoc2VlZCB8fCAhc2VsZWN0b3IpXG4gICAgICAgICAgICAgICAgPyBjb25kZW5zZShlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbClcbiAgICAgICAgICAgICAgICA6IGVsZW1zLFxuICAgICAgICAgICAgbWF0Y2hlck91dCA9IG1hdGNoZXJcbiAgICAgICAgICAgICAgPyAvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIgfHwgKHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyKVxuICAgICAgICAgICAgICAgID8gLy8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICBbXVxuICAgICAgICAgICAgICAgIDogLy8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICByZXN1bHRzXG4gICAgICAgICAgICAgIDogbWF0Y2hlckluO1xuXG4gICAgICAgICAgLy8gRmluZCBwcmltYXJ5IG1hdGNoZXNcbiAgICAgICAgICBpZiAobWF0Y2hlcikge1xuICAgICAgICAgICAgbWF0Y2hlcihtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQXBwbHkgcG9zdEZpbHRlclxuICAgICAgICAgIGlmIChwb3N0RmlsdGVyKSB7XG4gICAgICAgICAgICB0ZW1wID0gY29uZGVuc2UobWF0Y2hlck91dCwgcG9zdE1hcCk7XG4gICAgICAgICAgICBwb3N0RmlsdGVyKHRlbXAsIFtdLCBjb250ZXh0LCB4bWwpO1xuXG4gICAgICAgICAgICAvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG4gICAgICAgICAgICBpID0gdGVtcC5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgIGlmICgoZWxlbSA9IHRlbXBbaV0pKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlck91dFtwb3N0TWFwW2ldXSA9ICEobWF0Y2hlckluW3Bvc3RNYXBbaV1dID0gZWxlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VlZCkge1xuICAgICAgICAgICAgaWYgKHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyKSB7XG4gICAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG4gICAgICAgICAgICAgICAgdGVtcCA9IFtdO1xuICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2goKG1hdGNoZXJJbltpXSA9IGVsZW0pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zdEZpbmRlcihudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG4gICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcbiAgICAgICAgICAgICAgICAgICh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2Yoc2VlZCwgZWxlbSkgOiBwcmVNYXBbaV0pID4gLTFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoZXJPdXQgPSBjb25kZW5zZShcbiAgICAgICAgICAgICAgbWF0Y2hlck91dCA9PT0gcmVzdWx0c1xuICAgICAgICAgICAgICAgID8gbWF0Y2hlck91dC5zcGxpY2UocHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogbWF0Y2hlck91dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XG4gICAgICAgICAgICAgIHBvc3RGaW5kZXIobnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgbWF0Y2hlck91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zKSB7XG4gICAgICAgIHZhciBjaGVja0NvbnRleHQsXG4gICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICBqLFxuICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXG4gICAgICAgICAgbGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVt0b2tlbnNbMF0udHlwZV0sXG4gICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcbiAgICAgICAgICBpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG4gICAgICAgICAgLy8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcbiAgICAgICAgICBtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKFxuICAgICAgICAgICAgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGltcGxpY2l0UmVsYXRpdmUsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKSxcbiAgICAgICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKFxuICAgICAgICAgICAgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXhPZihjaGVja0NvbnRleHQsIGVsZW0pID4gLTE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApLFxuICAgICAgICAgIG1hdGNoZXJzID0gW1xuICAgICAgICAgICAgZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgeG1sKSB7XG4gICAgICAgICAgICAgIHZhciByZXQgPVxuICAgICAgICAgICAgICAgICghbGVhZGluZ1JlbGF0aXZlICYmICh4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCkpIHx8XG4gICAgICAgICAgICAgICAgKChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZVxuICAgICAgICAgICAgICAgICAgPyBtYXRjaENvbnRleHQoZWxlbSwgY29udGV4dCwgeG1sKVxuICAgICAgICAgICAgICAgICAgOiBtYXRjaEFueUNvbnRleHQoZWxlbSwgY29udGV4dCwgeG1sKSk7XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuICAgICAgICAgICAgICBjaGVja0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICgobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbdG9rZW5zW2ldLnR5cGVdKSkge1xuICAgICAgICAgICAgbWF0Y2hlcnMgPSBbYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksIG1hdGNoZXIpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2hlciA9IEV4cHIuZmlsdGVyW3Rva2Vuc1tpXS50eXBlXS5hcHBseShcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgdG9rZW5zW2ldLm1hdGNoZXNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG4gICAgICAgICAgICBpZiAobWF0Y2hlcltleHBhbmRvXSkge1xuICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcbiAgICAgICAgICAgICAgaiA9ICsraTtcbiAgICAgICAgICAgICAgZm9yICg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlW3Rva2Vuc1tqXS50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzZXRNYXRjaGVyKFxuICAgICAgICAgICAgICAgIGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKSxcbiAgICAgICAgICAgICAgICBpID4gMSAmJlxuICAgICAgICAgICAgICAgICAgdG9TZWxlY3RvcihcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDAsIGkgLSAxKVxuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoeyB2YWx1ZTogdG9rZW5zW2kgLSAyXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuICAgICAgICAgICAgICAgICAgKS5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpLFxuICAgICAgICAgICAgICAgIG1hdGNoZXIsXG4gICAgICAgICAgICAgICAgaSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zLnNsaWNlKGksIGopKSxcbiAgICAgICAgICAgICAgICBqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoaikpKSxcbiAgICAgICAgICAgICAgICBqIDwgbGVuICYmIHRvU2VsZWN0b3IodG9rZW5zKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycykge1xuICAgICAgICB2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuICAgICAgICAgIHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0KSB7XG4gICAgICAgICAgICB2YXIgZWxlbSxcbiAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICAgICAgbWF0Y2hlZENvdW50ID0gMCxcbiAgICAgICAgICAgICAgaSA9IFwiMFwiLFxuICAgICAgICAgICAgICB1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gW10sXG4gICAgICAgICAgICAgIGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuICAgICAgICAgICAgICAvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG4gICAgICAgICAgICAgIGVsZW1zID0gc2VlZCB8fCAoYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXShcIipcIiwgb3V0ZXJtb3N0KSksXG4gICAgICAgICAgICAgIC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG4gICAgICAgICAgICAgIGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPVxuICAgICAgICAgICAgICAgIGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG4gICAgICAgICAgICAgIGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKG91dGVybW9zdCkge1xuICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcbiAgICAgICAgICAgIC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuICAgICAgICAgICAgZm9yICg7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGJ5RWxlbWVudCAmJiBlbGVtKSB7XG4gICAgICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KGVsZW0pO1xuICAgICAgICAgICAgICAgICAgeG1sID0gIWRvY3VtZW50SXNIVE1MO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG91dGVybW9zdCkge1xuICAgICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuICAgICAgICAgICAgICBpZiAoYnlTZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG4gICAgICAgICAgICAgICAgaWYgKChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkpIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudC0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3RcbiAgICAgICAgICAgICAgICBpZiAoc2VlZCkge1xuICAgICAgICAgICAgICAgICAgdW5tYXRjaGVkLnB1c2goZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcbiAgICAgICAgICAgIC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG4gICAgICAgICAgICBtYXRjaGVkQ291bnQgKz0gaTtcblxuICAgICAgICAgICAgLy8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG4gICAgICAgICAgICAvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcbiAgICAgICAgICAgIC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG4gICAgICAgICAgICAvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG4gICAgICAgICAgICAvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cbiAgICAgICAgICAgIC8vIG51bWVyaWNhbGx5IHplcm8uXG4gICAgICAgICAgICBpZiAoYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50KSB7XG4gICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXIodW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHNlZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcbiAgICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2Uoc2V0TWF0Y2hlZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG4gICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc2V0TWF0Y2hlZCk7XG5cbiAgICAgICAgICAgICAgLy8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBvdXRlcm1vc3QgJiZcbiAgICAgICAgICAgICAgICAhc2VlZCAmJlxuICAgICAgICAgICAgICAgIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgU2l6emxlLnVuaXF1ZVNvcnQocmVzdWx0cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG4gICAgICAgICAgICBpZiAob3V0ZXJtb3N0KSB7XG4gICAgICAgICAgICAgIGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVubWF0Y2hlZDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBieVNldCA/IG1hcmtGdW5jdGlvbihzdXBlck1hdGNoZXIpIDogc3VwZXJNYXRjaGVyO1xuICAgICAgfVxuXG4gICAgICBjb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbihcbiAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovXG4gICAgICApIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgc2V0TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMgPSBbXSxcbiAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlW3NlbGVjdG9yICsgXCIgXCJdO1xuXG4gICAgICAgIGlmICghY2FjaGVkKSB7XG4gICAgICAgICAgLy8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG4gICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgbWF0Y2ggPSB0b2tlbml6ZShzZWxlY3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgPSBtYXRjaC5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMobWF0Y2hbaV0pO1xuICAgICAgICAgICAgaWYgKGNhY2hlZFtleHBhbmRvXSkge1xuICAgICAgICAgICAgICBzZXRNYXRjaGVycy5wdXNoKGNhY2hlZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMucHVzaChjYWNoZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoXG4gICAgICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgICAgIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyhlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cbiAgICAgICAgICBjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gICAgICAgKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICAgICAgICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICAgICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICAgICAgICovXG4gICAgICBzZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZmluZCxcbiAgICAgICAgICBjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuICAgICAgICAgIG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpKTtcblxuICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgICAgICAvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuICAgICAgICAvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuICAgICAgICAgIHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoMCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdG9rZW5zLmxlbmd0aCA+IDIgJiZcbiAgICAgICAgICAgICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG4gICAgICAgICAgICBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmXG4gICAgICAgICAgICBkb2N1bWVudElzSFRNTCAmJlxuICAgICAgICAgICAgRXhwci5yZWxhdGl2ZVt0b2tlbnNbMV0udHlwZV1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSAoRXhwci5maW5kW1wiSURcIl0oXG4gICAgICAgICAgICAgIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksXG4gICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICkgfHwgW10pWzBdO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuXG4gICAgICAgICAgICAgIC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGlsZWQpIHtcbiAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSh0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcbiAgICAgICAgICBpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3Qoc2VsZWN0b3IpID8gMCA6IHRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgICAgIC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3JcbiAgICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlWyh0eXBlID0gdG9rZW4udHlwZSldKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChmaW5kID0gRXhwci5maW5kW3R5cGVdKSkge1xuICAgICAgICAgICAgICAvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChzZWVkID0gZmluZChcbiAgICAgICAgICAgICAgICAgIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksXG4gICAgICAgICAgICAgICAgICAocnNpYmxpbmcudGVzdCh0b2tlbnNbMF0udHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKHRva2Vucyk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzZWVkKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgIC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcbiAgICAgICAgKGNvbXBpbGVkIHx8IGNvbXBpbGUoc2VsZWN0b3IsIG1hdGNoKSkoXG4gICAgICAgICAgc2VlZCxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICFkb2N1bWVudElzSFRNTCxcbiAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICFjb250ZXh0IHx8XG4gICAgICAgICAgICAocnNpYmxpbmcudGVzdChzZWxlY3RvcikgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSkgfHxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4gICAgICAvLyBTb3J0IHN0YWJpbGl0eVxuICAgICAgc3VwcG9ydC5zb3J0U3RhYmxlID1cbiAgICAgICAgZXhwYW5kb1xuICAgICAgICAgIC5zcGxpdChcIlwiKVxuICAgICAgICAgIC5zb3J0KHNvcnRPcmRlcilcbiAgICAgICAgICAuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuICAgICAgLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuICAgICAgc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuICAgICAgc2V0RG9jdW1lbnQoKTtcblxuICAgICAgLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbiAgICAgIC8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuICAgICAgc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgLy8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpKSAmIDFcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdXBwb3J0OiBJRTw4XG4gICAgICAvLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbiAgICAgIGlmIChcbiAgICAgICAgIWFzc2VydChmdW5jdGlvbihlbCkge1xuICAgICAgICAgIGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuICAgICAgICAgIHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiO1xuICAgICAgICB9KVxuICAgICAgKSB7XG4gICAgICAgIGFkZEhhbmRsZShcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oZWxlbSwgbmFtZSwgaXNYTUwpIHtcbiAgICAgICAgICBpZiAoIWlzWE1MKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdXBwb3J0OiBJRTw5XG4gICAgICAvLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG4gICAgICBpZiAoXG4gICAgICAgICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHxcbiAgICAgICAgIWFzc2VydChmdW5jdGlvbihlbCkge1xuICAgICAgICAgIGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcbiAgICAgICAgICBlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIFwiXCIpO1xuICAgICAgICAgIHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBcIlwiO1xuICAgICAgICB9KVxuICAgICAgKSB7XG4gICAgICAgIGFkZEhhbmRsZShcInZhbHVlXCIsIGZ1bmN0aW9uKGVsZW0sIG5hbWUsIGlzWE1MKSB7XG4gICAgICAgICAgaWYgKCFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN1cHBvcnQ6IElFPDlcbiAgICAgIC8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbiAgICAgIGlmIChcbiAgICAgICAgIWFzc2VydChmdW5jdGlvbihlbCkge1xuICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xuICAgICAgICB9KVxuICAgICAgKSB7XG4gICAgICAgIGFkZEhhbmRsZShib29sZWFucywgZnVuY3Rpb24oZWxlbSwgbmFtZSwgaXNYTUwpIHtcbiAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgIGlmICghaXNYTUwpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtW25hbWVdID09PSB0cnVlXG4gICAgICAgICAgICAgID8gbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgIDogKHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZFxuICAgICAgICAgICAgICAgID8gdmFsLnZhbHVlXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTaXp6bGU7XG4gICAgfSkod2luZG93KTtcblxuICBqUXVlcnkuZmluZCA9IFNpenpsZTtcbiAgalF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4gIC8vIERlcHJlY2F0ZWRcbiAgalF1ZXJ5LmV4cHJbXCI6XCJdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbiAgalF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG4gIGpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG4gIGpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbiAgalF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xuICBqUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG4gIHZhciBkaXIgPSBmdW5jdGlvbihlbGVtLCBkaXIsIHVudGlsKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBbXSxcbiAgICAgIHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSkge1xuICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgaWYgKHRydW5jYXRlICYmIGpRdWVyeShlbGVtKS5pcyh1bnRpbCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXRjaGVkLnB1c2goZWxlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVkO1xuICB9O1xuXG4gIHZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKG4sIGVsZW0pIHtcbiAgICB2YXIgbWF0Y2hlZCA9IFtdO1xuXG4gICAgZm9yICg7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAobi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtKSB7XG4gICAgICAgIG1hdGNoZWQucHVzaChuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlZDtcbiAgfTtcblxuICB2YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuICBmdW5jdGlvbiBub2RlTmFtZShlbGVtLCBuYW1lKSB7XG4gICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgdmFyIHJzaW5nbGVUYWcgPSAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaTtcblxuICB2YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4gIC8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG4gIGZ1bmN0aW9uIHdpbm5vdyhlbGVtZW50cywgcXVhbGlmaWVyLCBub3QpIHtcbiAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ocXVhbGlmaWVyKSkge1xuICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtLCBpKSB7XG4gICAgICAgIHJldHVybiAhIXF1YWxpZmllci5jYWxsKGVsZW0sIGksIGVsZW0pICE9PSBub3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgZWxlbWVudFxuICAgIGlmIChxdWFsaWZpZXIubm9kZVR5cGUpIHtcbiAgICAgIHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICByZXR1cm4gKGVsZW0gPT09IHF1YWxpZmllcikgIT09IG5vdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuICAgIGlmICh0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChxdWFsaWZpZXIsIGVsZW0pID4gLTEgIT09IG5vdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNpbXBsZSBzZWxlY3RvciB0aGF0IGNhbiBiZSBmaWx0ZXJlZCBkaXJlY3RseSwgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG4gICAgaWYgKHJpc1NpbXBsZS50ZXN0KHF1YWxpZmllcikpIHtcbiAgICAgIHJldHVybiBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcGxleCBzZWxlY3RvciwgY29tcGFyZSB0aGUgdHdvIHNldHMsIHJlbW92aW5nIG5vbi1FbGVtZW50c1xuICAgIHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIocXVhbGlmaWVyLCBlbGVtZW50cyk7XG4gICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKHF1YWxpZmllciwgZWxlbSkgPiAtMSAhPT0gbm90ICYmIGVsZW0ubm9kZVR5cGUgPT09IDE7XG4gICAgfSk7XG4gIH1cblxuICBqUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oZXhwciwgZWxlbXMsIG5vdCkge1xuICAgIHZhciBlbGVtID0gZWxlbXNbMF07XG5cbiAgICBpZiAobm90KSB7XG4gICAgICBleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuICAgIH1cblxuICAgIGlmIChlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihlbGVtLCBleHByKSA/IFtlbGVtXSA6IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKFxuICAgICAgZXhwcixcbiAgICAgIGpRdWVyeS5ncmVwKGVsZW1zLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuICAgICAgfSlcbiAgICApO1xuICB9O1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIGZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgcmV0LFxuICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuICAgICAgICAgIGpRdWVyeShzZWxlY3RvcikuZmlsdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChqUXVlcnkuY29udGFpbnMoc2VsZltpXSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHRoaXMucHVzaFN0YWNrKFtdKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGpRdWVyeS5maW5kKHNlbGVjdG9yLCBzZWxmW2ldLCByZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KHJldCkgOiByZXQ7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sod2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSkpO1xuICAgIH0sXG4gICAgbm90OiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkpO1xuICAgIH0sXG4gICAgaXM6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gISF3aW5ub3coXG4gICAgICAgIHRoaXMsXG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuICAgICAgICAvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG4gICAgICAgIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3IpXG4gICAgICAgICAgPyBqUXVlcnkoc2VsZWN0b3IpXG4gICAgICAgICAgOiBzZWxlY3RvciB8fCBbXSxcbiAgICAgICAgZmFsc2VcbiAgICAgICkubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuICAvLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbiAgdmFyIHJvb3RqUXVlcnksXG4gICAgLy8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3NcbiAgICAvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG4gICAgLy8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG4gICAgLy8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuICAgIHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcbiAgICBpbml0ID0gKGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QpIHtcbiAgICAgIHZhciBtYXRjaCwgZWxlbTtcblxuICAgICAgLy8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcbiAgICAgIC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcbiAgICAgIHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cbiAgICAgIC8vIEhhbmRsZSBIVE1MIHN0cmluZ3NcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHNlbGVjdG9yWzBdID09PSBcIjxcIiAmJlxuICAgICAgICAgIHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdID09PSBcIj5cIiAmJlxuICAgICAgICAgIHNlbGVjdG9yLmxlbmd0aCA+PSAzXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG4gICAgICAgICAgbWF0Y2ggPSBbbnVsbCwgc2VsZWN0b3IsIG51bGxdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcbiAgICAgICAgaWYgKG1hdGNoICYmIChtYXRjaFsxXSB8fCAhY29udGV4dCkpIHtcbiAgICAgICAgICAvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcbiAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XG5cbiAgICAgICAgICAgIC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcbiAgICAgICAgICAgIGpRdWVyeS5tZXJnZShcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgalF1ZXJ5LnBhcnNlSFRNTChcbiAgICAgICAgICAgICAgICBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGVcbiAgICAgICAgICAgICAgICAgID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgIDogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG4gICAgICAgICAgICBpZiAocnNpbmdsZVRhZy50ZXN0KG1hdGNoWzFdKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChjb250ZXh0KSkge1xuICAgICAgICAgICAgICBmb3IgKG1hdGNoIGluIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHRoaXNbbWF0Y2hdKSkge1xuICAgICAgICAgICAgICAgICAgdGhpc1ttYXRjaF0oY29udGV4dFttYXRjaF0pO1xuXG4gICAgICAgICAgICAgICAgICAvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihtYXRjaCwgY29udGV4dFttYXRjaF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgLy8gSEFORExFOiAkKCNpZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1hdGNoWzJdKTtcblxuICAgICAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICAgICAgLy8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAgICAgdGhpc1swXSA9IGVsZW07XG4gICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gKGNvbnRleHQgfHwgcm9vdCkuZmluZChzZWxlY3Rvcik7XG5cbiAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcbiAgICAgICAgICAvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcihjb250ZXh0KS5maW5kKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvci5ub2RlVHlwZSkge1xuICAgICAgICB0aGlzWzBdID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgLy8gSEFORExFOiAkKGZ1bmN0aW9uKVxuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcbiAgICAgIH0gZWxzZSBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHJvb3QucmVhZHkoc2VsZWN0b3IpXG4gICAgICAgICAgOiAvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG4gICAgICAgICAgICBzZWxlY3RvcihqUXVlcnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4galF1ZXJ5Lm1ha2VBcnJheShzZWxlY3RvciwgdGhpcyk7XG4gICAgfSk7XG5cbiAgLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuICBpbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuICAvLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG4gIHJvb3RqUXVlcnkgPSBqUXVlcnkoZG9jdW1lbnQpO1xuXG4gIHZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcbiAgICAvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuICAgIGd1YXJhbnRlZWRVbmlxdWUgPSB7XG4gICAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICAgIGNvbnRlbnRzOiB0cnVlLFxuICAgICAgbmV4dDogdHJ1ZSxcbiAgICAgIHByZXY6IHRydWVcbiAgICB9O1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIGhhczogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICB2YXIgdGFyZ2V0cyA9IGpRdWVyeSh0YXJnZXQsIHRoaXMpLFxuICAgICAgICBsID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChqUXVlcnkuY29udGFpbnModGhpcywgdGFyZ2V0c1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uKHNlbGVjdG9ycywgY29udGV4dCkge1xuICAgICAgdmFyIGN1cixcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGwgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgbWF0Y2hlZCA9IFtdLFxuICAgICAgICB0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoc2VsZWN0b3JzKTtcblxuICAgICAgLy8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuICAgICAgaWYgKCFybmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3JzKSkge1xuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGZvciAoY3VyID0gdGhpc1tpXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBjdXIubm9kZVR5cGUgPCAxMSAmJlxuICAgICAgICAgICAgICAodGFyZ2V0c1xuICAgICAgICAgICAgICAgID8gdGFyZ2V0cy5pbmRleChjdXIpID4gLTFcbiAgICAgICAgICAgICAgICA6IC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuICAgICAgICAgICAgICAgICAgY3VyLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoY3VyLCBzZWxlY3RvcnMpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG1hdGNoZWQucHVzaChjdXIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuICAgICAgICBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydChtYXRjaGVkKSA6IG1hdGNoZWRcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuICAgIGluZGV4OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZVxuICAgICAgICAgID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGhcbiAgICAgICAgICA6IC0xO1xuICAgICAgfVxuXG4gICAgICAvLyBJbmRleCBpbiBzZWxlY3RvclxuICAgICAgaWYgKHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBpbmRleE9mLmNhbGwoalF1ZXJ5KGVsZW0pLCB0aGlzWzBdKTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG4gICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKFxuICAgICAgICB0aGlzLFxuXG4gICAgICAgIC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuICAgICAgICBlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXG4gICAgICAgIGpRdWVyeS51bmlxdWVTb3J0KGpRdWVyeS5tZXJnZSh0aGlzLmdldCgpLCBqUXVlcnkoc2VsZWN0b3IsIGNvbnRleHQpKSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGFkZEJhY2s6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoXG4gICAgICAgIHNlbGVjdG9yID09IG51bGwgPyB0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHNlbGVjdG9yKVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHNpYmxpbmcoY3VyLCBkaXIpIHtcbiAgICB3aGlsZSAoKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEpIHt9XG4gICAgcmV0dXJuIGN1cjtcbiAgfVxuXG4gIGpRdWVyeS5lYWNoKFxuICAgIHtcbiAgICAgIHBhcmVudDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuICAgICAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIHBhcmVudHM6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGRpcihlbGVtLCBcInBhcmVudE5vZGVcIik7XG4gICAgICB9LFxuICAgICAgcGFyZW50c1VudGlsOiBmdW5jdGlvbihlbGVtLCBpLCB1bnRpbCkge1xuICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCk7XG4gICAgICB9LFxuICAgICAgbmV4dDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICByZXR1cm4gc2libGluZyhlbGVtLCBcIm5leHRTaWJsaW5nXCIpO1xuICAgICAgfSxcbiAgICAgIHByZXY6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHNpYmxpbmcoZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIik7XG4gICAgICB9LFxuICAgICAgbmV4dEFsbDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwibmV4dFNpYmxpbmdcIik7XG4gICAgICB9LFxuICAgICAgcHJldkFsbDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICByZXR1cm4gZGlyKGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIpO1xuICAgICAgfSxcbiAgICAgIG5leHRVbnRpbDogZnVuY3Rpb24oZWxlbSwgaSwgdW50aWwpIHtcbiAgICAgICAgcmV0dXJuIGRpcihlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsKTtcbiAgICAgIH0sXG4gICAgICBwcmV2VW50aWw6IGZ1bmN0aW9uKGVsZW0sIGksIHVudGlsKSB7XG4gICAgICAgIHJldHVybiBkaXIoZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwpO1xuICAgICAgfSxcbiAgICAgIHNpYmxpbmdzOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIHJldHVybiBzaWJsaW5ncygoZWxlbS5wYXJlbnROb2RlIHx8IHt9KS5maXJzdENoaWxkLCBlbGVtKTtcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICByZXR1cm4gc2libGluZ3MoZWxlbS5maXJzdENoaWxkKTtcbiAgICAgIH0sXG4gICAgICBjb250ZW50czogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICBpZiAobm9kZU5hbWUoZWxlbSwgXCJpZnJhbWVcIikpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmIChub2RlTmFtZShlbGVtLCBcInRlbXBsYXRlXCIpKSB7XG4gICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZShbXSwgZWxlbS5jaGlsZE5vZGVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbih1bnRpbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKHRoaXMsIGZuLCB1bnRpbCk7XG5cbiAgICAgICAgaWYgKG5hbWUuc2xpY2UoLTUpICE9PSBcIlVudGlsXCIpIHtcbiAgICAgICAgICBzZWxlY3RvciA9IHVudGlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKHNlbGVjdG9yLCBtYXRjaGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xuICAgICAgICAgIGlmICghZ3VhcmFudGVlZFVuaXF1ZVtuYW1lXSkge1xuICAgICAgICAgICAgalF1ZXJ5LnVuaXF1ZVNvcnQobWF0Y2hlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcbiAgICAgICAgICBpZiAocnBhcmVudHNwcmV2LnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIG1hdGNoZWQucmV2ZXJzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhtYXRjaGVkKTtcbiAgICAgIH07XG4gICAgfVxuICApO1xuICB2YXIgcm5vdGh0bWx3aGl0ZSA9IC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZztcblxuICAvLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuICBmdW5jdGlvbiBjcmVhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgalF1ZXJ5LmVhY2gob3B0aW9ucy5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXSwgZnVuY3Rpb24oXywgZmxhZykge1xuICAgICAgb2JqZWN0W2ZsYWddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbiAgalF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG4gICAgLy8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuICAgIG9wdGlvbnMgPVxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyBjcmVhdGVPcHRpb25zKG9wdGlvbnMpXG4gICAgICAgIDogalF1ZXJ5LmV4dGVuZCh7fSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuICAgICAgZmlyaW5nLFxuICAgICAgLy8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcbiAgICAgIG1lbW9yeSxcbiAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG4gICAgICBmaXJlZCxcbiAgICAgIC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcbiAgICAgIGxvY2tlZCxcbiAgICAgIC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG4gICAgICBsaXN0ID0gW10sXG4gICAgICAvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuICAgICAgcXVldWUgPSBbXSxcbiAgICAgIC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuICAgICAgZmlyaW5nSW5kZXggPSAtMSxcbiAgICAgIC8vIEZpcmUgY2FsbGJhY2tzXG4gICAgICBmaXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuICAgICAgICBsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG4gICAgICAgIC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuICAgICAgICAvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG4gICAgICAgIGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcbiAgICAgICAgZm9yICg7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSkge1xuICAgICAgICAgIG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgd2hpbGUgKCsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGlzdFtmaXJpbmdJbmRleF0uYXBwbHkobWVtb3J5WzBdLCBtZW1vcnlbMV0pID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICBvcHRpb25zLnN0b3BPbkZhbHNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICBtZW1vcnkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG4gICAgICAgIGlmICghb3B0aW9ucy5tZW1vcnkpIHtcbiAgICAgICAgICBtZW1vcnkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpcmluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG4gICAgICAgIGlmIChsb2NrZWQpIHtcbiAgICAgICAgICAvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG4gICAgICAgICAgaWYgKG1lbW9yeSkge1xuICAgICAgICAgICAgbGlzdCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3QgPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG4gICAgICBzZWxmID0ge1xuICAgICAgICAvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG4gICAgICAgIGFkZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG4gICAgICAgICAgICBpZiAobWVtb3J5ICYmICFmaXJpbmcpIHtcbiAgICAgICAgICAgICAgZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIHF1ZXVlLnB1c2gobWVtb3J5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKGZ1bmN0aW9uIGFkZChhcmdzKSB7XG4gICAgICAgICAgICAgIGpRdWVyeS5lYWNoKGFyZ3MsIGZ1bmN0aW9uKF8sIGFyZykge1xuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyhhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoYXJnKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgLy8gSW5zcGVjdCByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgYWRkKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmIChtZW1vcnkgJiYgIWZpcmluZykge1xuICAgICAgICAgICAgICBmaXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3RcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBqUXVlcnkuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKF8sIGFyZykge1xuICAgICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKChpbmRleCA9IGpRdWVyeS5pbkFycmF5KGFyZywgbGlzdCwgaW5kZXgpKSA+IC0xKSB7XG4gICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgICAvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcbiAgICAgICAgICAgICAgaWYgKGluZGV4IDw9IGZpcmluZ0luZGV4KSB7XG4gICAgICAgICAgICAgICAgZmlyaW5nSW5kZXgtLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG4gICAgICAgIC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuICAgICAgICBoYXM6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgcmV0dXJuIGZuID8galF1ZXJ5LmluQXJyYXkoZm4sIGxpc3QpID4gLTEgOiBsaXN0Lmxlbmd0aCA+IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuICAgICAgICAvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcbiAgICAgICAgLy8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG4gICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvY2tlZCA9IHF1ZXVlID0gW107XG4gICAgICAgICAgbGlzdCA9IG1lbW9yeSA9IFwiXCI7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gIWxpc3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGlzYWJsZSAuZmlyZVxuICAgICAgICAvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuICAgICAgICAvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG4gICAgICAgIGxvY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvY2tlZCA9IHF1ZXVlID0gW107XG4gICAgICAgICAgaWYgKCFtZW1vcnkgJiYgIWZpcmluZykge1xuICAgICAgICAgICAgbGlzdCA9IG1lbW9yeSA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAhIWxvY2tlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG4gICAgICAgIGZpcmVXaXRoOiBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgICAgaWYgKCFsb2NrZWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgICAgICAgICAgYXJncyA9IFtjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJnc107XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCFmaXJpbmcpIHtcbiAgICAgICAgICAgICAgZmlyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICBmaXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLmZpcmVXaXRoKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG4gICAgICAgIGZpcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gISFmaXJlZDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIElkZW50aXR5KHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBmdW5jdGlvbiBUaHJvd2VyKGV4KSB7XG4gICAgdGhyb3cgZXg7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdFZhbHVlKHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUpIHtcbiAgICB2YXIgbWV0aG9kO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3JcbiAgICAgIGlmICh2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbigobWV0aG9kID0gdmFsdWUucHJvbWlzZSkpKSB7XG4gICAgICAgIG1ldGhvZFxuICAgICAgICAgIC5jYWxsKHZhbHVlKVxuICAgICAgICAgIC5kb25lKHJlc29sdmUpXG4gICAgICAgICAgLmZhaWwocmVqZWN0KTtcblxuICAgICAgICAvLyBPdGhlciB0aGVuYWJsZXNcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oKG1ldGhvZCA9IHZhbHVlLnRoZW4pKSkge1xuICAgICAgICBtZXRob2QuY2FsbCh2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICAvLyBPdGhlciBub24tdGhlbmFibGVzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG4gICAgICAgIC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcbiAgICAgICAgLy8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcbiAgICAgICAgcmVzb2x2ZS5hcHBseSh1bmRlZmluZWQsIFt2YWx1ZV0uc2xpY2Uobm9WYWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcbiAgICAgIC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cbiAgICAgIC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG4gICAgfSBjYXRjaCAodmFsdWUpIHtcbiAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcbiAgICAgIC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcbiAgICAgIHJlamVjdC5hcHBseSh1bmRlZmluZWQsIFt2YWx1ZV0pO1xuICAgIH1cbiAgfVxuXG4gIGpRdWVyeS5leHRlbmQoe1xuICAgIERlZmVycmVkOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICB2YXIgdHVwbGVzID0gW1xuICAgICAgICAgIC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG4gICAgICAgICAgLy8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFwibm90aWZ5XCIsXG4gICAgICAgICAgICBcInByb2dyZXNzXCIsXG4gICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpLFxuICAgICAgICAgICAgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKSxcbiAgICAgICAgICAgIDJcbiAgICAgICAgICBdLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFwicmVzb2x2ZVwiLFxuICAgICAgICAgICAgXCJkb25lXCIsXG4gICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG4gICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgXCJyZXNvbHZlZFwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBcInJlamVjdFwiLFxuICAgICAgICAgICAgXCJmYWlsXCIsXG4gICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG4gICAgICAgICAgICBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgXCJyZWplY3RlZFwiXG4gICAgICAgICAgXVxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZSA9IFwicGVuZGluZ1wiLFxuICAgICAgICBwcm9taXNlID0ge1xuICAgICAgICAgIHN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFsd2F5czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXRjaDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4obnVsbCwgZm4pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG4gICAgICAgICAgcGlwZTogZnVuY3Rpb24oLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8pIHtcbiAgICAgICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgICAgIHJldHVybiBqUXVlcnlcbiAgICAgICAgICAgICAgLkRlZmVycmVkKGZ1bmN0aW9uKG5ld0RlZmVyKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2godHVwbGVzLCBmdW5jdGlvbihpLCB0dXBsZSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICB2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbihmbnNbdHVwbGVbNF1dKSAmJiBmbnNbdHVwbGVbNF1dO1xuXG4gICAgICAgICAgICAgICAgICAvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcbiAgICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuICAgICAgICAgICAgICAgICAgLy8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcbiAgICAgICAgICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzFdXShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKHJldHVybmVkLnByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9taXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9ncmVzcyhuZXdEZWZlci5ub3RpZnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZG9uZShuZXdEZWZlci5yZXNvbHZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZhaWwobmV3RGVmZXIucmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZXdEZWZlclt0dXBsZVswXSArIFwiV2l0aFwiXShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbiA/IFtyZXR1cm5lZF0gOiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmbnMgPSBudWxsO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAucHJvbWlzZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHZhciBtYXhEZXB0aCA9IDA7XG4gICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlKGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgIG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkLCB0aGVuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gaGFuZGxlci5hcHBseSh0aGF0LCBhcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG4gICAgICAgICAgICAgICAgICAgIHRoZW4gPVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG4gICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQudGhlbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4uY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heERlcHRoKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4uY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgIT09IElkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtyZXR1cm5lZF07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgdmFsdWUocylcbiAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICAgIChzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoKSh0aGF0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuICAgICAgICAgICAgICAgICAgcHJvY2VzcyA9IHNwZWNpYWxcbiAgICAgICAgICAgICAgICAgICAgPyBtaWdodFRocm93XG4gICAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtaWdodFRocm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggKyAxID49IG1heERlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSBUaHJvd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKHRoYXQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcbiAgICAgICAgICAgICAgICAvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG4gICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcbiAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHByb2Nlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeVxuICAgICAgICAgICAgICAuRGVmZXJyZWQoZnVuY3Rpb24obmV3RGVmZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG4gICAgICAgICAgICAgICAgdHVwbGVzWzBdWzNdLmFkZChcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaXNGdW5jdGlvbihvblByb2dyZXNzKSA/IG9uUHJvZ3Jlc3MgOiBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXIubm90aWZ5V2l0aFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuICAgICAgICAgICAgICAgIHR1cGxlc1sxXVszXS5hZGQoXG4gICAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICBuZXdEZWZlcixcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmlzRnVuY3Rpb24ob25GdWxmaWxsZWQpID8gb25GdWxmaWxsZWQgOiBJZGVudGl0eVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG4gICAgICAgICAgICAgICAgdHVwbGVzWzJdWzNdLmFkZChcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLFxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaXNGdW5jdGlvbihvblJlamVjdGVkKSA/IG9uUmVqZWN0ZWQgOiBUaHJvd2VyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnByb21pc2UoKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuICAgICAgICAgIC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3RcbiAgICAgICAgICBwcm9taXNlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQob2JqLCBwcm9taXNlKSA6IHByb21pc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWZlcnJlZCA9IHt9O1xuXG4gICAgICAvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG4gICAgICBqUXVlcnkuZWFjaCh0dXBsZXMsIGZ1bmN0aW9uKGksIHR1cGxlKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdHVwbGVbMl0sXG4gICAgICAgICAgc3RhdGVTdHJpbmcgPSB0dXBsZVs1XTtcblxuICAgICAgICAvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcbiAgICAgICAgLy8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcbiAgICAgICAgLy8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcbiAgICAgICAgcHJvbWlzZVt0dXBsZVsxXV0gPSBsaXN0LmFkZDtcblxuICAgICAgICAvLyBIYW5kbGUgc3RhdGVcbiAgICAgICAgaWYgKHN0YXRlU3RyaW5nKSB7XG4gICAgICAgICAgbGlzdC5hZGQoXG4gICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcbiAgICAgICAgICAgICAgLy8gc3RhdGUgPSBcInJlamVjdGVkXCJcbiAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVN0cmluZztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG4gICAgICAgICAgICAvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcbiAgICAgICAgICAgIHR1cGxlc1szIC0gaV1bMl0uZGlzYWJsZSxcblxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcbiAgICAgICAgICAgIHR1cGxlc1swXVsyXS5sb2NrXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcbiAgICAgICAgLy8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcbiAgICAgICAgLy8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuICAgICAgICBsaXN0LmFkZCh0dXBsZVszXS5maXJlKTtcblxuICAgICAgICAvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cbiAgICAgICAgLy8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cbiAgICAgICAgLy8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG4gICAgICAgIGRlZmVycmVkW3R1cGxlWzBdXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzBdICsgXCJXaXRoXCJdKFxuICAgICAgICAgICAgdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLFxuICAgICAgICAgICAgYXJndW1lbnRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuICAgICAgICAvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcbiAgICAgICAgLy8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcbiAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0gPSBsaXN0LmZpcmVXaXRoO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuICAgICAgcHJvbWlzZS5wcm9taXNlKGRlZmVycmVkKTtcblxuICAgICAgLy8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgZnVuYy5jYWxsKGRlZmVycmVkLCBkZWZlcnJlZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbCBkb25lIVxuICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgIH0sXG5cbiAgICAvLyBEZWZlcnJlZCBoZWxwZXJcbiAgICB3aGVuOiBmdW5jdGlvbihzaW5nbGVWYWx1ZSkge1xuICAgICAgdmFyIC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuICAgICAgICByZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcbiAgICAgICAgaSA9IHJlbWFpbmluZyxcbiAgICAgICAgLy8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuICAgICAgICByZXNvbHZlQ29udGV4dHMgPSBBcnJheShpKSxcbiAgICAgICAgcmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgLy8gdGhlIG1hc3RlciBEZWZlcnJlZFxuICAgICAgICBtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcbiAgICAgICAgLy8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuICAgICAgICB1cGRhdGVGdW5jID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZUNvbnRleHRzW2ldID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVWYWx1ZXNbaV0gPVxuICAgICAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoYXJndW1lbnRzKSA6IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZykge1xuICAgICAgICAgICAgICBtYXN0ZXIucmVzb2x2ZVdpdGgocmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMSkge1xuICAgICAgICBhZG9wdFZhbHVlKFxuICAgICAgICAgIHNpbmdsZVZhbHVlLFxuICAgICAgICAgIG1hc3Rlci5kb25lKHVwZGF0ZUZ1bmMoaSkpLnJlc29sdmUsXG4gICAgICAgICAgbWFzdGVyLnJlamVjdCxcbiAgICAgICAgICAhcmVtYWluaW5nXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG4gICAgICAgICAgalF1ZXJ5LmlzRnVuY3Rpb24ocmVzb2x2ZVZhbHVlc1tpXSAmJiByZXNvbHZlVmFsdWVzW2ldLnRoZW4pXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBtYXN0ZXIudGhlbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGFkb3B0VmFsdWUocmVzb2x2ZVZhbHVlc1tpXSwgdXBkYXRlRnVuYyhpKSwgbWFzdGVyLnJlamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4gIC8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxuICB2YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxuICBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKGVycm9yLCBzdGFjaykge1xuICAgIC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcbiAgICAvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuICAgIGlmIChcbiAgICAgIHdpbmRvdy5jb25zb2xlICYmXG4gICAgICB3aW5kb3cuY29uc29sZS53YXJuICYmXG4gICAgICBlcnJvciAmJlxuICAgICAgcmVycm9yTmFtZXMudGVzdChlcnJvci5uYW1lKVxuICAgICkge1xuICAgICAgd2luZG93LmNvbnNvbGUud2FybihcbiAgICAgICAgXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsXG4gICAgICAgIGVycm9yLnN0YWNrLFxuICAgICAgICBzdGFja1xuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxuICB2YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbiAgalF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oZm4pIHtcbiAgICByZWFkeUxpc3RcbiAgICAgIC50aGVuKGZuKVxuXG4gICAgICAvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuICAgICAgLy8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG4gICAgICAvLyByZWdpc3RyYXRpb24uXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uKGVycm9yKTtcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgLy8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cbiAgICBpc1JlYWR5OiBmYWxzZSxcblxuICAgIC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcbiAgICAvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuICAgIHJlYWR5V2FpdDogMSxcblxuICAgIC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcbiAgICByZWFkeTogZnVuY3Rpb24od2FpdCkge1xuICAgICAgLy8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuICAgICAgaWYgKHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuICAgICAgalF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuICAgICAgaWYgKHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcbiAgICAgIHJlYWR5TGlzdC5yZXNvbHZlV2l0aChkb2N1bWVudCwgW2pRdWVyeV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgalF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuICAvLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcGxldGVkKTtcbiAgICBqUXVlcnkucmVhZHkoKTtcbiAgfVxuXG4gIC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4gIC8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuICAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4gIC8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuICBpZiAoXG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG4gICAgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwpXG4gICkge1xuICAgIC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGpRdWVyeS5yZWFkeSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCk7XG5cbiAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjb21wbGV0ZWQpO1xuICB9XG5cbiAgLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4gIC8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxuICB2YXIgYWNjZXNzID0gZnVuY3Rpb24oZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICBsZW4gPSBlbGVtcy5sZW5ndGgsXG4gICAgICBidWxrID0ga2V5ID09IG51bGw7XG5cbiAgICAvLyBTZXRzIG1hbnkgdmFsdWVzXG4gICAgaWYgKGpRdWVyeS50eXBlKGtleSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNoYWluYWJsZSA9IHRydWU7XG4gICAgICBmb3IgKGkgaW4ga2V5KSB7XG4gICAgICAgIGFjY2VzcyhlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldHMgb25lIHZhbHVlXG4gICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjaGFpbmFibGUgPSB0cnVlO1xuXG4gICAgICBpZiAoIWpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByYXcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVsaykge1xuICAgICAgICAvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcbiAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgIGZuLmNhbGwoZWxlbXMsIHZhbHVlKTtcbiAgICAgICAgICBmbiA9IG51bGw7XG5cbiAgICAgICAgICAvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVsayA9IGZuO1xuICAgICAgICAgIGZuID0gZnVuY3Rpb24oZWxlbSwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1bGsuY2FsbChqUXVlcnkoZWxlbSksIHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmbikge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZm4oXG4gICAgICAgICAgICBlbGVtc1tpXSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHJhdyA/IHZhbHVlIDogdmFsdWUuY2FsbChlbGVtc1tpXSwgaSwgZm4oZWxlbXNbaV0sIGtleSkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGFpbmFibGUpIHtcbiAgICAgIHJldHVybiBlbGVtcztcbiAgICB9XG5cbiAgICAvLyBHZXRzXG4gICAgaWYgKGJ1bGspIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKGVsZW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuID8gZm4oZWxlbXNbMF0sIGtleSkgOiBlbXB0eUdldDtcbiAgfTtcbiAgdmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbihvd25lcikge1xuICAgIC8vIEFjY2VwdHMgb25seTpcbiAgICAvLyAgLSBOb2RlXG4gICAgLy8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuICAgIC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG4gICAgLy8gIC0gT2JqZWN0XG4gICAgLy8gICAgLSBBbnlcbiAgICByZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgIStvd25lci5ub2RlVHlwZTtcbiAgfTtcblxuICBmdW5jdGlvbiBEYXRhKCkge1xuICAgIHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbiAgfVxuXG4gIERhdGEudWlkID0gMTtcblxuICBEYXRhLnByb3RvdHlwZSA9IHtcbiAgICBjYWNoZTogZnVuY3Rpb24ob3duZXIpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuICAgICAgdmFyIHZhbHVlID0gb3duZXJbdGhpcy5leHBhbmRvXTtcblxuICAgICAgLy8gSWYgbm90LCBjcmVhdGUgb25lXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0ge307XG5cbiAgICAgICAgLy8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG4gICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG4gICAgICAgIC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuICAgICAgICBpZiAoYWNjZXB0RGF0YShvd25lcikpIHtcbiAgICAgICAgICAvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG4gICAgICAgICAgLy8gdXNlIHBsYWluIGFzc2lnbm1lbnRcbiAgICAgICAgICBpZiAob3duZXIubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG4gICAgICAgICAgICAvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuICAgICAgICAgICAgLy8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3duZXIsIHRoaXMuZXhwYW5kbywge1xuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24ob3duZXIsIGRhdGEsIHZhbHVlKSB7XG4gICAgICB2YXIgcHJvcCxcbiAgICAgICAgY2FjaGUgPSB0aGlzLmNhY2hlKG93bmVyKTtcblxuICAgICAgLy8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuICAgICAgLy8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNhY2hlW2pRdWVyeS5jYW1lbENhc2UoZGF0YSldID0gdmFsdWU7XG5cbiAgICAgICAgLy8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3NcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG4gICAgICAgIGZvciAocHJvcCBpbiBkYXRhKSB7XG4gICAgICAgICAgY2FjaGVbalF1ZXJ5LmNhbWVsQ2FzZShwcm9wKV0gPSBkYXRhW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKG93bmVyLCBrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHRoaXMuY2FjaGUob3duZXIpXG4gICAgICAgIDogLy8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gJiYgb3duZXJbdGhpcy5leHBhbmRvXVtqUXVlcnkuY2FtZWxDYXNlKGtleSldO1xuICAgIH0sXG4gICAgYWNjZXNzOiBmdW5jdGlvbihvd25lciwga2V5LCB2YWx1ZSkge1xuICAgICAgLy8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuICAgICAgLy9cbiAgICAgIC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcbiAgICAgIC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuICAgICAgLy9cbiAgICAgIC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuICAgICAgLy8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuICAgICAgLy9cbiAgICAgIC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3RcbiAgICAgIC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcbiAgICAgIC8vXG4gICAgICBpZiAoXG4gICAgICAgIGtleSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIChrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChvd25lciwga2V5KTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcbiAgICAgIC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuICAgICAgLy9cbiAgICAgIC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcbiAgICAgIC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG4gICAgICAvL1xuICAgICAgdGhpcy5zZXQob3duZXIsIGtleSwgdmFsdWUpO1xuXG4gICAgICAvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcbiAgICAgIC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24ob3duZXIsIGtleSkge1xuICAgICAgdmFyIGksXG4gICAgICAgIGNhY2hlID0gb3duZXJbdGhpcy5leHBhbmRvXTtcblxuICAgICAgaWYgKGNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgIC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG4gICAgICAgICAgLy8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG4gICAgICAgICAga2V5ID0ga2V5Lm1hcChqUXVlcnkuY2FtZWxDYXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBqUXVlcnkuY2FtZWxDYXNlKGtleSk7XG5cbiAgICAgICAgICAvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2VcbiAgICAgICAgICBrZXkgPSBrZXkgaW4gY2FjaGUgPyBba2V5XSA6IGtleS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgPSBrZXkubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBkZWxldGUgY2FjaGVba2V5W2ldXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdChjYWNoZSkpIHtcbiAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuICAgICAgICAvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuICAgICAgICAvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG4gICAgICAgIGlmIChvd25lci5ub2RlVHlwZSkge1xuICAgICAgICAgIG93bmVyW3RoaXMuZXhwYW5kb10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIG93bmVyW3RoaXMuZXhwYW5kb107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc0RhdGE6IGZ1bmN0aW9uKG93bmVyKSB7XG4gICAgICB2YXIgY2FjaGUgPSBvd25lclt0aGlzLmV4cGFuZG9dO1xuICAgICAgcmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KGNhY2hlKTtcbiAgICB9XG4gIH07XG4gIHZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbiAgdmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuICAvL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuICAvL1xuICAvL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuICAvL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4gIC8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbiAgLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4gIC8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4gIC8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbiAgLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG4gIHZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG4gICAgcm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG4gIGZ1bmN0aW9uIGdldERhdGEoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBcInRydWVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgPT09IFwiZmFsc2VcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChkYXRhID09PSBcIm51bGxcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcbiAgICBpZiAoZGF0YSA9PT0gK2RhdGEgKyBcIlwiKSB7XG4gICAgICByZXR1cm4gK2RhdGE7XG4gICAgfVxuXG4gICAgaWYgKHJicmFjZS50ZXN0KGRhdGEpKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRhdGFBdHRyKGVsZW0sIGtleSwgZGF0YSkge1xuICAgIHZhciBuYW1lO1xuXG4gICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuICAgIC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgbmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKHJtdWx0aURhc2gsIFwiLSQmXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBnZXREYXRhKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuICAgICAgICBkYXRhVXNlci5zZXQoZWxlbSwga2V5LCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgaGFzRGF0YTogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoZWxlbSkgfHwgZGF0YVByaXYuaGFzRGF0YShlbGVtKTtcbiAgICB9LFxuXG4gICAgZGF0YTogZnVuY3Rpb24oZWxlbSwgbmFtZSwgZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGFVc2VyLmFjY2VzcyhlbGVtLCBuYW1lLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24oZWxlbSwgbmFtZSkge1xuICAgICAgZGF0YVVzZXIucmVtb3ZlKGVsZW0sIG5hbWUpO1xuICAgIH0sXG5cbiAgICAvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuICAgIC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuICAgIF9kYXRhOiBmdW5jdGlvbihlbGVtLCBuYW1lLCBkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YVByaXYuYWNjZXNzKGVsZW0sIG5hbWUsIGRhdGEpO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlRGF0YTogZnVuY3Rpb24oZWxlbSwgbmFtZSkge1xuICAgICAgZGF0YVByaXYucmVtb3ZlKGVsZW0sIG5hbWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgZGF0YTogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGksXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGVsZW0gPSB0aGlzWzBdLFxuICAgICAgICBhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG4gICAgICAvLyBHZXRzIGFsbCB2YWx1ZXNcbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICBkYXRhID0gZGF0YVVzZXIuZ2V0KGVsZW0pO1xuXG4gICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldChlbGVtLCBcImhhc0RhdGFBdHRyc1wiKSkge1xuICAgICAgICAgICAgaSA9IGF0dHJzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEgb25seVxuICAgICAgICAgICAgICAvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcbiAgICAgICAgICAgICAgaWYgKGF0dHJzW2ldKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZihcImRhdGEtXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZShuYW1lLnNsaWNlKDUpKTtcbiAgICAgICAgICAgICAgICAgIGRhdGFBdHRyKGVsZW0sIG5hbWUsIGRhdGFbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YVByaXYuc2V0KGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICBkYXRhVXNlci5zZXQodGhpcywga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2Nlc3MoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRhdGE7XG5cbiAgICAgICAgICAvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuICAgICAgICAgIC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG4gICAgICAgICAgLy8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3RcbiAgICAgICAgICAvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG4gICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cbiAgICAgICAgICBpZiAoZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG4gICAgICAgICAgICAvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuICAgICAgICAgICAgZGF0YSA9IGRhdGFVc2VyLmdldChlbGVtLCBrZXkpO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cbiAgICAgICAgICAgIC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhQXR0cihlbGVtLCBrZXkpO1xuICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCB0aGUgZGF0YS4uLlxuICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcbiAgICAgICAgICAgIGRhdGFVc2VyLnNldCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxLFxuICAgICAgICBudWxsLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH0sXG5cbiAgICByZW1vdmVEYXRhOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGRhdGFVc2VyLnJlbW92ZSh0aGlzLCBrZXkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBqUXVlcnkuZXh0ZW5kKHtcbiAgICBxdWV1ZTogZnVuY3Rpb24oZWxlbSwgdHlwZSwgZGF0YSkge1xuICAgICAgdmFyIHF1ZXVlO1xuXG4gICAgICBpZiAoZWxlbSkge1xuICAgICAgICB0eXBlID0gKHR5cGUgfHwgXCJmeFwiKSArIFwicXVldWVcIjtcbiAgICAgICAgcXVldWUgPSBkYXRhUHJpdi5nZXQoZWxlbSwgdHlwZSk7XG5cbiAgICAgICAgLy8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGlmICghcXVldWUgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheShkYXRhKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWV1ZSB8fCBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVxdWV1ZTogZnVuY3Rpb24oZWxlbSwgdHlwZSkge1xuICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG4gICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoZWxlbSwgdHlwZSksXG4gICAgICAgIHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuICAgICAgICBmbiA9IHF1ZXVlLnNoaWZ0KCksXG4gICAgICAgIGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKGVsZW0sIHR5cGUpLFxuICAgICAgICBuZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgalF1ZXJ5LmRlcXVldWUoZWxlbSwgdHlwZSk7XG4gICAgICAgIH07XG5cbiAgICAgIC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcbiAgICAgIGlmIChmbiA9PT0gXCJpbnByb2dyZXNzXCIpIHtcbiAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBzdGFydExlbmd0aC0tO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgLy8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG4gICAgICAgIGlmICh0eXBlID09PSBcImZ4XCIpIHtcbiAgICAgICAgICBxdWV1ZS51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cbiAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XG4gICAgICAgIGZuLmNhbGwoZWxlbSwgbmV4dCwgaG9va3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0YXJ0TGVuZ3RoICYmIGhvb2tzKSB7XG4gICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcbiAgICBfcXVldWVIb29rczogZnVuY3Rpb24oZWxlbSwgdHlwZSkge1xuICAgICAgdmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGRhdGFQcml2LmdldChlbGVtLCBrZXkpIHx8XG4gICAgICAgIGRhdGFQcml2LmFjY2VzcyhlbGVtLCBrZXksIHtcbiAgICAgICAgICBlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCBbdHlwZSArIFwicXVldWVcIiwga2V5XSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICBxdWV1ZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgICAgdmFyIHNldHRlciA9IDI7XG5cbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gdHlwZTtcbiAgICAgICAgdHlwZSA9IFwiZnhcIjtcbiAgICAgICAgc2V0dGVyLS07XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkucXVldWUodGhpc1swXSwgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB0aGlzXG4gICAgICAgIDogdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKHRoaXMsIHR5cGUsIGRhdGEpO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuICAgICAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKHRoaXMsIHR5cGUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIikge1xuICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRlcXVldWU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG4gICAgLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG4gICAgcHJvbWlzZTogZnVuY3Rpb24odHlwZSwgb2JqKSB7XG4gICAgICB2YXIgdG1wLFxuICAgICAgICBjb3VudCA9IDEsXG4gICAgICAgIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG4gICAgICAgIGVsZW1lbnRzID0gdGhpcyxcbiAgICAgICAgaSA9IHRoaXMubGVuZ3RoLFxuICAgICAgICByZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCEtLWNvdW50KSB7XG4gICAgICAgICAgICBkZWZlci5yZXNvbHZlV2l0aChlbGVtZW50cywgW2VsZW1lbnRzXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb2JqID0gdHlwZTtcbiAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB0bXAgPSBkYXRhUHJpdi5nZXQoZWxlbWVudHNbaV0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIik7XG4gICAgICAgIGlmICh0bXAgJiYgdG1wLmVtcHR5KSB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgICB0bXAuZW1wdHkuYWRkKHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgICByZXR1cm4gZGVmZXIucHJvbWlzZShvYmopO1xuICAgIH1cbiAgfSk7XG4gIHZhciBwbnVtID0gL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8uc291cmNlO1xuXG4gIHZhciByY3NzTnVtID0gbmV3IFJlZ0V4cChcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIik7XG5cbiAgdmFyIGNzc0V4cGFuZCA9IFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXTtcblxuICB2YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oZWxlbSwgZWwpIHtcbiAgICAvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcbiAgICAvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcbiAgICBlbGVtID0gZWwgfHwgZWxlbTtcblxuICAgIC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG4gICAgcmV0dXJuIChcbiAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcbiAgICAgIChlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuICAgICAgICAvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcbiAgICAgICAgLy8gaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICBqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSAmJlxuICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCIpXG4gICAgKTtcbiAgfTtcblxuICB2YXIgc3dhcCA9IGZ1bmN0aW9uKGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgdmFyIHJldCxcbiAgICAgIG5hbWUsXG4gICAgICBvbGQgPSB7fTtcblxuICAgIC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICBvbGRbbmFtZV0gPSBlbGVtLnN0eWxlW25hbWVdO1xuICAgICAgZWxlbS5zdHlsZVtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgfVxuXG4gICAgcmV0ID0gY2FsbGJhY2suYXBwbHkoZWxlbSwgYXJncyB8fCBbXSk7XG5cbiAgICAvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcbiAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgZWxlbS5zdHlsZVtuYW1lXSA9IG9sZFtuYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkanVzdENTUyhlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2Vlbikge1xuICAgIHZhciBhZGp1c3RlZCxcbiAgICAgIHNjYWxlID0gMSxcbiAgICAgIG1heEl0ZXJhdGlvbnMgPSAyMCxcbiAgICAgIGN1cnJlbnRWYWx1ZSA9IHR3ZWVuXG4gICAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHdlZW4uY3VyKCk7XG4gICAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5jc3MoZWxlbSwgcHJvcCwgXCJcIik7XG4gICAgICAgICAgfSxcbiAgICAgIGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcbiAgICAgIHVuaXQgPVxuICAgICAgICAodmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWzNdKSB8fCAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSA/IFwiXCIgOiBcInB4XCIpLFxuICAgICAgLy8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcbiAgICAgIGluaXRpYWxJblVuaXQgPVxuICAgICAgICAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSB8fCAodW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsKSkgJiZcbiAgICAgICAgcmNzc051bS5leGVjKGpRdWVyeS5jc3MoZWxlbSwgcHJvcCkpO1xuXG4gICAgaWYgKGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFszXSAhPT0gdW5pdCkge1xuICAgICAgLy8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuICAgICAgdW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFszXTtcblxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuICAgICAgdmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cbiAgICAgIC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG4gICAgICBpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuICAgICAgZG8ge1xuICAgICAgICAvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cbiAgICAgICAgLy8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcbiAgICAgICAgc2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cbiAgICAgICAgLy8gQWRqdXN0IGFuZCBhcHBseVxuICAgICAgICBpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG4gICAgICAgIC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG4gICAgICB9IHdoaWxlIChcbiAgICAgICAgc2NhbGUgIT09IChzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCkgJiZcbiAgICAgICAgc2NhbGUgIT09IDEgJiZcbiAgICAgICAgLS1tYXhJdGVyYXRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZVBhcnRzKSB7XG4gICAgICBpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuICAgICAgLy8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG4gICAgICBhZGp1c3RlZCA9IHZhbHVlUGFydHNbMV1cbiAgICAgICAgPyBpbml0aWFsSW5Vbml0ICsgKHZhbHVlUGFydHNbMV0gKyAxKSAqIHZhbHVlUGFydHNbMl1cbiAgICAgICAgOiArdmFsdWVQYXJ0c1syXTtcbiAgICAgIGlmICh0d2Vlbikge1xuICAgICAgICB0d2Vlbi51bml0ID0gdW5pdDtcbiAgICAgICAgdHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuICAgICAgICB0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFkanVzdGVkO1xuICB9XG5cbiAgdmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoZWxlbSkge1xuICAgIHZhciB0ZW1wLFxuICAgICAgZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuICAgICAgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuICAgICAgZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwW25vZGVOYW1lXTtcblxuICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICByZXR1cm4gZGlzcGxheTtcbiAgICB9XG5cbiAgICB0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpKTtcbiAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyh0ZW1wLCBcImRpc3BsYXlcIik7XG5cbiAgICB0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGVtcCk7XG5cbiAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgIGRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfVxuICAgIGRlZmF1bHREaXNwbGF5TWFwW25vZGVOYW1lXSA9IGRpc3BsYXk7XG5cbiAgICByZXR1cm4gZGlzcGxheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3dIaWRlKGVsZW1lbnRzLCBzaG93KSB7XG4gICAgdmFyIGRpc3BsYXksXG4gICAgICBlbGVtLFxuICAgICAgdmFsdWVzID0gW10sXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICAvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2VcbiAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGVsZW0gPSBlbGVtZW50c1tpbmRleF07XG4gICAgICBpZiAoIWVsZW0uc3R5bGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG4gICAgICBpZiAoc2hvdykge1xuICAgICAgICAvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG4gICAgICAgIC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuICAgICAgICAvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG4gICAgICAgIGlmIChkaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBkYXRhUHJpdi5nZXQoZWxlbSwgXCJkaXNwbGF5XCIpIHx8IG51bGw7XG4gICAgICAgICAgaWYgKCF2YWx1ZXNbaW5kZXhdKSB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZShlbGVtKSkge1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBnZXREZWZhdWx0RGlzcGxheShlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRpc3BsYXkgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IFwibm9uZVwiO1xuXG4gICAgICAgICAgLy8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuICAgICAgICAgIGRhdGFQcml2LnNldChlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAodmFsdWVzW2luZGV4XSAhPSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnRzW2luZGV4XS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH1cblxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzaG93SGlkZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNob3dIaWRlKHRoaXMpO1xuICAgIH0sXG4gICAgdG9nZ2xlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGlzSGlkZGVuV2l0aGluVHJlZSh0aGlzKSkge1xuICAgICAgICAgIGpRdWVyeSh0aGlzKS5zaG93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgalF1ZXJ5KHRoaXMpLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgdmFyIHJjaGVja2FibGVUeXBlID0gL14oPzpjaGVja2JveHxyYWRpbykkL2k7XG5cbiAgdmFyIHJ0YWdOYW1lID0gLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pO1xuXG4gIHZhciByc2NyaXB0VHlwZSA9IC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2k7XG5cbiAgLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbiAgdmFyIHdyYXBNYXAgPSB7XG4gICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICBvcHRpb246IFsxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIl0sXG5cbiAgICAvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuICAgIC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cbiAgICAvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG4gICAgdGhlYWQ6IFsxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiXSxcbiAgICBjb2w6IFsyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSxcbiAgICB0cjogWzIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCJdLFxuICAgIHRkOiBbMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sXG5cbiAgICBfZGVmYXVsdDogWzAsIFwiXCIsIFwiXCJdXG4gIH07XG5cbiAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgd3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG4gIHdyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9XG4gICAgd3JhcE1hcC50aGVhZDtcbiAgd3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbiAgZnVuY3Rpb24gZ2V0QWxsKGNvbnRleHQsIHRhZykge1xuICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcbiAgICAvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG4gICAgdmFyIHJldDtcblxuICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcgfHwgXCIqXCIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHRhZyB8fCBcIipcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCB8fCAodGFnICYmIG5vZGVOYW1lKGNvbnRleHQsIHRhZykpKSB7XG4gICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKFtjb250ZXh0XSwgcmV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG4gIGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoZWxlbXMsIHJlZkVsZW1lbnRzKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgbCA9IGVsZW1zLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBkYXRhUHJpdi5zZXQoXG4gICAgICAgIGVsZW1zW2ldLFxuICAgICAgICBcImdsb2JhbEV2YWxcIixcbiAgICAgICAgIXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldChyZWZFbGVtZW50c1tpXSwgXCJnbG9iYWxFdmFsXCIpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuICBmdW5jdGlvbiBidWlsZEZyYWdtZW50KGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQpIHtcbiAgICB2YXIgZWxlbSxcbiAgICAgIHRtcCxcbiAgICAgIHRhZyxcbiAgICAgIHdyYXAsXG4gICAgICBjb250YWlucyxcbiAgICAgIGosXG4gICAgICBmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgbm9kZXMgPSBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgbCA9IGVsZW1zLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBlbGVtID0gZWxlbXNbaV07XG5cbiAgICAgIGlmIChlbGVtIHx8IGVsZW0gPT09IDApIHtcbiAgICAgICAgLy8gQWRkIG5vZGVzIGRpcmVjdGx5XG4gICAgICAgIGlmIChqUXVlcnkudHlwZShlbGVtKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcbiAgICAgICAgICBqUXVlcnkubWVyZ2Uobm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbZWxlbV0gOiBlbGVtKTtcblxuICAgICAgICAgIC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuICAgICAgICB9IGVsc2UgaWYgKCFyaHRtbC50ZXN0KGVsZW0pKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChjb250ZXh0LmNyZWF0ZVRleHROb2RlKGVsZW0pKTtcblxuICAgICAgICAgIC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZChjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuXG4gICAgICAgICAgLy8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuICAgICAgICAgIHRhZyA9IChydGFnTmFtZS5leGVjKGVsZW0pIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB3cmFwID0gd3JhcE1hcFt0YWddIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG4gICAgICAgICAgdG1wLmlubmVySFRNTCA9IHdyYXBbMV0gKyBqUXVlcnkuaHRtbFByZWZpbHRlcihlbGVtKSArIHdyYXBbMl07XG5cbiAgICAgICAgICAvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcbiAgICAgICAgICBqID0gd3JhcFswXTtcbiAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICB0bXAgPSB0bXAubGFzdENoaWxkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcbiAgICAgICAgICBqUXVlcnkubWVyZ2Uobm9kZXMsIHRtcC5jaGlsZE5vZGVzKTtcblxuICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG4gICAgICAgICAgdG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5MilcbiAgICAgICAgICB0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuICAgIGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuICAgIGkgPSAwO1xuICAgIHdoaWxlICgoZWxlbSA9IG5vZGVzW2krK10pKSB7XG4gICAgICAvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheShlbGVtLCBzZWxlY3Rpb24pID4gLTEpIHtcbiAgICAgICAgaWYgKGlnbm9yZWQpIHtcbiAgICAgICAgICBpZ25vcmVkLnB1c2goZWxlbSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSk7XG5cbiAgICAgIC8vIEFwcGVuZCB0byBmcmFnbWVudFxuICAgICAgdG1wID0gZ2V0QWxsKGZyYWdtZW50LmFwcGVuZENoaWxkKGVsZW0pLCBcInNjcmlwdFwiKTtcblxuICAgICAgLy8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuICAgICAgaWYgKGNvbnRhaW5zKSB7XG4gICAgICAgIHNldEdsb2JhbEV2YWwodG1wKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuICAgICAgaWYgKHNjcmlwdHMpIHtcbiAgICAgICAgaiA9IDA7XG4gICAgICAgIHdoaWxlICgoZWxlbSA9IHRtcFtqKytdKSkge1xuICAgICAgICAgIGlmIChyc2NyaXB0VHlwZS50ZXN0KGVsZW0udHlwZSB8fCBcIlwiKSkge1xuICAgICAgICAgICAgc2NyaXB0cy5wdXNoKGVsZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICBkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxcbiAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXG4gICAgLy8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuICAgIC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG4gICAgLy8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuICAgIC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJyYWRpb1wiKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiKTtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwidFwiKTtcblxuICAgIGRpdi5hcHBlbmRDaGlsZChpbnB1dCk7XG5cbiAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcbiAgICAvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcbiAgICBzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKHRydWUpLmNsb25lTm9kZSh0cnVlKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgIC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG4gICAgZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuICAgIHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUodHJ1ZSkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbiAgfSkoKTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICB2YXIgcmtleUV2ZW50ID0gL15rZXkvLFxuICAgIHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuICAgIHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG4gIGZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH1cblxuICBmdW5jdGlvbiBvbihlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUpIHtcbiAgICB2YXIgb3JpZ0ZuLCB0eXBlO1xuXG4gICAgLy8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG4gICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuICAgICAgICBkYXRhID0gZGF0YSB8fCBzZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBmb3IgKHR5cGUgaW4gdHlwZXMpIHtcbiAgICAgICAgb24oZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzW3R5cGVdLCBvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsKSB7XG4gICAgICAvLyAoIHR5cGVzLCBmbiApXG4gICAgICBmbiA9IHNlbGVjdG9yO1xuICAgICAgZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoZm4gPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG4gICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgZGF0YSA9IHNlbGVjdG9yO1xuICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZuID09PSBmYWxzZSkge1xuICAgICAgZm4gPSByZXR1cm5GYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFmbikge1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgaWYgKG9uZSA9PT0gMSkge1xuICAgICAgb3JpZ0ZuID0gZm47XG4gICAgICBmbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuICAgICAgICBqUXVlcnkoKS5vZmYoZXZlbnQpO1xuICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuICAgICAgZm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8IChvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKyspO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgalF1ZXJ5LmV2ZW50LmFkZCh0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG4gIGpRdWVyeS5ldmVudCA9IHtcbiAgICBnbG9iYWw6IHt9LFxuXG4gICAgYWRkOiBmdW5jdGlvbihlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IpIHtcbiAgICAgIHZhciBoYW5kbGVPYmpJbixcbiAgICAgICAgZXZlbnRIYW5kbGUsXG4gICAgICAgIHRtcCxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICB0LFxuICAgICAgICBoYW5kbGVPYmosXG4gICAgICAgIHNwZWNpYWwsXG4gICAgICAgIGhhbmRsZXJzLFxuICAgICAgICB0eXBlLFxuICAgICAgICBuYW1lc3BhY2VzLFxuICAgICAgICBvcmlnVHlwZSxcbiAgICAgICAgZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoZWxlbSk7XG5cbiAgICAgIC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG4gICAgICBpZiAoIWVsZW1EYXRhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG4gICAgICBpZiAoaGFuZGxlci5oYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZU9iakluID0gaGFuZGxlcjtcbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG4gICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcbiAgICAgIC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3Rvcihkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG4gICAgICBpZiAoIWhhbmRsZXIuZ3VpZCkge1xuICAgICAgICBoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICBpZiAoIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpKSB7XG4gICAgICAgIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKCEoZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUpKSB7XG4gICAgICAgIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG4gICAgICAgICAgLy8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuICAgICAgICAgIHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGVcbiAgICAgICAgICAgID8galF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KGVsZW0sIGFyZ3VtZW50cylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG4gICAgICB0eXBlcyA9ICh0eXBlcyB8fCBcIlwiKS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXCJcIl07XG4gICAgICB0ID0gdHlwZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKHQtLSkge1xuICAgICAgICB0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKHR5cGVzW3RdKSB8fCBbXTtcbiAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xuICAgICAgICBuYW1lc3BhY2VzID0gKHRtcFsyXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpO1xuXG4gICAgICAgIC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XG5cbiAgICAgICAgLy8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG4gICAgICAgIHR5cGUgPSAoc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUpIHx8IHR5cGU7XG5cbiAgICAgICAgLy8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XG5cbiAgICAgICAgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZChcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICBuZWVkc0NvbnRleHQ6XG4gICAgICAgICAgICAgIHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KHNlbGVjdG9yKSxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKFwiLlwiKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFuZGxlT2JqSW5cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuICAgICAgICBpZiAoIShoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSkpIHtcbiAgICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IFtdO1xuICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG4gICAgICAgICAgLy8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXNwZWNpYWwuc2V0dXAgfHxcbiAgICAgICAgICAgIHNwZWNpYWwuc2V0dXAuY2FsbChlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSkgPT09IGZhbHNlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldmVudEhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWNpYWwuYWRkKSB7XG4gICAgICAgICAgc3BlY2lhbC5hZGQuY2FsbChlbGVtLCBoYW5kbGVPYmopO1xuXG4gICAgICAgICAgaWYgKCFoYW5kbGVPYmouaGFuZGxlci5ndWlkKSB7XG4gICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVPYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuICAgICAgICBqUXVlcnkuZXZlbnQuZ2xvYmFsW3R5cGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG4gICAgcmVtb3ZlOiBmdW5jdGlvbihlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzKSB7XG4gICAgICB2YXIgaixcbiAgICAgICAgb3JpZ0NvdW50LFxuICAgICAgICB0bXAsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgdCxcbiAgICAgICAgaGFuZGxlT2JqLFxuICAgICAgICBzcGVjaWFsLFxuICAgICAgICBoYW5kbGVycyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbmFtZXNwYWNlcyxcbiAgICAgICAgb3JpZ1R5cGUsXG4gICAgICAgIGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YShlbGVtKSAmJiBkYXRhUHJpdi5nZXQoZWxlbSk7XG5cbiAgICAgIGlmICghZWxlbURhdGEgfHwgIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuICAgICAgdHlwZXMgPSAodHlwZXMgfHwgXCJcIikubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW1wiXCJdO1xuICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICh0LS0pIHtcbiAgICAgICAgdG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyh0eXBlc1t0XSkgfHwgW107XG4gICAgICAgIHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcbiAgICAgICAgbmFtZXNwYWNlcyA9ICh0bXBbMl0gfHwgXCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKTtcblxuICAgICAgICAvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgZm9yICh0eXBlIGluIGV2ZW50cykge1xuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZShlbGVtLCB0eXBlICsgdHlwZXNbdF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XG4gICAgICAgIHR5cGUgPSAoc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUpIHx8IHR5cGU7XG4gICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdIHx8IFtdO1xuICAgICAgICB0bXAgPVxuICAgICAgICAgIHRtcFsyXSAmJlxuICAgICAgICAgIG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIik7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuICAgICAgICBvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgaGFuZGxlT2JqID0gaGFuZGxlcnNbal07XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAobWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSkgJiZcbiAgICAgICAgICAgICghaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkKSAmJlxuICAgICAgICAgICAgKCF0bXAgfHwgdG1wLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpICYmXG4gICAgICAgICAgICAoIXNlbGVjdG9yIHx8XG4gICAgICAgICAgICAgIHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgKHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShqLCAxKTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZU9iai5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BlY2lhbC5yZW1vdmUpIHtcbiAgICAgICAgICAgICAgc3BlY2lhbC5yZW1vdmUuY2FsbChlbGVtLCBoYW5kbGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3RcbiAgICAgICAgLy8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG4gICAgICAgIGlmIChvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFzcGVjaWFsLnRlYXJkb3duIHx8XG4gICAgICAgICAgICBzcGVjaWFsLnRlYXJkb3duLmNhbGwoZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlKSA9PT0gZmFsc2VcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcbiAgICAgIGlmIChqUXVlcnkuaXNFbXB0eU9iamVjdChldmVudHMpKSB7XG4gICAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCBcImhhbmRsZSBldmVudHNcIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRpc3BhdGNoOiBmdW5jdGlvbihuYXRpdmVFdmVudCkge1xuICAgICAgLy8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG4gICAgICB2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KG5hdGl2ZUV2ZW50KTtcblxuICAgICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIHJldCxcbiAgICAgICAgbWF0Y2hlZCxcbiAgICAgICAgaGFuZGxlT2JqLFxuICAgICAgICBoYW5kbGVyUXVldWUsXG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksXG4gICAgICAgIGhhbmRsZXJzID0gKGRhdGFQcml2LmdldCh0aGlzLCBcImV2ZW50c1wiKSB8fCB7fSlbZXZlbnQudHlwZV0gfHwgW10sXG4gICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFtldmVudC50eXBlXSB8fCB7fTtcblxuICAgICAgLy8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcbiAgICAgIGFyZ3NbMF0gPSBldmVudDtcblxuICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cbiAgICAgIC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcbiAgICAgIGlmIChcbiAgICAgICAgc3BlY2lhbC5wcmVEaXNwYXRjaCAmJlxuICAgICAgICBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwodGhpcywgZXZlbnQpID09PSBmYWxzZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGhhbmRsZXJzXG4gICAgICBoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCBldmVudCwgaGFuZGxlcnMpO1xuXG4gICAgICAvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuICAgICAgaSA9IDA7XG4gICAgICB3aGlsZSAoKG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuICAgICAgICBqID0gMDtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgIChoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzW2orK10pICYmXG4gICAgICAgICAgIWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuICAgICAgICAgIC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuICAgICAgICAgIGlmICghZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuICAgICAgICAgICAgcmV0ID0gKFxuICAgICAgICAgICAgICAoalF1ZXJ5LmV2ZW50LnNwZWNpYWxbaGFuZGxlT2JqLm9yaWdUeXBlXSB8fCB7fSkuaGFuZGxlIHx8XG4gICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyXG4gICAgICAgICAgICApLmFwcGx5KG1hdGNoZWQuZWxlbSwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoKGV2ZW50LnJlc3VsdCA9IHJldCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG4gICAgICBpZiAoc3BlY2lhbC5wb3N0RGlzcGF0Y2gpIHtcbiAgICAgICAgc3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG4gICAgfSxcblxuICAgIGhhbmRsZXJzOiBmdW5jdGlvbihldmVudCwgaGFuZGxlcnMpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICBoYW5kbGVPYmosXG4gICAgICAgIHNlbCxcbiAgICAgICAgbWF0Y2hlZEhhbmRsZXJzLFxuICAgICAgICBtYXRjaGVkU2VsZWN0b3JzLFxuICAgICAgICBoYW5kbGVyUXVldWUgPSBbXSxcbiAgICAgICAgZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG4gICAgICAgIGN1ciA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgLy8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuICAgICAgaWYgKFxuICAgICAgICBkZWxlZ2F0ZUNvdW50ICYmXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OVxuICAgICAgICAvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcbiAgICAgICAgY3VyLm5vZGVUeXBlICYmXG4gICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuICAgICAgICAvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcbiAgICAgICAgLy8gU3VwcG9ydDogSUUgMTEgb25seVxuICAgICAgICAvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG4gICAgICAgICEoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxKVxuICAgICAgKSB7XG4gICAgICAgIGZvciAoOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMpIHtcbiAgICAgICAgICAvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcbiAgICAgICAgICAvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjdXIubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICAgICEoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgbWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBoYW5kbGVPYmogPSBoYW5kbGVyc1tpXTtcblxuICAgICAgICAgICAgICAvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuICAgICAgICAgICAgICBzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuICAgICAgICAgICAgICBpZiAobWF0Y2hlZFNlbGVjdG9yc1tzZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkU2VsZWN0b3JzW3NlbF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0XG4gICAgICAgICAgICAgICAgICA/IGpRdWVyeShzZWwsIHRoaXMpLmluZGV4KGN1cikgPiAtMVxuICAgICAgICAgICAgICAgICAgOiBqUXVlcnkuZmluZChzZWwsIHRoaXMsIG51bGwsIFtjdXJdKS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1hdGNoZWRTZWxlY3RvcnNbc2VsXSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRIYW5kbGVycy5wdXNoKGhhbmRsZU9iaik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVkSGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG4gICAgICBjdXIgPSB0aGlzO1xuICAgICAgaWYgKGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goe1xuICAgICAgICAgIGVsZW06IGN1cixcbiAgICAgICAgICBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoZGVsZWdhdGVDb3VudClcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYW5kbGVyUXVldWU7XG4gICAgfSxcblxuICAgIGFkZFByb3A6IGZ1bmN0aW9uKG5hbWUsIGhvb2spIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGpRdWVyeS5pc0Z1bmN0aW9uKGhvb2spXG4gICAgICAgICAgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxFdmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBob29rKHRoaXMub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFtuYW1lXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZml4OiBmdW5jdGlvbihvcmlnaW5hbEV2ZW50KSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWxFdmVudFtqUXVlcnkuZXhwYW5kb11cbiAgICAgICAgPyBvcmlnaW5hbEV2ZW50XG4gICAgICAgIDogbmV3IGpRdWVyeS5FdmVudChvcmlnaW5hbEV2ZW50KTtcbiAgICB9LFxuXG4gICAgc3BlY2lhbDoge1xuICAgICAgbG9hZDoge1xuICAgICAgICAvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG4gICAgICAgIG5vQnViYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgLy8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcbiAgICAgIH0sXG4gICAgICBibHVyOiB7XG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1cikge1xuICAgICAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuICAgICAgfSxcbiAgICAgIGNsaWNrOiB7XG4gICAgICAgIC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmXG4gICAgICAgICAgICB0aGlzLmNsaWNrICYmXG4gICAgICAgICAgICBub2RlTmFtZSh0aGlzLCBcImlucHV0XCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuICAgICAgICBfZGVmYXVsdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZU5hbWUoZXZlbnQudGFyZ2V0LCBcImFcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGJlZm9yZXVubG9hZDoge1xuICAgICAgICBwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgLy8gU3VwcG9ydDogRmlyZWZveCAyMCtcbiAgICAgICAgICAvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG4gICAgICAgICAgaWYgKGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKGVsZW0sIHR5cGUsIGhhbmRsZSkge1xuICAgIC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGUpO1xuICAgIH1cbiAgfTtcblxuICBqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbihzcmMsIHByb3BzKSB7XG4gICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCkpIHtcbiAgICAgIHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KHNyYywgcHJvcHMpO1xuICAgIH1cblxuICAgIC8vIEV2ZW50IG9iamVjdFxuICAgIGlmIChzcmMgJiYgc3JjLnR5cGUpIHtcbiAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcbiAgICAgIHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG4gICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9XG4gICAgICAgIHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG4gICAgICAgIChzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG4gICAgICAgICAgc3JjLnJldHVyblZhbHVlID09PSBmYWxzZSlcbiAgICAgICAgICA/IHJldHVyblRydWVcbiAgICAgICAgICA6IHJldHVybkZhbHNlO1xuXG4gICAgICAvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcbiAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcbiAgICAgIC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG4gICAgICB0aGlzLnRhcmdldCA9XG4gICAgICAgIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gM1xuICAgICAgICAgID8gc3JjLnRhcmdldC5wYXJlbnROb2RlXG4gICAgICAgICAgOiBzcmMudGFyZ2V0O1xuXG4gICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcbiAgICAgIHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG4gICAgICAvLyBFdmVudCB0eXBlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHlwZSA9IHNyYztcbiAgICB9XG5cbiAgICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuICAgIGlmIChwcm9wcykge1xuICAgICAgalF1ZXJ5LmV4dGVuZCh0aGlzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICB0aGlzLnRpbWVTdGFtcCA9IChzcmMgJiYgc3JjLnRpbWVTdGFtcCkgfHwgalF1ZXJ5Lm5vdygpO1xuXG4gICAgLy8gTWFyayBpdCBhcyBmaXhlZFxuICAgIHRoaXNbalF1ZXJ5LmV4cGFuZG9dID0gdHJ1ZTtcbiAgfTtcblxuICAvLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuICBqUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG4gICAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcbiAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICAgIGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cbiAgICAgIGlmIChlICYmICF0aGlzLmlzU2ltdWxhdGVkKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICAgIGlmIChlICYmICF0aGlzLmlzU2ltdWxhdGVkKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgICBpZiAoZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCkge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICAvLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xuICBqUXVlcnkuZWFjaChcbiAgICB7XG4gICAgICBhbHRLZXk6IHRydWUsXG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuICAgICAgY3RybEtleTogdHJ1ZSxcbiAgICAgIGRldGFpbDogdHJ1ZSxcbiAgICAgIGV2ZW50UGhhc2U6IHRydWUsXG4gICAgICBtZXRhS2V5OiB0cnVlLFxuICAgICAgcGFnZVg6IHRydWUsXG4gICAgICBwYWdlWTogdHJ1ZSxcbiAgICAgIHNoaWZ0S2V5OiB0cnVlLFxuICAgICAgdmlldzogdHJ1ZSxcbiAgICAgIGNoYXI6IHRydWUsXG4gICAgICBjaGFyQ29kZTogdHJ1ZSxcbiAgICAgIGtleTogdHJ1ZSxcbiAgICAgIGtleUNvZGU6IHRydWUsXG4gICAgICBidXR0b246IHRydWUsXG4gICAgICBidXR0b25zOiB0cnVlLFxuICAgICAgY2xpZW50WDogdHJ1ZSxcbiAgICAgIGNsaWVudFk6IHRydWUsXG4gICAgICBvZmZzZXRYOiB0cnVlLFxuICAgICAgb2Zmc2V0WTogdHJ1ZSxcbiAgICAgIHBvaW50ZXJJZDogdHJ1ZSxcbiAgICAgIHBvaW50ZXJUeXBlOiB0cnVlLFxuICAgICAgc2NyZWVuWDogdHJ1ZSxcbiAgICAgIHNjcmVlblk6IHRydWUsXG4gICAgICB0YXJnZXRUb3VjaGVzOiB0cnVlLFxuICAgICAgdG9FbGVtZW50OiB0cnVlLFxuICAgICAgdG91Y2hlczogdHJ1ZSxcblxuICAgICAgd2hpY2g6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cbiAgICAgICAgLy8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG4gICAgICAgIGlmIChldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KGV2ZW50LnR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZXZlbnQud2hpY2ggJiZcbiAgICAgICAgICBidXR0b24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHJtb3VzZUV2ZW50LnRlc3QoZXZlbnQudHlwZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGJ1dHRvbiAmIDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChidXR0b24gJiAyKSB7XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYnV0dG9uICYgNCkge1xuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnQud2hpY2g7XG4gICAgICB9XG4gICAgfSxcbiAgICBqUXVlcnkuZXZlbnQuYWRkUHJvcFxuICApO1xuXG4gIC8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuICAvLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuICAvLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuICAvL1xuICAvLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4gIC8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbiAgLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbiAgalF1ZXJ5LmVhY2goXG4gICAge1xuICAgICAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcbiAgICAgIHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuICAgICAgcG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxuICAgIH0sXG4gICAgZnVuY3Rpb24ob3JpZywgZml4KSB7XG4gICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtvcmlnXSA9IHtcbiAgICAgICAgZGVsZWdhdGVUeXBlOiBmaXgsXG4gICAgICAgIGJpbmRUeXBlOiBmaXgsXG5cbiAgICAgICAgaGFuZGxlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciByZXQsXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLFxuICAgICAgICAgICAgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG4gICAgICAgICAgICBoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cbiAgICAgICAgICAvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuICAgICAgICAgIC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXJlbGF0ZWQgfHxcbiAgICAgICAgICAgIChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyh0YXJnZXQsIHJlbGF0ZWQpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcbiAgICAgICAgICAgIHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBldmVudC50eXBlID0gZml4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgKTtcblxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICBvbjogZnVuY3Rpb24odHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbikge1xuICAgICAgcmV0dXJuIG9uKHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pO1xuICAgIH0sXG4gICAgb25lOiBmdW5jdGlvbih0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKSB7XG4gICAgICByZXR1cm4gb24odGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSk7XG4gICAgfSxcbiAgICBvZmY6IGZ1bmN0aW9uKHR5cGVzLCBzZWxlY3RvciwgZm4pIHtcbiAgICAgIHZhciBoYW5kbGVPYmosIHR5cGU7XG4gICAgICBpZiAodHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqKSB7XG4gICAgICAgIC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcbiAgICAgICAgaGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuICAgICAgICBqUXVlcnkodHlwZXMuZGVsZWdhdGVUYXJnZXQpLm9mZihcbiAgICAgICAgICBoYW5kbGVPYmoubmFtZXNwYWNlXG4gICAgICAgICAgICA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZVxuICAgICAgICAgICAgOiBoYW5kbGVPYmoub3JpZ1R5cGUsXG4gICAgICAgICAgaGFuZGxlT2JqLnNlbGVjdG9yLFxuICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuICAgICAgICBmb3IgKHR5cGUgaW4gdHlwZXMpIHtcbiAgICAgICAgICB0aGlzLm9mZih0eXBlLCBzZWxlY3RvciwgdHlwZXNbdHlwZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyAoIHR5cGVzIFssIGZuXSApXG4gICAgICAgIGZuID0gc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGZuID09PSBmYWxzZSkge1xuICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSh0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuICAgIHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICAgIC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzXG4gICAgLy8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuICAgIHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuICAgIC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuICAgIHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcbiAgICByc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuICAgIHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuICAvLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbiAgZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KGVsZW0sIGNvbnRlbnQpIHtcbiAgICBpZiAoXG4gICAgICBub2RlTmFtZShlbGVtLCBcInRhYmxlXCIpICYmXG4gICAgICBub2RlTmFtZShjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIilcbiAgICApIHtcbiAgICAgIHJldHVybiBqUXVlcnkoXCI+dGJvZHlcIiwgZWxlbSlbMF0gfHwgZWxlbTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbTtcbiAgfVxuXG4gIC8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbiAgZnVuY3Rpb24gZGlzYWJsZVNjcmlwdChlbGVtKSB7XG4gICAgZWxlbS50eXBlID0gKGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSAhPT0gbnVsbCkgKyBcIi9cIiArIGVsZW0udHlwZTtcbiAgICByZXR1cm4gZWxlbTtcbiAgfVxuICBmdW5jdGlvbiByZXN0b3JlU2NyaXB0KGVsZW0pIHtcbiAgICB2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKGVsZW0udHlwZSk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGVsZW0udHlwZSA9IG1hdGNoWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW07XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZUNvcHlFdmVudChzcmMsIGRlc3QpIHtcbiAgICB2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuICAgIGlmIChkZXN0Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cbiAgICBpZiAoZGF0YVByaXYuaGFzRGF0YShzcmMpKSB7XG4gICAgICBwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2VzcyhzcmMpO1xuICAgICAgcGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoZGVzdCwgcGRhdGFPbGQpO1xuICAgICAgZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG4gICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgIGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG4gICAgICAgIHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG4gICAgICAgIGZvciAodHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXZlbnRzW3R5cGVdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LmFkZChkZXN0LCB0eXBlLCBldmVudHNbdHlwZV1baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDIuIENvcHkgdXNlciBkYXRhXG4gICAgaWYgKGRhdGFVc2VyLmhhc0RhdGEoc3JjKSkge1xuICAgICAgdWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3Moc3JjKTtcbiAgICAgIHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCh7fSwgdWRhdGFPbGQpO1xuXG4gICAgICBkYXRhVXNlci5zZXQoZGVzdCwgdWRhdGFDdXIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuICBmdW5jdGlvbiBmaXhJbnB1dChzcmMsIGRlc3QpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cbiAgICBpZiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KHNyYy50eXBlKSkge1xuICAgICAgZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cbiAgICAgIC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG4gICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgICAgIGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb21NYW5pcChjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCkge1xuICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcbiAgICBhcmdzID0gY29uY2F0LmFwcGx5KFtdLCBhcmdzKTtcblxuICAgIHZhciBmcmFnbWVudCxcbiAgICAgIGZpcnN0LFxuICAgICAgc2NyaXB0cyxcbiAgICAgIGhhc1NjcmlwdHMsXG4gICAgICBub2RlLFxuICAgICAgZG9jLFxuICAgICAgaSA9IDAsXG4gICAgICBsID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICBpTm9DbG9uZSA9IGwgLSAxLFxuICAgICAgdmFsdWUgPSBhcmdzWzBdLFxuICAgICAgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKTtcblxuICAgIC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuICAgIGlmIChcbiAgICAgIGlzRnVuY3Rpb24gfHxcbiAgICAgIChsID4gMSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgIXN1cHBvcnQuY2hlY2tDbG9uZSAmJlxuICAgICAgICByY2hlY2tlZC50ZXN0KHZhbHVlKSlcbiAgICApIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmVhY2goZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKGluZGV4KTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24pIHtcbiAgICAgICAgICBhcmdzWzBdID0gdmFsdWUuY2FsbCh0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkpO1xuICAgICAgICB9XG4gICAgICAgIGRvbU1hbmlwKHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsKSB7XG4gICAgICBmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIGNvbGxlY3Rpb25bMF0ub3duZXJEb2N1bWVudCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGlnbm9yZWRcbiAgICAgICk7XG4gICAgICBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICAgIGlmIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBmcmFnbWVudCA9IGZpcnN0O1xuICAgICAgfVxuXG4gICAgICAvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcbiAgICAgIGlmIChmaXJzdCB8fCBpZ25vcmVkKSB7XG4gICAgICAgIHNjcmlwdHMgPSBqUXVlcnkubWFwKGdldEFsbChmcmFnbWVudCwgXCJzY3JpcHRcIiksIGRpc2FibGVTY3JpcHQpO1xuICAgICAgICBoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cbiAgICAgICAgLy8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcbiAgICAgICAgLy8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cbiAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gZnJhZ21lbnQ7XG5cbiAgICAgICAgICBpZiAoaSAhPT0gaU5vQ2xvbmUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBqUXVlcnkuY2xvbmUobm9kZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cbiAgICAgICAgICAgIGlmIChoYXNTY3JpcHRzKSB7XG4gICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuICAgICAgICAgICAgICAvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShzY3JpcHRzLCBnZXRBbGwobm9kZSwgXCJzY3JpcHRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY29sbGVjdGlvbltpXSwgbm9kZSwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xuICAgICAgICAgIGRvYyA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5vd25lckRvY3VtZW50O1xuXG4gICAgICAgICAgLy8gUmVlbmFibGUgc2NyaXB0c1xuICAgICAgICAgIGpRdWVyeS5tYXAoc2NyaXB0cywgcmVzdG9yZVNjcmlwdCk7XG5cbiAgICAgICAgICAvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKykge1xuICAgICAgICAgICAgbm9kZSA9IHNjcmlwdHNbaV07XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHJzY3JpcHRUeXBlLnRlc3Qobm9kZS50eXBlIHx8IFwiXCIpICYmXG4gICAgICAgICAgICAgICFkYXRhUHJpdi5hY2Nlc3Mobm9kZSwgXCJnbG9iYWxFdmFsXCIpICYmXG4gICAgICAgICAgICAgIGpRdWVyeS5jb250YWlucyhkb2MsIG5vZGUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuc3JjKSB7XG4gICAgICAgICAgICAgICAgLy8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5Ll9ldmFsVXJsKSB7XG4gICAgICAgICAgICAgICAgICBqUXVlcnkuX2V2YWxVcmwobm9kZS5zcmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBET01FdmFsKG5vZGUudGV4dENvbnRlbnQucmVwbGFjZShyY2xlYW5TY3JpcHQsIFwiXCIpLCBkb2MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUoZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhKSB7XG4gICAgdmFyIG5vZGUsXG4gICAgICBub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlcihzZWxlY3RvciwgZWxlbSkgOiBlbGVtLFxuICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgKG5vZGUgPSBub2Rlc1tpXSkgIT0gbnVsbDsgaSsrKSB7XG4gICAgICBpZiAoIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwobm9kZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMobm9kZS5vd25lckRvY3VtZW50LCBub2RlKSkge1xuICAgICAgICAgIHNldEdsb2JhbEV2YWwoZ2V0QWxsKG5vZGUsIFwic2NyaXB0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW07XG4gIH1cblxuICBqUXVlcnkuZXh0ZW5kKHtcbiAgICBodG1sUHJlZmlsdGVyOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIik7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbihlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cykge1xuICAgICAgdmFyIGksXG4gICAgICAgIGwsXG4gICAgICAgIHNyY0VsZW1lbnRzLFxuICAgICAgICBkZXN0RWxlbWVudHMsXG4gICAgICAgIGNsb25lID0gZWxlbS5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgIGluUGFnZSA9IGpRdWVyeS5jb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pO1xuXG4gICAgICAvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcbiAgICAgIGlmIChcbiAgICAgICAgIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiZcbiAgICAgICAgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEpICYmXG4gICAgICAgICFqUXVlcnkuaXNYTUxEb2MoZWxlbSlcbiAgICAgICkge1xuICAgICAgICAvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcbiAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lKTtcbiAgICAgICAgc3JjRWxlbWVudHMgPSBnZXRBbGwoZWxlbSk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGZpeElucHV0KHNyY0VsZW1lbnRzW2ldLCBkZXN0RWxlbWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcbiAgICAgIGlmIChkYXRhQW5kRXZlbnRzKSB7XG4gICAgICAgIGlmIChkZWVwRGF0YUFuZEV2ZW50cykge1xuICAgICAgICAgIHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKGVsZW0pO1xuICAgICAgICAgIGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoY2xvbmUpO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb25lQ29weUV2ZW50KGVsZW0sIGNsb25lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG4gICAgICBkZXN0RWxlbWVudHMgPSBnZXRBbGwoY2xvbmUsIFwic2NyaXB0XCIpO1xuICAgICAgaWYgKGRlc3RFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldEdsb2JhbEV2YWwoZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbChlbGVtLCBcInNjcmlwdFwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0sXG5cbiAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uKGVsZW1zKSB7XG4gICAgICB2YXIgZGF0YSxcbiAgICAgICAgZWxlbSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IChlbGVtID0gZWxlbXNbaV0pICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICBpZiAoYWNjZXB0RGF0YShlbGVtKSkge1xuICAgICAgICAgIGlmICgoZGF0YSA9IGVsZW1bZGF0YVByaXYuZXhwYW5kb10pKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5ldmVudHMpIHtcbiAgICAgICAgICAgICAgZm9yICh0eXBlIGluIGRhdGEuZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoZWxlbSwgdHlwZSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcbiAgICAgICAgICAgIC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuICAgICAgICAgICAgZWxlbVtkYXRhUHJpdi5leHBhbmRvXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsZW1bZGF0YVVzZXIuZXhwYW5kb10pIHtcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG4gICAgICAgICAgICAvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcbiAgICAgICAgICAgIGVsZW1bZGF0YVVzZXIuZXhwYW5kb10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICBkZXRhY2g6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlKHRoaXMsIHNlbGVjdG9yLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHJlbW92ZSh0aGlzLCBzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIHRleHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYWNjZXNzKFxuICAgICAgICB0aGlzLFxuICAgICAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGpRdWVyeS50ZXh0KHRoaXMpXG4gICAgICAgICAgICA6IHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPT09IDEgfHxcbiAgICAgICAgICAgICAgICAgIHRoaXMubm9kZVR5cGUgPT09IDExIHx8XG4gICAgICAgICAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSA5XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGFwcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9tTWFuaXAodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSAxIHx8XG4gICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHxcbiAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSA5XG4gICAgICAgICkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQodGhpcywgZWxlbSk7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcHJlcGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZG9tTWFuaXAodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSAxIHx8XG4gICAgICAgICAgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHxcbiAgICAgICAgICB0aGlzLm5vZGVUeXBlID09PSA5XG4gICAgICAgICkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQodGhpcywgZWxlbSk7XG4gICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBiZWZvcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRvbU1hbmlwKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFmdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb21NYW5pcCh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbSwgdGhpcy5uZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbSxcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKykge1xuICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwoZWxlbSwgZmFsc2UpKTtcblxuICAgICAgICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG4gICAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbihkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cykge1xuICAgICAgZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcbiAgICAgIGRlZXBEYXRhQW5kRXZlbnRzID1cbiAgICAgICAgZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4galF1ZXJ5LmNsb25lKHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBodG1sOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGFjY2VzcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF0gfHwge30sXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGwgPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmlubmVySFRNTDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhcm5vSW5uZXJodG1sLnRlc3QodmFsdWUpICYmXG4gICAgICAgICAgICAhd3JhcE1hcFsocnRhZ05hbWUuZXhlYyh2YWx1ZSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpXVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlcih2YWx1ZSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbaV0gfHwge307XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwoZWxlbSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWxlbSA9IDA7XG5cbiAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgICB0aGlzLmVtcHR5KCkuYXBwZW5kKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG51bGwsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoXG4gICAgICApO1xuICAgIH0sXG5cbiAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaWdub3JlZCA9IFtdO1xuXG4gICAgICAvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcbiAgICAgIHJldHVybiBkb21NYW5pcChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgYXJndW1lbnRzLFxuICAgICAgICBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgICAgICAgIGlmIChqUXVlcnkuaW5BcnJheSh0aGlzLCBpZ25vcmVkKSA8IDApIHtcbiAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKHRoaXMpKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChlbGVtLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIGlnbm9yZWRcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICBqUXVlcnkuZWFjaChcbiAgICB7XG4gICAgICBhcHBlbmRUbzogXCJhcHBlbmRcIixcbiAgICAgIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG4gICAgICBpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG4gICAgICBpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuICAgICAgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG4gICAgfSxcbiAgICBmdW5jdGlvbihuYW1lLCBvcmlnaW5hbCkge1xuICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGVsZW1zLFxuICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgIGluc2VydCA9IGpRdWVyeShzZWxlY3RvciksXG4gICAgICAgICAgbGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICAgIGZvciAoOyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICAgIGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKHRydWUpO1xuICAgICAgICAgIGpRdWVyeShpbnNlcnRbaV0pW29yaWdpbmFsXShlbGVtcyk7XG5cbiAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcbiAgICAgICAgICAvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG4gICAgICAgICAgcHVzaC5hcHBseShyZXQsIGVsZW1zLmdldCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhyZXQpO1xuICAgICAgfTtcbiAgICB9XG4gICk7XG4gIHZhciBybWFyZ2luID0gL15tYXJnaW4vO1xuXG4gIHZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIik7XG5cbiAgdmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG4gICAgLy8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG4gICAgLy8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG4gICAgdmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cbiAgICBpZiAoIXZpZXcgfHwgIXZpZXcub3BlbmVyKSB7XG4gICAgICB2aWV3ID0gd2luZG93O1xuICAgIH1cblxuICAgIHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gIH07XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuICAgIC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG4gICAgZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG4gICAgICBpZiAoIWRpdikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID1cbiAgICAgICAgXCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuICAgICAgICBcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7XCIgK1xuICAgICAgICBcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuICAgICAgICBcInRvcDoxJTt3aWR0aDo1MCVcIjtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdik7XG4gICAgICBwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcbiAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IGRpdlN0eWxlLm1hcmdpbkxlZnQgPT09IFwiMnB4XCI7XG4gICAgICBib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG4gICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG4gICAgICAvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3RcbiAgICAgIGRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCI7XG4gICAgICBwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cbiAgICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG4gICAgICAvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG4gICAgICBkaXYgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBwaXhlbFBvc2l0aW9uVmFsLFxuICAgICAgYm94U2l6aW5nUmVsaWFibGVWYWwsXG4gICAgICBwaXhlbE1hcmdpblJpZ2h0VmFsLFxuICAgICAgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuICAgIGlmICghZGl2LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgIC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcbiAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG4gICAgZGl2LmNsb25lTm9kZSh0cnVlKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG4gICAgc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID1cbiAgICAgIFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG4gICAgICBcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgalF1ZXJ5LmV4dGVuZChzdXBwb3J0LCB7XG4gICAgICBwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29tcHV0ZVN0eWxlVGVzdHMoKTtcbiAgICAgICAgcmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG4gICAgICB9LFxuICAgICAgYm94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb21wdXRlU3R5bGVUZXN0cygpO1xuICAgICAgICByZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG4gICAgICB9LFxuICAgICAgcGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgIHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuICAgICAgfSxcbiAgICAgIHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbXB1dGVTdHlsZVRlc3RzKCk7XG4gICAgICAgIHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gY3VyQ1NTKGVsZW0sIG5hbWUsIGNvbXB1dGVkKSB7XG4gICAgdmFyIHdpZHRoLFxuICAgICAgbWluV2lkdGgsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJldCxcbiAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG4gICAgICAvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG4gICAgICAvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG4gICAgICAvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlO1xuXG4gICAgY29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoZWxlbSk7XG5cbiAgICAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG4gICAgLy8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG4gICAgLy8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG4gICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICByZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIHx8IGNvbXB1dGVkW25hbWVdO1xuXG4gICAgICBpZiAocmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSkge1xuICAgICAgICByZXQgPSBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcbiAgICAgIC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuICAgICAgLy8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cbiAgICAgIC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcbiAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG4gICAgICBpZiAoXG4gICAgICAgICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJlxuICAgICAgICBybnVtbm9ucHgudGVzdChyZXQpICYmXG4gICAgICAgIHJtYXJnaW4udGVzdChuYW1lKVxuICAgICAgKSB7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgbWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcbiAgICAgICAgbWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuICAgICAgICAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG4gICAgICAgIHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcbiAgICAgICAgcmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuICAgICAgICBzdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyAvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG4gICAgICAgIC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG4gICAgICAgIHJldCArIFwiXCJcbiAgICAgIDogcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkR2V0SG9va0lmKGNvbmRpdGlvbkZuLCBob29rRm4pIHtcbiAgICAvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuICAgIHJldHVybiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY29uZGl0aW9uRm4oKSkge1xuICAgICAgICAgIC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuICAgICAgICAgIC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cbiAgICAgICAgICBkZWxldGUgdGhpcy5nZXQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG4gICAgICAgIHJldHVybiAodGhpcy5nZXQgPSBob29rRm4pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciAvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG4gICAgLy8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG4gICAgLy8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG4gICAgcmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuICAgIHJjdXN0b21Qcm9wID0gL14tLS8sXG4gICAgY3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG4gICAgY3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuICAgICAgbGV0dGVyU3BhY2luZzogXCIwXCIsXG4gICAgICBmb250V2VpZ2h0OiBcIjQwMFwiXG4gICAgfSxcbiAgICBjc3NQcmVmaXhlcyA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCJdLFxuICAgIGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO1xuXG4gIC8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbiAgZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUobmFtZSkge1xuICAgIC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuICAgIHZhciBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcbiAgICAgIGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBuYW1lID0gY3NzUHJlZml4ZXNbaV0gKyBjYXBOYW1lO1xuICAgICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cbiAgLy8gYSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkuXG4gIGZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUobmFtZSkge1xuICAgIHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbbmFtZV07XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHJldCA9IGpRdWVyeS5jc3NQcm9wc1tuYW1lXSA9IHZlbmRvclByb3BOYW1lKG5hbWUpIHx8IG5hbWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlcihlbGVtLCB2YWx1ZSwgc3VidHJhY3QpIHtcbiAgICAvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG4gICAgLy8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG4gICAgdmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWModmFsdWUpO1xuICAgIHJldHVybiBtYXRjaGVzXG4gICAgICA/IC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG4gICAgICAgIE1hdGgubWF4KDAsIG1hdGNoZXNbMl0gLSAoc3VidHJhY3QgfHwgMCkpICsgKG1hdGNoZXNbM10gfHwgXCJweFwiKVxuICAgICAgOiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzKSB7XG4gICAgdmFyIGksXG4gICAgICB2YWwgPSAwO1xuXG4gICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXG4gICAgaWYgKGV4dHJhID09PSAoaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpKSB7XG4gICAgICBpID0gNDtcblxuICAgICAgLy8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuICAgIH0gZWxzZSB7XG4gICAgICBpID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDA7XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCA0OyBpICs9IDIpIHtcbiAgICAgIC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcbiAgICAgIGlmIChleHRyYSA9PT0gXCJtYXJnaW5cIikge1xuICAgICAgICB2YWwgKz0galF1ZXJ5LmNzcyhlbGVtLCBleHRyYSArIGNzc0V4cGFuZFtpXSwgdHJ1ZSwgc3R5bGVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQm9yZGVyQm94KSB7XG4gICAgICAgIC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuICAgICAgICBpZiAoZXh0cmEgPT09IFwiY29udGVudFwiKSB7XG4gICAgICAgICAgdmFsIC09IGpRdWVyeS5jc3MoZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbaV0sIHRydWUsIHN0eWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuICAgICAgICBpZiAoZXh0cmEgIT09IFwibWFyZ2luXCIpIHtcbiAgICAgICAgICB2YWwgLT0galF1ZXJ5LmNzcyhcbiAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIHN0eWxlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG4gICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcbiAgICAgICAgaWYgKGV4dHJhICE9PSBcInBhZGRpbmdcIikge1xuICAgICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKFxuICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbaV0gKyBcIldpZHRoXCIsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgc3R5bGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhKSB7XG4gICAgLy8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuICAgIHZhciB2YWx1ZUlzQm9yZGVyQm94LFxuICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pLFxuICAgICAgdmFsID0gY3VyQ1NTKGVsZW0sIG5hbWUsIHN0eWxlcyksXG4gICAgICBpc0JvcmRlckJveCA9XG4gICAgICAgIGpRdWVyeS5jc3MoZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcykgPT09IFwiYm9yZGVyLWJveFwiO1xuXG4gICAgLy8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cbiAgICBpZiAocm51bW5vbnB4LnRlc3QodmFsKSkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuICAgIC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcbiAgICB2YWx1ZUlzQm9yZGVyQm94ID1cbiAgICAgIGlzQm9yZGVyQm94ICYmIChzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlW25hbWVdKTtcblxuICAgIC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9IZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuICAgIC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcbiAgICBpZiAodmFsID09PSBcImF1dG9cIikge1xuICAgICAgdmFsID0gZWxlbVtcIm9mZnNldFwiICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKV07XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKSB8fCAwO1xuXG4gICAgLy8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcbiAgICByZXR1cm4gKFxuICAgICAgdmFsICtcbiAgICAgIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuICAgICAgICBlbGVtLFxuICAgICAgICBuYW1lLFxuICAgICAgICBleHRyYSB8fCAoaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpLFxuICAgICAgICB2YWx1ZUlzQm9yZGVyQm94LFxuICAgICAgICBzdHlsZXNcbiAgICAgICkgK1xuICAgICAgXCJweFwiXG4gICAgKTtcbiAgfVxuXG4gIGpRdWVyeS5leHRlbmQoe1xuICAgIC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuICAgIC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuICAgIGNzc0hvb2tzOiB7XG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oZWxlbSwgY29tcHV0ZWQpIHtcbiAgICAgICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG4gICAgICAgICAgICB2YXIgcmV0ID0gY3VyQ1NTKGVsZW0sIFwib3BhY2l0eVwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcbiAgICBjc3NOdW1iZXI6IHtcbiAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICAgICAgY29sdW1uQ291bnQ6IHRydWUsXG4gICAgICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgICAgIGZsZXhHcm93OiB0cnVlLFxuICAgICAgZmxleFNocmluazogdHJ1ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgICAgb3BhY2l0eTogdHJ1ZSxcbiAgICAgIG9yZGVyOiB0cnVlLFxuICAgICAgb3JwaGFuczogdHJ1ZSxcbiAgICAgIHdpZG93czogdHJ1ZSxcbiAgICAgIHpJbmRleDogdHJ1ZSxcbiAgICAgIHpvb206IHRydWVcbiAgICB9LFxuXG4gICAgLy8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuICAgIC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcbiAgICBjc3NQcm9wczoge1xuICAgICAgZmxvYXQ6IFwiY3NzRmxvYXRcIlxuICAgIH0sXG5cbiAgICAvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuICAgIHN0eWxlOiBmdW5jdGlvbihlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEpIHtcbiAgICAgIC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuICAgICAgaWYgKCFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuICAgICAgdmFyIHJldCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaG9va3MsXG4gICAgICAgIG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZShuYW1lKSxcbiAgICAgICAgaXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdChuYW1lKSxcbiAgICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcbiAgICAgIC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cbiAgICAgIGlmICghaXNDdXN0b21Qcm9wKSB7XG4gICAgICAgIG5hbWUgPSBmaW5hbFByb3BOYW1lKG9yaWdOYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cbiAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdIHx8IGpRdWVyeS5jc3NIb29rc1tvcmlnTmFtZV07XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgICAgICAvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG4gICAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIChyZXQgPSByY3NzTnVtLmV4ZWModmFsdWUpKSAmJiByZXRbMV0pIHtcbiAgICAgICAgICB2YWx1ZSA9IGFkanVzdENTUyhlbGVtLCBuYW1lLCByZXQpO1xuXG4gICAgICAgICAgLy8gRml4ZXMgYnVnICM5MjM3XG4gICAgICAgICAgdHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcbiAgICAgICAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB2YWx1ZSArPSAocmV0ICYmIHJldFszXSkgfHwgKGpRdWVyeS5jc3NOdW1iZXJbb3JpZ05hbWVdID8gXCJcIiA6IFwicHhcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiZcbiAgICAgICAgICB2YWx1ZSA9PT0gXCJcIiAmJlxuICAgICAgICAgIG5hbWUuaW5kZXhPZihcImJhY2tncm91bmRcIikgPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgc3R5bGVbbmFtZV0gPSBcImluaGVyaXRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWhvb2tzIHx8XG4gICAgICAgICAgIShcInNldFwiIGluIGhvb2tzKSB8fFxuICAgICAgICAgICh2YWx1ZSA9IGhvb2tzLnNldChlbGVtLCB2YWx1ZSwgZXh0cmEpKSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChpc0N1c3RvbVByb3ApIHtcbiAgICAgICAgICAgIHN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgaG9va3MgJiZcbiAgICAgICAgICBcImdldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgKHJldCA9IGhvb2tzLmdldChlbGVtLCBmYWxzZSwgZXh0cmEpKSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuICAgICAgICByZXR1cm4gc3R5bGVbbmFtZV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNzczogZnVuY3Rpb24oZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcykge1xuICAgICAgdmFyIHZhbCxcbiAgICAgICAgbnVtLFxuICAgICAgICBob29rcyxcbiAgICAgICAgb3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKG5hbWUpLFxuICAgICAgICBpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KG5hbWUpO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG4gICAgICAvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcCkge1xuICAgICAgICBuYW1lID0gZmluYWxQcm9wTmFtZShvcmlnTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcbiAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdIHx8IGpRdWVyeS5jc3NIb29rc1tvcmlnTmFtZV07XG5cbiAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG4gICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcykge1xuICAgICAgICB2YWwgPSBob29rcy5nZXQoZWxlbSwgdHJ1ZSwgZXh0cmEpO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcbiAgICAgIGlmICh2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgdmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtW25hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcbiAgICAgIGlmIChleHRyYSA9PT0gXCJcIiB8fCBleHRyYSkge1xuICAgICAgICBudW0gPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgIHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZShudW0pID8gbnVtIHx8IDAgOiB2YWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9KTtcblxuICBqUXVlcnkuZWFjaChbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiXSwgZnVuY3Rpb24oaSwgbmFtZSkge1xuICAgIGpRdWVyeS5jc3NIb29rc1tuYW1lXSA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24oZWxlbSwgY29tcHV0ZWQsIGV4dHJhKSB7XG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgIC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuICAgICAgICAgIC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG4gICAgICAgICAgcmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpKSAmJlxuICAgICAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDgrXG4gICAgICAgICAgICAvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuICAgICAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgICAgICAgLy8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuICAgICAgICAgICAgLy8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICAgICAgKCFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKVxuICAgICAgICAgICAgPyBzd2FwKGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogZ2V0V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24oZWxlbSwgdmFsdWUsIGV4dHJhKSB7XG4gICAgICAgIHZhciBtYXRjaGVzLFxuICAgICAgICAgIHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyhlbGVtKSxcbiAgICAgICAgICBzdWJ0cmFjdCA9XG4gICAgICAgICAgICBleHRyYSAmJlxuICAgICAgICAgICAgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG4gICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMpID09PSBcImJvcmRlci1ib3hcIixcbiAgICAgICAgICAgICAgc3R5bGVzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdWJ0cmFjdCAmJlxuICAgICAgICAgIChtYXRjaGVzID0gcmNzc051bS5leGVjKHZhbHVlKSkgJiZcbiAgICAgICAgICAobWF0Y2hlc1szXSB8fCBcInB4XCIpICE9PSBcInB4XCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgZWxlbS5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlID0galF1ZXJ5LmNzcyhlbGVtLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXRQb3NpdGl2ZU51bWJlcihlbGVtLCB2YWx1ZSwgc3VidHJhY3QpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIGpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKFxuICAgIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuICAgIGZ1bmN0aW9uKGVsZW0sIGNvbXB1dGVkKSB7XG4gICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAocGFyc2VGbG9hdChjdXJDU1MoZWxlbSwgXCJtYXJnaW5MZWZ0XCIpKSB8fFxuICAgICAgICAgICAgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cbiAgICAgICAgICAgICAgc3dhcChlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgICAgICAgfSkpICsgXCJweFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICApO1xuXG4gIC8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbiAgalF1ZXJ5LmVhY2goXG4gICAge1xuICAgICAgbWFyZ2luOiBcIlwiLFxuICAgICAgcGFkZGluZzogXCJcIixcbiAgICAgIGJvcmRlcjogXCJXaWR0aFwiXG4gICAgfSxcbiAgICBmdW5jdGlvbihwcmVmaXgsIHN1ZmZpeCkge1xuICAgICAgalF1ZXJ5LmNzc0hvb2tzW3ByZWZpeCArIHN1ZmZpeF0gPSB7XG4gICAgICAgIGV4cGFuZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBleHBhbmRlZCA9IHt9LFxuICAgICAgICAgICAgLy8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG4gICAgICAgICAgICBwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KFwiIFwiKSA6IFt2YWx1ZV07XG5cbiAgICAgICAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgZXhwYW5kZWRbcHJlZml4ICsgY3NzRXhwYW5kW2ldICsgc3VmZml4XSA9XG4gICAgICAgICAgICAgIHBhcnRzW2ldIHx8IHBhcnRzW2kgLSAyXSB8fCBwYXJ0c1swXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICghcm1hcmdpbi50ZXN0KHByZWZpeCkpIHtcbiAgICAgICAgalF1ZXJ5LmNzc0hvb2tzW3ByZWZpeCArIHN1ZmZpeF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG4gICAgICB9XG4gICAgfVxuICApO1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIGNzczogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBhY2Nlc3MoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGZ1bmN0aW9uKGVsZW0sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHN0eWxlcyxcbiAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgIG1hcCA9IHt9LFxuICAgICAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pO1xuICAgICAgICAgICAgbGVuID0gbmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgbWFwW25hbWVbaV1dID0galF1ZXJ5LmNzcyhlbGVtLCBuYW1lW2ldLCBmYWxzZSwgc3R5bGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSwgdmFsdWUpXG4gICAgICAgICAgICA6IGpRdWVyeS5jc3MoZWxlbSwgbmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIFR3ZWVuKGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdChlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyk7XG4gIH1cbiAgalF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cbiAgVHdlZW4ucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBUd2VlbixcbiAgICBpbml0OiBmdW5jdGlvbihlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCkge1xuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMucHJvcCA9IHByb3A7XG4gICAgICB0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG4gICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gPyBcIlwiIDogXCJweFwiKTtcbiAgICB9LFxuICAgIGN1cjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtcblxuICAgICAgcmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldFxuICAgICAgICA/IGhvb2tzLmdldCh0aGlzKVxuICAgICAgICA6IFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQodGhpcyk7XG4gICAgfSxcbiAgICBydW46IGZ1bmN0aW9uKHBlcmNlbnQpIHtcbiAgICAgIHZhciBlYXNlZCxcbiAgICAgICAgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1t0aGlzLmVhc2luZ10oXG4gICAgICAgICAgcGVyY2VudCxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMSxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZHVyYXRpb25cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuICAgICAgfVxuICAgICAgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGVwKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChob29rcyAmJiBob29rcy5zZXQpIHtcbiAgICAgICAgaG9va3Muc2V0KHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICBUd2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cbiAgVHdlZW4ucHJvcEhvb2tzID0ge1xuICAgIF9kZWZhdWx0OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKHR3ZWVuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgLy8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcbiAgICAgICAgLy8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcbiAgICAgICAgICAodHdlZW4uZWxlbVt0d2Vlbi5wcm9wXSAhPSBudWxsICYmXG4gICAgICAgICAgICB0d2Vlbi5lbGVtLnN0eWxlW3R3ZWVuLnByb3BdID09IG51bGwpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG4gICAgICAgIC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuICAgICAgICAvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuICAgICAgICByZXN1bHQgPSBqUXVlcnkuY3NzKHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIpO1xuXG4gICAgICAgIC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuICAgICAgICByZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHR3ZWVuKSB7XG4gICAgICAgIC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuICAgICAgICAvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG4gICAgICAgIC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG4gICAgICAgIGlmIChqUXVlcnkuZnguc3RlcFt0d2Vlbi5wcm9wXSkge1xuICAgICAgICAgIGpRdWVyeS5meC5zdGVwW3R3ZWVuLnByb3BdKHR3ZWVuKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgKHR3ZWVuLmVsZW0uc3R5bGVbalF1ZXJ5LmNzc1Byb3BzW3R3ZWVuLnByb3BdXSAhPSBudWxsIHx8XG4gICAgICAgICAgICBqUXVlcnkuY3NzSG9va3NbdHdlZW4ucHJvcF0pXG4gICAgICAgICkge1xuICAgICAgICAgIGpRdWVyeS5zdHlsZSh0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdID0gdHdlZW4ubm93O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4gIC8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuICBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG4gICAgc2V0OiBmdW5jdGlvbih0d2Vlbikge1xuICAgICAgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlKSB7XG4gICAgICAgIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gPSB0d2Vlbi5ub3c7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGpRdWVyeS5lYXNpbmcgPSB7XG4gICAgbGluZWFyOiBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIHN3aW5nOiBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gMC41IC0gTWF0aC5jb3MocCAqIE1hdGguUEkpIC8gMjtcbiAgICB9LFxuICAgIF9kZWZhdWx0OiBcInN3aW5nXCJcbiAgfTtcblxuICBqUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuICAvLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxuICBqUXVlcnkuZnguc3RlcCA9IHt9O1xuXG4gIHZhciBmeE5vdyxcbiAgICBpblByb2dyZXNzLFxuICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuICAgIHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuICAgIGlmIChpblByb2dyZXNzKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2NoZWR1bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCk7XG4gICAgICB9XG5cbiAgICAgIGpRdWVyeS5meC50aWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuICBmdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGZ4Tm93ID0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHJldHVybiAoZnhOb3cgPSBqUXVlcnkubm93KCkpO1xuICB9XG5cbiAgLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbiAgZnVuY3Rpb24gZ2VuRngodHlwZSwgaW5jbHVkZVdpZHRoKSB7XG4gICAgdmFyIHdoaWNoLFxuICAgICAgaSA9IDAsXG4gICAgICBhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cbiAgICAvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG4gICAgLy8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcbiAgICBpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcbiAgICBmb3IgKDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCkge1xuICAgICAgd2hpY2ggPSBjc3NFeHBhbmRbaV07XG4gICAgICBhdHRyc1tcIm1hcmdpblwiICsgd2hpY2hdID0gYXR0cnNbXCJwYWRkaW5nXCIgKyB3aGljaF0gPSB0eXBlO1xuICAgIH1cblxuICAgIGlmIChpbmNsdWRlV2lkdGgpIHtcbiAgICAgIGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVHdlZW4odmFsdWUsIHByb3AsIGFuaW1hdGlvbikge1xuICAgIHZhciB0d2VlbixcbiAgICAgIGNvbGxlY3Rpb24gPSAoQW5pbWF0aW9uLnR3ZWVuZXJzW3Byb3BdIHx8IFtdKS5jb25jYXQoXG4gICAgICAgIEFuaW1hdGlvbi50d2VlbmVyc1tcIipcIl1cbiAgICAgICksXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmICgodHdlZW4gPSBjb2xsZWN0aW9uW2luZGV4XS5jYWxsKGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUpKSkge1xuICAgICAgICAvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gdHdlZW47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlcihlbGVtLCBwcm9wcywgb3B0cykge1xuICAgIHZhciBwcm9wLFxuICAgICAgdmFsdWUsXG4gICAgICB0b2dnbGUsXG4gICAgICBob29rcyxcbiAgICAgIG9sZGZpcmUsXG4gICAgICBwcm9wVHdlZW4sXG4gICAgICByZXN0b3JlRGlzcGxheSxcbiAgICAgIGRpc3BsYXksXG4gICAgICBpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuICAgICAgYW5pbSA9IHRoaXMsXG4gICAgICBvcmlnID0ge30sXG4gICAgICBzdHlsZSA9IGVsZW0uc3R5bGUsXG4gICAgICBoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZShlbGVtKSxcbiAgICAgIGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KGVsZW0sIFwiZnhzaG93XCIpO1xuXG4gICAgLy8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG4gICAgaWYgKCFvcHRzLnF1ZXVlKSB7XG4gICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyhlbGVtLCBcImZ4XCIpO1xuICAgICAgaWYgKGhvb2tzLnVucXVldWVkID09IG51bGwpIHtcbiAgICAgICAgaG9va3MudW5xdWV1ZWQgPSAwO1xuICAgICAgICBvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcbiAgICAgICAgaG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghaG9va3MudW5xdWV1ZWQpIHtcbiAgICAgICAgICAgIG9sZGZpcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBob29rcy51bnF1ZXVlZCsrO1xuXG4gICAgICBhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcbiAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaG9va3MudW5xdWV1ZWQtLTtcbiAgICAgICAgICBpZiAoIWpRdWVyeS5xdWV1ZShlbGVtLCBcImZ4XCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgaG9va3MuZW1wdHkuZmlyZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcbiAgICBmb3IgKHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIHZhbHVlID0gcHJvcHNbcHJvcF07XG4gICAgICBpZiAocmZ4dHlwZXMudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BdO1xuICAgICAgICB0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gKGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIpKSB7XG4gICAgICAgICAgLy8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuICAgICAgICAgIC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1twcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoaWRkZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcmlnW3Byb3BdID0gKGRhdGFTaG93ICYmIGRhdGFTaG93W3Byb3BdKSB8fCBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcbiAgICBwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QocHJvcHMpO1xuICAgIGlmICghcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KG9yaWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG4gICAgaWYgKGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcbiAgICAgIC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuICAgICAgLy8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1lcbiAgICAgIG9wdHMub3ZlcmZsb3cgPSBbc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZXTtcblxuICAgICAgLy8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG4gICAgICByZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG4gICAgICBpZiAocmVzdG9yZURpc3BsYXkgPT0gbnVsbCkge1xuICAgICAgICByZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldChlbGVtLCBcImRpc3BsYXlcIik7XG4gICAgICB9XG4gICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIik7XG4gICAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgaWYgKHJlc3RvcmVEaXNwbGF5KSB7XG4gICAgICAgICAgZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcbiAgICAgICAgICBzaG93SGlkZShbZWxlbV0sIHRydWUpO1xuICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuICAgICAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKGVsZW0sIFwiZGlzcGxheVwiKTtcbiAgICAgICAgICBzaG93SGlkZShbZWxlbV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuICAgICAgaWYgKFxuICAgICAgICBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8XG4gICAgICAgIChkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwpXG4gICAgICApIHtcbiAgICAgICAgaWYgKGpRdWVyeS5jc3MoZWxlbSwgXCJmbG9hdFwiKSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuICAgICAgICAgIGlmICghcHJvcFR3ZWVuKSB7XG4gICAgICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3RvcmVEaXNwbGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICAgIHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0cy5vdmVyZmxvdykge1xuICAgICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1swXTtcbiAgICAgICAgc3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sxXTtcbiAgICAgICAgc3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1syXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuICAgIHByb3BUd2VlbiA9IGZhbHNlO1xuICAgIGZvciAocHJvcCBpbiBvcmlnKSB7XG4gICAgICAvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuICAgICAgaWYgKCFwcm9wVHdlZW4pIHtcbiAgICAgICAgaWYgKGRhdGFTaG93KSB7XG4gICAgICAgICAgaWYgKFwiaGlkZGVuXCIgaW4gZGF0YVNob3cpIHtcbiAgICAgICAgICAgIGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoZWxlbSwgXCJmeHNob3dcIiwge1xuICAgICAgICAgICAgZGlzcGxheTogcmVzdG9yZURpc3BsYXlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuICAgICAgICBpZiAodG9nZ2xlKSB7XG4gICAgICAgICAgZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG4gICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICBzaG93SGlkZShbZWxlbV0sIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cbiAgICAgICAgYW5pbS5kb25lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cbiAgICAgICAgICAvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcbiAgICAgICAgICBpZiAoIWhpZGRlbikge1xuICAgICAgICAgICAgc2hvd0hpZGUoW2VsZW1dKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVByaXYucmVtb3ZlKGVsZW0sIFwiZnhzaG93XCIpO1xuICAgICAgICAgIGZvciAocHJvcCBpbiBvcmlnKSB7XG4gICAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgb3JpZ1twcm9wXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUGVyLXByb3BlcnR5IHNldHVwXG4gICAgICBwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbihoaWRkZW4gPyBkYXRhU2hvd1twcm9wXSA6IDAsIHByb3AsIGFuaW0pO1xuICAgICAgaWYgKCEocHJvcCBpbiBkYXRhU2hvdykpIHtcbiAgICAgICAgZGF0YVNob3dbcHJvcF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG4gICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICBwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuICAgICAgICAgIHByb3BUd2Vlbi5zdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wRmlsdGVyKHByb3BzLCBzcGVjaWFsRWFzaW5nKSB7XG4gICAgdmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuICAgIC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuICAgIGZvciAoaW5kZXggaW4gcHJvcHMpIHtcbiAgICAgIG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKGluZGV4KTtcbiAgICAgIGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbbmFtZV07XG4gICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBlYXNpbmcgPSB2YWx1ZVsxXTtcbiAgICAgICAgdmFsdWUgPSBwcm9wc1tpbmRleF0gPSB2YWx1ZVswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICE9PSBuYW1lKSB7XG4gICAgICAgIHByb3BzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGRlbGV0ZSBwcm9wc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdO1xuICAgICAgaWYgKGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MpIHtcbiAgICAgICAgdmFsdWUgPSBob29rcy5leHBhbmQodmFsdWUpO1xuICAgICAgICBkZWxldGUgcHJvcHNbbmFtZV07XG5cbiAgICAgICAgLy8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuICAgICAgICAvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG4gICAgICAgIGZvciAoaW5kZXggaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAoIShpbmRleCBpbiBwcm9wcykpIHtcbiAgICAgICAgICAgIHByb3BzW2luZGV4XSA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgIHNwZWNpYWxFYXNpbmdbaW5kZXhdID0gZWFzaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlY2lhbEVhc2luZ1tuYW1lXSA9IGVhc2luZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBBbmltYXRpb24oZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHQsXG4gICAgICBzdG9wcGVkLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuICAgICAgICBkZWxldGUgdGljay5lbGVtO1xuICAgICAgfSksXG4gICAgICB0aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG4gICAgICAgICAgcmVtYWluaW5nID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG4gICAgICAgICAgLy8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuICAgICAgICAgIHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcbiAgICAgICAgICBwZXJjZW50ID0gMSAtIHRlbXAsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnNbaW5kZXhdLnJ1bihwZXJjZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nXSk7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuICAgICAgICBpZiAocGVyY2VudCA8IDEgJiYgbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgMSwgMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbl0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgYW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XG4gICAgICAgIGVsZW06IGVsZW0sXG4gICAgICAgIHByb3BzOiBqUXVlcnkuZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKSxcbiAgICAgICAgb3B0czogalF1ZXJ5LmV4dGVuZChcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNwZWNpYWxFYXNpbmc6IHt9LFxuICAgICAgICAgICAgZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICksXG4gICAgICAgIG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgb3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICB0d2VlbnM6IFtdLFxuICAgICAgICBjcmVhdGVUd2VlbjogZnVuY3Rpb24ocHJvcCwgZW5kKSB7XG4gICAgICAgICAgdmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKFxuICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgIGFuaW1hdGlvbi5vcHRzLFxuICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbcHJvcF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhbmltYXRpb24udHdlZW5zLnB1c2godHdlZW4pO1xuICAgICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24oZ290b0VuZCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuICAgICAgICAgICAgbGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcbiAgICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG4gICAgICAgICAgaWYgKGdvdG9FbmQpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgMSwgMF0pO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgZ290b0VuZF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKGVsZW0sIFthbmltYXRpb24sIGdvdG9FbmRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgcHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cbiAgICBwcm9wRmlsdGVyKHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nKTtcblxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbaW5kZXhdLmNhbGwoXG4gICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgZWxlbSxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGFuaW1hdGlvbi5vcHRzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ocmVzdWx0LnN0b3ApKSB7XG4gICAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKFxuICAgICAgICAgICAgYW5pbWF0aW9uLmVsZW0sXG4gICAgICAgICAgICBhbmltYXRpb24ub3B0cy5xdWV1ZVxuICAgICAgICAgICkuc3RvcCA9IGpRdWVyeS5wcm94eShyZXN1bHQuc3RvcCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGpRdWVyeS5tYXAocHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24pO1xuXG4gICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGFuaW1hdGlvbi5vcHRzLnN0YXJ0KSkge1xuICAgICAgYW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbChlbGVtLCBhbmltYXRpb24pO1xuICAgIH1cblxuICAgIC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG4gICAgYW5pbWF0aW9uXG4gICAgICAucHJvZ3Jlc3MoYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MpXG4gICAgICAuZG9uZShhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSlcbiAgICAgIC5mYWlsKGFuaW1hdGlvbi5vcHRzLmZhaWwpXG4gICAgICAuYWx3YXlzKGFuaW1hdGlvbi5vcHRzLmFsd2F5cyk7XG5cbiAgICBqUXVlcnkuZngudGltZXIoXG4gICAgICBqUXVlcnkuZXh0ZW5kKHRpY2ssIHtcbiAgICAgICAgZWxlbTogZWxlbSxcbiAgICAgICAgYW5pbTogYW5pbWF0aW9uLFxuICAgICAgICBxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHJldHVybiBhbmltYXRpb247XG4gIH1cblxuICBqUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZChBbmltYXRpb24sIHtcbiAgICB0d2VlbmVyczoge1xuICAgICAgXCIqXCI6IFtcbiAgICAgICAgZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKHByb3AsIHZhbHVlKTtcbiAgICAgICAgICBhZGp1c3RDU1ModHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKHZhbHVlKSwgdHdlZW4pO1xuICAgICAgICAgIHJldHVybiB0d2VlbjtcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG5cbiAgICB0d2VlbmVyOiBmdW5jdGlvbihwcm9wcywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihwcm9wcykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBwcm9wcztcbiAgICAgICAgcHJvcHMgPSBbXCIqXCJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wcy5tYXRjaChybm90aHRtbHdoaXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3AsXG4gICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgcHJvcCA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgQW5pbWF0aW9uLnR3ZWVuZXJzW3Byb3BdID0gQW5pbWF0aW9uLnR3ZWVuZXJzW3Byb3BdIHx8IFtdO1xuICAgICAgICBBbmltYXRpb24udHdlZW5lcnNbcHJvcF0udW5zaGlmdChjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHByZWZpbHRlcnM6IFtkZWZhdWx0UHJlZmlsdGVyXSxcblxuICAgIHByZWZpbHRlcjogZnVuY3Rpb24oY2FsbGJhY2ssIHByZXBlbmQpIHtcbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaChjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBqUXVlcnkuc3BlZWQgPSBmdW5jdGlvbihzcGVlZCwgZWFzaW5nLCBmbikge1xuICAgIHZhciBvcHQgPVxuICAgICAgc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiXG4gICAgICAgID8galF1ZXJ5LmV4dGVuZCh7fSwgc3BlZWQpXG4gICAgICAgIDoge1xuICAgICAgICAgICAgY29tcGxldGU6XG4gICAgICAgICAgICAgIGZuIHx8ICghZm4gJiYgZWFzaW5nKSB8fCAoalF1ZXJ5LmlzRnVuY3Rpb24oc3BlZWQpICYmIHNwZWVkKSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzcGVlZCxcbiAgICAgICAgICAgIGVhc2luZzpcbiAgICAgICAgICAgICAgKGZuICYmIGVhc2luZykgfHwgKGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oZWFzaW5nKSAmJiBlYXNpbmcpXG4gICAgICAgICAgfTtcblxuICAgIC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuICAgIGlmIChqUXVlcnkuZngub2ZmKSB7XG4gICAgICBvcHQuZHVyYXRpb24gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAob3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMpIHtcbiAgICAgICAgICBvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzW29wdC5kdXJhdGlvbl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuICAgIGlmIChvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUpIHtcbiAgICAgIG9wdC5xdWV1ZSA9IFwiZnhcIjtcbiAgICB9XG5cbiAgICAvLyBRdWV1ZWluZ1xuICAgIG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cbiAgICBvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihvcHQub2xkKSkge1xuICAgICAgICBvcHQub2xkLmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHQucXVldWUpIHtcbiAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgb3B0LnF1ZXVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIG9wdDtcbiAgfTtcblxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICBmYWRlVG86IGZ1bmN0aW9uKHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgLy8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLmZpbHRlcihpc0hpZGRlbldpdGhpblRyZWUpXG4gICAgICAgICAgLmNzcyhcIm9wYWNpdHlcIiwgMClcbiAgICAgICAgICAuc2hvdygpXG5cbiAgICAgICAgICAvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgICAuZW5kKClcbiAgICAgICAgICAuYW5pbWF0ZSh7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdChwcm9wKSxcbiAgICAgICAgb3B0YWxsID0galF1ZXJ5LnNwZWVkKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSxcbiAgICAgICAgZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuICAgICAgICAgIHZhciBhbmltID0gQW5pbWF0aW9uKHRoaXMsIGpRdWVyeS5leHRlbmQoe30sIHByb3ApLCBvcHRhbGwpO1xuXG4gICAgICAgICAgLy8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgaWYgKGVtcHR5IHx8IGRhdGFQcml2LmdldCh0aGlzLCBcImZpbmlzaFwiKSkge1xuICAgICAgICAgICAgYW5pbS5zdG9wKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG4gICAgICByZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZVxuICAgICAgICA/IHRoaXMuZWFjaChkb0FuaW1hdGlvbilcbiAgICAgICAgOiB0aGlzLnF1ZXVlKG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24pO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24odHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCkge1xuICAgICAgdmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKGhvb2tzKSB7XG4gICAgICAgIHZhciBzdG9wID0gaG9va3Muc3RvcDtcbiAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XG4gICAgICAgIHN0b3AoZ290b0VuZCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZ290b0VuZCA9IGNsZWFyUXVldWU7XG4gICAgICAgIGNsZWFyUXVldWUgPSB0eXBlO1xuICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVxdWV1ZSA9IHRydWUsXG4gICAgICAgICAgaW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG4gICAgICAgICAgZGF0YSA9IGRhdGFQcml2LmdldCh0aGlzKTtcblxuICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICBpZiAoZGF0YVtpbmRleF0gJiYgZGF0YVtpbmRleF0uc3RvcCkge1xuICAgICAgICAgICAgc3RvcFF1ZXVlKGRhdGFbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpbmRleCBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtpbmRleF0gJiYgZGF0YVtpbmRleF0uc3RvcCAmJiBycnVuLnRlc3QoaW5kZXgpKSB7XG4gICAgICAgICAgICAgIHN0b3BRdWV1ZShkYXRhW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRpbWVyc1tpbmRleF0uZWxlbSA9PT0gdGhpcyAmJlxuICAgICAgICAgICAgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbaW5kZXhdLnF1ZXVlID09PSB0eXBlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGltZXJzW2luZGV4XS5hbmltLnN0b3AoZ290b0VuZCk7XG4gICAgICAgICAgICBkZXF1ZXVlID0gZmFsc2U7XG4gICAgICAgICAgICB0aW1lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuICAgICAgICAvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG4gICAgICAgIC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cbiAgICAgICAgaWYgKGRlcXVldWUgfHwgIWdvdG9FbmQpIHtcbiAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICE9PSBmYWxzZSkge1xuICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgZGF0YSA9IGRhdGFQcml2LmdldCh0aGlzKSxcbiAgICAgICAgICBxdWV1ZSA9IGRhdGFbdHlwZSArIFwicXVldWVcIl0sXG4gICAgICAgICAgaG9va3MgPSBkYXRhW3R5cGUgKyBcInF1ZXVlSG9va3NcIl0sXG4gICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcbiAgICAgICAgICBsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgLy8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuICAgICAgICBkYXRhLmZpbmlzaCA9IHRydWU7XG5cbiAgICAgICAgLy8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG4gICAgICAgIGpRdWVyeS5xdWV1ZSh0aGlzLCB0eXBlLCBbXSk7XG5cbiAgICAgICAgaWYgKGhvb2tzICYmIGhvb2tzLnN0b3ApIHtcbiAgICAgICAgICBob29rcy5zdG9wLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuICAgICAgICBmb3IgKGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG4gICAgICAgICAgaWYgKHRpbWVyc1tpbmRleF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbaW5kZXhdLnF1ZXVlID09PSB0eXBlKSB7XG4gICAgICAgICAgICB0aW1lcnNbaW5kZXhdLmFuaW0uc3RvcCh0cnVlKTtcbiAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChxdWV1ZVtpbmRleF0gJiYgcXVldWVbaW5kZXhdLmZpbmlzaCkge1xuICAgICAgICAgICAgcXVldWVbaW5kZXhdLmZpbmlzaC5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG4gICAgICAgIGRlbGV0ZSBkYXRhLmZpbmlzaDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgalF1ZXJ5LmVhY2goW1widG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIl0sIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICB2YXIgY3NzRm4gPSBqUXVlcnkuZm5bbmFtZV07XG4gICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24oc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCJcbiAgICAgICAgPyBjc3NGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIDogdGhpcy5hbmltYXRlKGdlbkZ4KG5hbWUsIHRydWUpLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xuICBqUXVlcnkuZWFjaChcbiAgICB7XG4gICAgICBzbGlkZURvd246IGdlbkZ4KFwic2hvd1wiKSxcbiAgICAgIHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcbiAgICAgIHNsaWRlVG9nZ2xlOiBnZW5GeChcInRvZ2dsZVwiKSxcbiAgICAgIGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuICAgICAgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuICAgICAgZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uKG5hbWUsIHByb3BzKSB7XG4gICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbihzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICB9O1xuICAgIH1cbiAgKTtcblxuICBqUXVlcnkudGltZXJzID0gW107XG4gIGpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRpbWVyLFxuICAgICAgaSA9IDAsXG4gICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG4gICAgZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cbiAgICBmb3IgKDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGltZXIgPSB0aW1lcnNbaV07XG5cbiAgICAgIC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcbiAgICAgIGlmICghdGltZXIoKSAmJiB0aW1lcnNbaV0gPT09IHRpbWVyKSB7XG4gICAgICAgIHRpbWVycy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRpbWVycy5sZW5ndGgpIHtcbiAgICAgIGpRdWVyeS5meC5zdG9wKCk7XG4gICAgfVxuICAgIGZ4Tm93ID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIGpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKHRpbWVyKSB7XG4gICAgalF1ZXJ5LnRpbWVycy5wdXNoKHRpbWVyKTtcbiAgICBqUXVlcnkuZnguc3RhcnQoKTtcbiAgfTtcblxuICBqUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbiAgalF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGluUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpblByb2dyZXNzID0gdHJ1ZTtcbiAgICBzY2hlZHVsZSgpO1xuICB9O1xuXG4gIGpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgaW5Qcm9ncmVzcyA9IG51bGw7XG4gIH07XG5cbiAgalF1ZXJ5LmZ4LnNwZWVkcyA9IHtcbiAgICBzbG93OiA2MDAsXG4gICAgZmFzdDogMjAwLFxuXG4gICAgLy8gRGVmYXVsdCBzcGVlZFxuICAgIF9kZWZhdWx0OiA0MDBcbiAgfTtcblxuICAvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4gIC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG4gIGpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKHRpbWUsIHR5cGUpIHtcbiAgICB0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1t0aW1lXSB8fCB0aW1lIDogdGltZTtcbiAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZSh0eXBlLCBmdW5jdGlvbihuZXh0LCBob29rcykge1xuICAgICAgdmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChuZXh0LCB0aW1lKTtcbiAgICAgIGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxcbiAgICAgIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksXG4gICAgICBvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKSk7XG5cbiAgICBpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG4gICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG4gICAgLy8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG4gICAgc3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cbiAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbiAgICAvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuICAgIHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cbiAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbiAgICAvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnZhbHVlID0gXCJ0XCI7XG4gICAgaW5wdXQudHlwZSA9IFwicmFkaW9cIjtcbiAgICBzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG4gIH0pKCk7XG5cbiAgdmFyIGJvb2xIb29rLFxuICAgIGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIGF0dHI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xuICAgIH0sXG5cbiAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cih0aGlzLCBuYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgYXR0cjogZnVuY3Rpb24oZWxlbSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciByZXQsXG4gICAgICAgIGhvb2tzLFxuICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cbiAgICAgIC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcbiAgICAgIGlmIChuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG4gICAgICBpZiAodHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBqUXVlcnkucHJvcChlbGVtLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICAgIC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcbiAgICAgIGlmIChuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pKSB7XG4gICAgICAgIGhvb2tzID1cbiAgICAgICAgICBqUXVlcnkuYXR0ckhvb2tzW25hbWUudG9Mb3dlckNhc2UoKV0gfHxcbiAgICAgICAgICAoalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KG5hbWUpID8gYm9vbEhvb2sgOiB1bmRlZmluZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cihlbGVtLCBuYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgaG9va3MgJiZcbiAgICAgICAgICBcInNldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgKHJldCA9IGhvb2tzLnNldChlbGVtLCB2YWx1ZSwgbmFtZSkpICE9PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlICsgXCJcIik7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBuYW1lKSkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgcmV0ID0galF1ZXJ5LmZpbmQuYXR0cihlbGVtLCBuYW1lKTtcblxuICAgICAgLy8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcbiAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcbiAgICB9LFxuXG4gICAgYXR0ckhvb2tzOiB7XG4gICAgICB0eXBlOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24oZWxlbSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmXG4gICAgICAgICAgICB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG4gICAgICAgICAgICBub2RlTmFtZShlbGVtLCBcImlucHV0XCIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZWxlbS52YWx1ZTtcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwidHlwZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgIGVsZW0udmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKGVsZW0sIHZhbHVlKSB7XG4gICAgICB2YXIgbmFtZSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4gICAgICAgIGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKHJub3RodG1sd2hpdGUpO1xuXG4gICAgICBpZiAoYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKChuYW1lID0gYXR0ck5hbWVzW2krK10pKSB7XG4gICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbiAgYm9vbEhvb2sgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihlbGVtLCB2YWx1ZSwgbmFtZSkge1xuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG4gICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKGVsZW0sIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUobmFtZSwgbmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH07XG5cbiAgalF1ZXJ5LmVhY2goalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICB2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVtuYW1lXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG4gICAgYXR0ckhhbmRsZVtuYW1lXSA9IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIGlzWE1MKSB7XG4gICAgICB2YXIgcmV0LFxuICAgICAgICBoYW5kbGUsXG4gICAgICAgIGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICghaXNYTUwpIHtcbiAgICAgICAgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuICAgICAgICBoYW5kbGUgPSBhdHRySGFuZGxlW2xvd2VyY2FzZU5hbWVdO1xuICAgICAgICBhdHRySGFuZGxlW2xvd2VyY2FzZU5hbWVdID0gcmV0O1xuICAgICAgICByZXQgPSBnZXR0ZXIoZWxlbSwgbmFtZSwgaXNYTUwpICE9IG51bGwgPyBsb3dlcmNhc2VOYW1lIDogbnVsbDtcbiAgICAgICAgYXR0ckhhbmRsZVtsb3dlcmNhc2VOYW1lXSA9IGhhbmRsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfSk7XG5cbiAgdmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuICAgIHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgcHJvcDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XG4gICAgfSxcblxuICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW2pRdWVyeS5wcm9wRml4W25hbWVdIHx8IG5hbWVdO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBqUXVlcnkuZXh0ZW5kKHtcbiAgICBwcm9wOiBmdW5jdGlvbihlbGVtLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHJldCxcbiAgICAgICAgaG9va3MsXG4gICAgICAgIG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuICAgICAgLy8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuICAgICAgaWYgKG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoZWxlbSkpIHtcbiAgICAgICAgLy8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuICAgICAgICBuYW1lID0galF1ZXJ5LnByb3BGaXhbbmFtZV0gfHwgbmFtZTtcbiAgICAgICAgaG9va3MgPSBqUXVlcnkucHJvcEhvb2tzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaG9va3MgJiZcbiAgICAgICAgICBcInNldFwiIGluIGhvb2tzICYmXG4gICAgICAgICAgKHJldCA9IGhvb2tzLnNldChlbGVtLCB2YWx1ZSwgbmFtZSkpICE9PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoZWxlbVtuYW1lXSA9IHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBuYW1lKSkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVsZW1bbmFtZV07XG4gICAgfSxcblxuICAgIHByb3BIb29rczoge1xuICAgICAgdGFiSW5kZXg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuICAgICAgICAgIC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuICAgICAgICAgIC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuICAgICAgICAgIC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuICAgICAgICAgIC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG4gICAgICAgICAgdmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0cihlbGVtLCBcInRhYmluZGV4XCIpO1xuXG4gICAgICAgICAgaWYgKHRhYmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGFiaW5kZXgsIDEwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByZm9jdXNhYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkgfHxcbiAgICAgICAgICAgIChyY2xpY2thYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkgJiYgZWxlbS5ocmVmKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHByb3BGaXg6IHtcbiAgICAgIGZvcjogXCJodG1sRm9yXCIsXG4gICAgICBjbGFzczogXCJjbGFzc05hbWVcIlxuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4gIC8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuICAvLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4gIC8vIG9uIHRoZSBvcHRpb25cbiAgLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbiAgLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuICAvLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbiAgLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG4gIGlmICghc3VwcG9ydC5vcHRTZWxlY3RlZCkge1xuICAgIGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgLyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cbiAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG4gICAgICAgICAgaWYgKHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBqUXVlcnkuZWFjaChcbiAgICBbXG4gICAgICBcInRhYkluZGV4XCIsXG4gICAgICBcInJlYWRPbmx5XCIsXG4gICAgICBcIm1heExlbmd0aFwiLFxuICAgICAgXCJjZWxsU3BhY2luZ1wiLFxuICAgICAgXCJjZWxsUGFkZGluZ1wiLFxuICAgICAgXCJyb3dTcGFuXCIsXG4gICAgICBcImNvbFNwYW5cIixcbiAgICAgIFwidXNlTWFwXCIsXG4gICAgICBcImZyYW1lQm9yZGVyXCIsXG4gICAgICBcImNvbnRlbnRFZGl0YWJsZVwiXG4gICAgXSxcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIGpRdWVyeS5wcm9wRml4W3RoaXMudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xuICAgIH1cbiAgKTtcblxuICAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2VcbiAgZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSh2YWx1ZSkge1xuICAgIHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaChybm90aHRtbHdoaXRlKSB8fCBbXTtcbiAgICByZXR1cm4gdG9rZW5zLmpvaW4oXCIgXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3MoZWxlbSkge1xuICAgIHJldHVybiAoZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSkgfHwgXCJcIjtcbiAgfVxuXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNsYXNzZXMsXG4gICAgICAgIGVsZW0sXG4gICAgICAgIGN1cixcbiAgICAgICAgY3VyVmFsdWUsXG4gICAgICAgIGNsYXp6LFxuICAgICAgICBqLFxuICAgICAgICBmaW5hbFZhbHVlLFxuICAgICAgICBpID0gMDtcblxuICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgICBqUXVlcnkodGhpcykuYWRkQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBqLCBnZXRDbGFzcyh0aGlzKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSkge1xuICAgICAgICBjbGFzc2VzID0gdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XG5cbiAgICAgICAgd2hpbGUgKChlbGVtID0gdGhpc1tpKytdKSkge1xuICAgICAgICAgIGN1clZhbHVlID0gZ2V0Q2xhc3MoZWxlbSk7XG4gICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoY3VyVmFsdWUpICsgXCIgXCI7XG5cbiAgICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW2orK10pKSB7XG4gICAgICAgICAgICAgIGlmIChjdXIuaW5kZXhPZihcIiBcIiArIGNsYXp6ICsgXCIgXCIpIDwgMCkge1xuICAgICAgICAgICAgICAgIGN1ciArPSBjbGF6eiArIFwiIFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZShjdXIpO1xuICAgICAgICAgICAgaWYgKGN1clZhbHVlICE9PSBmaW5hbFZhbHVlKSB7XG4gICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZmluYWxWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBjbGFzc2VzLFxuICAgICAgICBlbGVtLFxuICAgICAgICBjdXIsXG4gICAgICAgIGN1clZhbHVlLFxuICAgICAgICBjbGF6eixcbiAgICAgICAgaixcbiAgICAgICAgZmluYWxWYWx1ZSxcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihqKSB7XG4gICAgICAgICAgalF1ZXJ5KHRoaXMpLnJlbW92ZUNsYXNzKHZhbHVlLmNhbGwodGhpcywgaiwgZ2V0Q2xhc3ModGhpcykpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIiwgXCJcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUpIHtcbiAgICAgICAgY2xhc3NlcyA9IHZhbHVlLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdO1xuXG4gICAgICAgIHdoaWxlICgoZWxlbSA9IHRoaXNbaSsrXSkpIHtcbiAgICAgICAgICBjdXJWYWx1ZSA9IGdldENsYXNzKGVsZW0pO1xuXG4gICAgICAgICAgLy8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcbiAgICAgICAgICBjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZShjdXJWYWx1ZSkgKyBcIiBcIjtcblxuICAgICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbaisrXSkpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuICAgICAgICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YoXCIgXCIgKyBjbGF6eiArIFwiIFwiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UoXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKGN1cik7XG4gICAgICAgICAgICBpZiAoY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBmaW5hbFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbih2YWx1ZSwgc3RhdGVWYWwpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgICBpZiAodHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3ModmFsdWUpIDogdGhpcy5yZW1vdmVDbGFzcyh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgalF1ZXJ5KHRoaXMpLnRvZ2dsZUNsYXNzKFxuICAgICAgICAgICAgdmFsdWUuY2FsbCh0aGlzLCBpLCBnZXRDbGFzcyh0aGlzKSwgc3RhdGVWYWwpLFxuICAgICAgICAgICAgc3RhdGVWYWxcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgc2VsZiA9IGpRdWVyeSh0aGlzKTtcbiAgICAgICAgICBjbGFzc05hbWVzID0gdmFsdWUubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW107XG5cbiAgICAgICAgICB3aGlsZSAoKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaSsrXSkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuICAgICAgICAgICAgaWYgKHNlbGYuaGFzQ2xhc3MoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3ModGhpcyk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgLy8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuICAgICAgICAgICAgZGF0YVByaXYuc2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG4gICAgICAgICAgLy8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cbiAgICAgICAgICAvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuICAgICAgICAgIC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAodGhpcy5zZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgICBcImNsYXNzXCIsXG4gICAgICAgICAgICAgIGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICA/IFwiXCJcbiAgICAgICAgICAgICAgICA6IGRhdGFQcml2LmdldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIikgfHwgXCJcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciBjbGFzc05hbWUsXG4gICAgICAgIGVsZW0sXG4gICAgICAgIGkgPSAwO1xuXG4gICAgICBjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG4gICAgICB3aGlsZSAoKGVsZW0gPSB0aGlzW2krK10pKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBlbGVtLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgKFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZShnZXRDbGFzcyhlbGVtKSkgKyBcIiBcIikuaW5kZXhPZihjbGFzc05hbWUpID4gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgdmFsOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGhvb2tzLFxuICAgICAgICByZXQsXG4gICAgICAgIGlzRnVuY3Rpb24sXG4gICAgICAgIGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgICBob29rcyA9XG4gICAgICAgICAgICBqUXVlcnkudmFsSG9va3NbZWxlbS50eXBlXSB8fFxuICAgICAgICAgICAgalF1ZXJ5LnZhbEhvb2tzW2VsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBob29rcyAmJlxuICAgICAgICAgICAgXCJnZXRcIiBpbiBob29rcyAmJlxuICAgICAgICAgICAgKHJldCA9IGhvb2tzLmdldChlbGVtLCBcInZhbHVlXCIpKSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldCA9IGVsZW0udmFsdWU7XG5cbiAgICAgICAgICAvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG4gICAgICAgICAgaWYgKHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcbiAgICAgICAgICByZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgdmFsID0gdmFsdWUuY2FsbCh0aGlzLCBpLCBqUXVlcnkodGhpcykudmFsKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICB2YWwgPSBcIlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB2YWwgKz0gXCJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSBqUXVlcnkubWFwKHZhbCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhvb2tzID1cbiAgICAgICAgICBqUXVlcnkudmFsSG9va3NbdGhpcy50eXBlXSB8fFxuICAgICAgICAgIGpRdWVyeS52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaG9va3MgfHxcbiAgICAgICAgICAhKFwic2V0XCIgaW4gaG9va3MpIHx8XG4gICAgICAgICAgaG9va3Muc2V0KHRoaXMsIHZhbCwgXCJ2YWx1ZVwiKSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgalF1ZXJ5LmV4dGVuZCh7XG4gICAgdmFsSG9va3M6IHtcbiAgICAgIG9wdGlvbjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICB2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0cihlbGVtLCBcInZhbHVlXCIpO1xuICAgICAgICAgIHJldHVybiB2YWwgIT0gbnVsbFxuICAgICAgICAgICAgPyB2YWxcbiAgICAgICAgICAgIDogLy8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcbiAgICAgICAgICAgICAgLy8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuICAgICAgICAgICAgICAvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuICAgICAgICAgICAgICBzdHJpcEFuZENvbGxhcHNlKGpRdWVyeS50ZXh0KGVsZW0pKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbGVjdDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgICBvcHRpb24sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgIGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgb25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcbiAgICAgICAgICAgIHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcbiAgICAgICAgICAgIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaSA9IG1heDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSA9IG9uZSA/IGluZGV4IDogMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG4gICAgICAgICAgZm9yICg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAgICAgICAgIC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAob3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4KSAmJlxuICAgICAgICAgICAgICAvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG4gICAgICAgICAgICAgICFvcHRpb24uZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgKCFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuICAgICAgICAgICAgICAgICFub2RlTmFtZShvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG4gICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5KG9wdGlvbikudmFsKCk7XG5cbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcbiAgICAgICAgICAgICAgaWYgKG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG4gICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24oZWxlbSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgb3B0aW9uU2V0LFxuICAgICAgICAgICAgb3B0aW9uLFxuICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcbiAgICAgICAgICAgIHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkodmFsdWUpLFxuICAgICAgICAgICAgaSA9IG9wdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcblxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAob3B0aW9uLnNlbGVjdGVkID1cbiAgICAgICAgICAgICAgICBqUXVlcnkuaW5BcnJheShqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldChvcHRpb24pLCB2YWx1ZXMpID4gLTEpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgb3B0aW9uU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG4gICAgICAgICAgaWYgKCFvcHRpb25TZXQpIHtcbiAgICAgICAgICAgIGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxuICBqUXVlcnkuZWFjaChbXCJyYWRpb1wiLCBcImNoZWNrYm94XCJdLCBmdW5jdGlvbigpIHtcbiAgICBqUXVlcnkudmFsSG9va3NbdGhpc10gPSB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uKGVsZW0sIHZhbHVlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiAoZWxlbS5jaGVja2VkID1cbiAgICAgICAgICAgIGpRdWVyeS5pbkFycmF5KGpRdWVyeShlbGVtKS52YWwoKSwgdmFsdWUpID4gLTEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIXN1cHBvcnQuY2hlY2tPbikge1xuICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuICB2YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbiAgalF1ZXJ5LmV4dGVuZChqUXVlcnkuZXZlbnQsIHtcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbihldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgY3VyLFxuICAgICAgICB0bXAsXG4gICAgICAgIGJ1YmJsZVR5cGUsXG4gICAgICAgIG9udHlwZSxcbiAgICAgICAgaGFuZGxlLFxuICAgICAgICBzcGVjaWFsLFxuICAgICAgICBldmVudFBhdGggPSBbZWxlbSB8fCBkb2N1bWVudF0sXG4gICAgICAgIHR5cGUgPSBoYXNPd24uY2FsbChldmVudCwgXCJ0eXBlXCIpID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuICAgICAgICBuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoZXZlbnQsIFwibmFtZXNwYWNlXCIpXG4gICAgICAgICAgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpXG4gICAgICAgICAgOiBbXTtcblxuICAgICAgY3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cbiAgICAgIC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG4gICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG4gICAgICBpZiAocmZvY3VzTW9ycGgudGVzdCh0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZS5pbmRleE9mKFwiLlwiKSA+IC0xKSB7XG4gICAgICAgIC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcbiAgICAgICAgbmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuICAgICAgICBuYW1lc3BhY2VzLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7XG5cbiAgICAgIC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuICAgICAgZXZlbnQgPSBldmVudFtqUXVlcnkuZXhwYW5kb11cbiAgICAgICAgPyBldmVudFxuICAgICAgICA6IG5ldyBqUXVlcnkuRXZlbnQodHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50KTtcblxuICAgICAgLy8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuICAgICAgZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG4gICAgICBldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpO1xuICAgICAgZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZVxuICAgICAgICA/IG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIilcbiAgICAgICAgOiBudWxsO1xuXG4gICAgICAvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcbiAgICAgIGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgIGV2ZW50LnRhcmdldCA9IGVsZW07XG4gICAgICB9XG5cbiAgICAgIC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3RcbiAgICAgIGRhdGEgPSBkYXRhID09IG51bGwgPyBbZXZlbnRdIDogalF1ZXJ5Lm1ha2VBcnJheShkYXRhLCBbZXZlbnRdKTtcblxuICAgICAgLy8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xuICAgICAgaWYgKFxuICAgICAgICAhb25seUhhbmRsZXJzICYmXG4gICAgICAgIHNwZWNpYWwudHJpZ2dlciAmJlxuICAgICAgICBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoZWxlbSwgZGF0YSkgPT09IGZhbHNlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcbiAgICAgIC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG4gICAgICBpZiAoIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KGVsZW0pKSB7XG4gICAgICAgIGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuICAgICAgICBpZiAoIXJmb2N1c01vcnBoLnRlc3QoYnViYmxlVHlwZSArIHR5cGUpKSB7XG4gICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBldmVudFBhdGgucHVzaChjdXIpO1xuICAgICAgICAgIHRtcCA9IGN1cjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuICAgICAgICBpZiAodG1wID09PSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSkge1xuICAgICAgICAgIGV2ZW50UGF0aC5wdXNoKHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuICAgICAgaSA9IDA7XG4gICAgICB3aGlsZSAoKGN1ciA9IGV2ZW50UGF0aFtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBldmVudC50eXBlID0gaSA+IDEgPyBidWJibGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG4gICAgICAgIC8vIGpRdWVyeSBoYW5kbGVyXG4gICAgICAgIGhhbmRsZSA9XG4gICAgICAgICAgKGRhdGFQcml2LmdldChjdXIsIFwiZXZlbnRzXCIpIHx8IHt9KVtldmVudC50eXBlXSAmJlxuICAgICAgICAgIGRhdGFQcml2LmdldChjdXIsIFwiaGFuZGxlXCIpO1xuICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgaGFuZGxlLmFwcGx5KGN1ciwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOYXRpdmUgaGFuZGxlclxuICAgICAgICBoYW5kbGUgPSBvbnR5cGUgJiYgY3VyW29udHlwZV07XG4gICAgICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoY3VyKSkge1xuICAgICAgICAgIGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseShjdXIsIGRhdGEpO1xuICAgICAgICAgIGlmIChldmVudC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnQudHlwZSA9IHR5cGU7XG5cbiAgICAgIC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcbiAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKCFzcGVjaWFsLl9kZWZhdWx0IHx8XG4gICAgICAgICAgICBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KGV2ZW50UGF0aC5wb3AoKSwgZGF0YSkgPT09IGZhbHNlKSAmJlxuICAgICAgICAgIGFjY2VwdERhdGEoZWxlbSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cbiAgICAgICAgICAvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgb250eXBlICYmXG4gICAgICAgICAgICBqUXVlcnkuaXNGdW5jdGlvbihlbGVtW3R5cGVdKSAmJlxuICAgICAgICAgICAgIWpRdWVyeS5pc1dpbmRvdyhlbGVtKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuICAgICAgICAgICAgdG1wID0gZWxlbVtvbnR5cGVdO1xuXG4gICAgICAgICAgICBpZiAodG1wKSB7XG4gICAgICAgICAgICAgIGVsZW1bb250eXBlXSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcbiAgICAgICAgICAgIGVsZW1bdHlwZV0oKTtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmICh0bXApIHtcbiAgICAgICAgICAgICAgZWxlbVtvbnR5cGVdID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xuICAgIH0sXG5cbiAgICAvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcbiAgICAvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuICAgIHNpbXVsYXRlOiBmdW5jdGlvbih0eXBlLCBlbGVtLCBldmVudCkge1xuICAgICAgdmFyIGUgPSBqUXVlcnkuZXh0ZW5kKG5ldyBqUXVlcnkuRXZlbnQoKSwgZXZlbnQsIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgaXNTaW11bGF0ZWQ6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihlLCBudWxsLCBlbGVtKTtcbiAgICB9XG4gIH0pO1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xuICAgICAgaWYgKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIGVsZW0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgalF1ZXJ5LmVhY2goXG4gICAgKFxuICAgICAgXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG4gICAgICBcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcbiAgICAgIFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiXG4gICAgKS5zcGxpdChcIiBcIiksXG4gICAgZnVuY3Rpb24oaSwgbmFtZSkge1xuICAgICAgLy8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcbiAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uKGRhdGEsIGZuKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMFxuICAgICAgICAgID8gdGhpcy5vbihuYW1lLCBudWxsLCBkYXRhLCBmbilcbiAgICAgICAgICA6IHRoaXMudHJpZ2dlcihuYW1lKTtcbiAgICAgIH07XG4gICAgfVxuICApO1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIGhvdmVyOiBmdW5jdGlvbihmbk92ZXIsIGZuT3V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGZuT3ZlcikubW91c2VsZWF2ZShmbk91dCB8fCBmbk92ZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cbiAgLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4gIC8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbiAgLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbiAgLy9cbiAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4gIC8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuICAvLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbiAgLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbiAgaWYgKCFzdXBwb3J0LmZvY3VzaW4pIHtcbiAgICBqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKG9yaWcsIGZpeCkge1xuICAgICAgLy8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcbiAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KGV2ZW50KSk7XG4gICAgICB9O1xuXG4gICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtmaXhdID0ge1xuICAgICAgICBzZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgYXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoZG9jLCBmaXgpO1xuXG4gICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xuICAgICAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIob3JpZywgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFQcml2LmFjY2Vzcyhkb2MsIGZpeCwgKGF0dGFjaGVzIHx8IDApICsgMSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG4gICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2Vzcyhkb2MsIGZpeCkgLSAxO1xuXG4gICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIob3JpZywgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZG9jLCBmaXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhUHJpdi5hY2Nlc3MoZG9jLCBmaXgsIGF0dGFjaGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgdmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG4gIHZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcblxuICB2YXIgcnF1ZXJ5ID0gL1xcPy87XG5cbiAgLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xuICBqUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHhtbDtcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG4gICAgLy8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG4gICAgdHJ5IHtcbiAgICAgIHhtbCA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGRhdGEsIFwidGV4dC94bWxcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgeG1sID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICgheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpLmxlbmd0aCkge1xuICAgICAgalF1ZXJ5LmVycm9yKFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB4bWw7XG4gIH07XG5cbiAgdmFyIHJicmFja2V0ID0gL1xcW1xcXSQvLFxuICAgIHJDUkxGID0gL1xccj9cXG4vZyxcbiAgICByc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG4gICAgcnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkUGFyYW1zKHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkKSB7XG4gICAgdmFyIG5hbWU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cbiAgICAgIGpRdWVyeS5lYWNoKG9iaiwgZnVuY3Rpb24oaSwgdikge1xuICAgICAgICBpZiAodHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdChwcmVmaXgpKSB7XG4gICAgICAgICAgLy8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuICAgICAgICAgIGFkZChwcmVmaXgsIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuICAgICAgICAgIGJ1aWxkUGFyYW1zKFxuICAgICAgICAgICAgcHJlZml4ICsgXCJbXCIgKyAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIpICsgXCJdXCIsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgdHJhZGl0aW9uYWwsXG4gICAgICAgICAgICBhZGRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCF0cmFkaXRpb25hbCAmJiBqUXVlcnkudHlwZShvYmopID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG4gICAgICBmb3IgKG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbbmFtZV0sIHRyYWRpdGlvbmFsLCBhZGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG4gICAgICBhZGQocHJlZml4LCBvYmopO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4gIC8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xuICBqUXVlcnkucGFyYW0gPSBmdW5jdGlvbihhLCB0cmFkaXRpb25hbCkge1xuICAgIHZhciBwcmVmaXgsXG4gICAgICBzID0gW10sXG4gICAgICBhZGQgPSBmdW5jdGlvbihrZXksIHZhbHVlT3JGdW5jdGlvbikge1xuICAgICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG4gICAgICAgIHZhciB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlT3JGdW5jdGlvbilcbiAgICAgICAgICA/IHZhbHVlT3JGdW5jdGlvbigpXG4gICAgICAgICAgOiB2YWx1ZU9yRnVuY3Rpb247XG5cbiAgICAgICAgc1tzLmxlbmd0aF0gPVxuICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUpO1xuICAgICAgfTtcblxuICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgfHwgKGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdChhKSkpIHtcbiAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuICAgICAgalF1ZXJ5LmVhY2goYSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGFkZCh0aGlzLm5hbWUsIHRoaXMudmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG4gICAgICAvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cbiAgICAgIGZvciAocHJlZml4IGluIGEpIHtcbiAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4LCBhW3ByZWZpeF0sIHRyYWRpdGlvbmFsLCBhZGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cbiAgICByZXR1cm4gcy5qb2luKFwiJlwiKTtcbiAgfTtcblxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGpRdWVyeS5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpO1xuICAgIH0sXG4gICAgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG4gICAgICAgIHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKHRoaXMsIFwiZWxlbWVudHNcIik7XG4gICAgICAgIHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoZWxlbWVudHMpIDogdGhpcztcbiAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgICAgICAvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3NcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5uYW1lICYmXG4gICAgICAgICAgICAhalF1ZXJ5KHRoaXMpLmlzKFwiOmRpc2FibGVkXCIpICYmXG4gICAgICAgICAgICByc3VibWl0dGFibGUudGVzdCh0aGlzLm5vZGVOYW1lKSAmJlxuICAgICAgICAgICAgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KHR5cGUpICYmXG4gICAgICAgICAgICAodGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KHR5cGUpKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaSwgZWxlbSkge1xuICAgICAgICAgIHZhciB2YWwgPSBqUXVlcnkodGhpcykudmFsKCk7XG5cbiAgICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkubWFwKHZhbCwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKHJDUkxGLCBcIlxcclxcblwiKSB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UockNSTEYsIFwiXFxyXFxuXCIpIH07XG4gICAgICAgIH0pXG4gICAgICAgIC5nZXQoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciByMjAgPSAvJTIwL2csXG4gICAgcmhhc2ggPSAvIy4qJC8sXG4gICAgcmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcbiAgICByaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvZ20sXG4gICAgLy8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG4gICAgcmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcbiAgICBybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcbiAgICBycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG4gICAgLyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuICAgIHByZWZpbHRlcnMgPSB7fSxcbiAgICAvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG4gICAgdHJhbnNwb3J0cyA9IHt9LFxuICAgIC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuICAgIGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdChcIipcIiksXG4gICAgLy8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG4gICAgb3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gIG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuICAvLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG4gIGZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyhzdHJ1Y3R1cmUpIHtcbiAgICAvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcbiAgICAgICAgZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhVHlwZSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKHJub3RodG1sd2hpdGUpIHx8IFtdO1xuXG4gICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgLy8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuICAgICAgICB3aGlsZSAoKGRhdGFUeXBlID0gZGF0YVR5cGVzW2krK10pKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICBpZiAoZGF0YVR5cGVbMF0gPT09IFwiK1wiKSB7XG4gICAgICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKDEpIHx8IFwiKlwiO1xuICAgICAgICAgICAgKHN0cnVjdHVyZVtkYXRhVHlwZV0gPSBzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdKS51bnNoaWZ0KGZ1bmMpO1xuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgYXBwZW5kXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIChzdHJ1Y3R1cmVbZGF0YVR5cGVdID0gc3RydWN0dXJlW2RhdGFUeXBlXSB8fCBbXSkucHVzaChmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG4gIGZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKFxuICAgIHN0cnVjdHVyZSxcbiAgICBvcHRpb25zLFxuICAgIG9yaWdpbmFsT3B0aW9ucyxcbiAgICBqcVhIUlxuICApIHtcbiAgICB2YXIgaW5zcGVjdGVkID0ge30sXG4gICAgICBzZWVraW5nVHJhbnNwb3J0ID0gc3RydWN0dXJlID09PSB0cmFuc3BvcnRzO1xuXG4gICAgZnVuY3Rpb24gaW5zcGVjdChkYXRhVHlwZSkge1xuICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgaW5zcGVjdGVkW2RhdGFUeXBlXSA9IHRydWU7XG4gICAgICBqUXVlcnkuZWFjaChzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdLCBmdW5jdGlvbihfLCBwcmVmaWx0ZXJPckZhY3RvcnkpIHtcbiAgICAgICAgdmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBvcmlnaW5hbE9wdGlvbnMsXG4gICAgICAgICAganFYSFJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgIXNlZWtpbmdUcmFuc3BvcnQgJiZcbiAgICAgICAgICAhaW5zcGVjdGVkW2RhdGFUeXBlT3JUcmFuc3BvcnRdXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoZGF0YVR5cGVPclRyYW5zcG9ydCk7XG4gICAgICAgICAgaW5zcGVjdChkYXRhVHlwZU9yVHJhbnNwb3J0KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc2Vla2luZ1RyYW5zcG9ydCkge1xuICAgICAgICAgIHJldHVybiAhKHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cblxuICAgIHJldHVybiBpbnNwZWN0KG9wdGlvbnMuZGF0YVR5cGVzWzBdKSB8fCAoIWluc3BlY3RlZFtcIipcIl0gJiYgaW5zcGVjdChcIipcIikpO1xuICB9XG5cbiAgLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4gIC8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4gIC8vIEZpeGVzICM5ODg3XG4gIGZ1bmN0aW9uIGFqYXhFeHRlbmQodGFyZ2V0LCBzcmMpIHtcbiAgICB2YXIga2V5LFxuICAgICAgZGVlcCxcbiAgICAgIGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuICAgIGZvciAoa2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyY1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgKGZsYXRPcHRpb25zW2tleV0gPyB0YXJnZXQgOiBkZWVwIHx8IChkZWVwID0ge30pKVtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWVwKSB7XG4gICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIHRhcmdldCwgZGVlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuICBmdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKHMsIGpxWEhSLCByZXNwb25zZXMpIHtcbiAgICB2YXIgY3QsXG4gICAgICB0eXBlLFxuICAgICAgZmluYWxEYXRhVHlwZSxcbiAgICAgIGZpcnN0RGF0YVR5cGUsXG4gICAgICBjb250ZW50cyA9IHMuY29udGVudHMsXG4gICAgICBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuICAgIC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG4gICAgd2hpbGUgKGRhdGFUeXBlc1swXSA9PT0gXCIqXCIpIHtcbiAgICAgIGRhdGFUeXBlcy5zaGlmdCgpO1xuICAgICAgaWYgKGN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuICAgIGlmIChjdCkge1xuICAgICAgZm9yICh0eXBlIGluIGNvbnRlbnRzKSB7XG4gICAgICAgIGlmIChjb250ZW50c1t0eXBlXSAmJiBjb250ZW50c1t0eXBlXS50ZXN0KGN0KSkge1xuICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KHR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG4gICAgaWYgKGRhdGFUeXBlc1swXSBpbiByZXNwb25zZXMpIHtcbiAgICAgIGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcbiAgICAgIGZvciAodHlwZSBpbiByZXNwb25zZXMpIHtcbiAgICAgICAgaWYgKCFkYXRhVHlwZXNbMF0gfHwgcy5jb252ZXJ0ZXJzW3R5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1swXV0pIHtcbiAgICAgICAgICBmaW5hbERhdGFUeXBlID0gdHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZpcnN0RGF0YVR5cGUpIHtcbiAgICAgICAgICBmaXJzdERhdGFUeXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcbiAgICAgIGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuICAgIC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG4gICAgLy8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICAgIGlmIChmaW5hbERhdGFUeXBlKSB7XG4gICAgICBpZiAoZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWzBdKSB7XG4gICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KGZpbmFsRGF0YVR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlc1tmaW5hbERhdGFUeXBlXTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuICBmdW5jdGlvbiBhamF4Q29udmVydChzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2Vzcykge1xuICAgIHZhciBjb252MixcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjb252LFxuICAgICAgdG1wLFxuICAgICAgcHJldixcbiAgICAgIGNvbnZlcnRlcnMgPSB7fSxcbiAgICAgIC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cbiAgICAgIGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cbiAgICAvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcbiAgICBpZiAoZGF0YVR5cGVzWzFdKSB7XG4gICAgICBmb3IgKGNvbnYgaW4gcy5jb252ZXJ0ZXJzKSB7XG4gICAgICAgIGNvbnZlcnRlcnNbY29udi50b0xvd2VyQ2FzZSgpXSA9IHMuY29udmVydGVyc1tjb252XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cbiAgICAvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBpZiAocy5yZXNwb25zZUZpZWxkc1tjdXJyZW50XSkge1xuICAgICAgICBqcVhIUltzLnJlc3BvbnNlRmllbGRzW2N1cnJlbnRdXSA9IHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuICAgICAgaWYgKCFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIocmVzcG9uc2UsIHMuZGF0YVR5cGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgIGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgLy8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gXCIqXCIpIHtcbiAgICAgICAgICBjdXJyZW50ID0gcHJldjtcblxuICAgICAgICAgIC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgLy8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcbiAgICAgICAgICBjb252ID0gY29udmVydGVyc1twcmV2ICsgXCIgXCIgKyBjdXJyZW50XSB8fCBjb252ZXJ0ZXJzW1wiKiBcIiArIGN1cnJlbnRdO1xuXG4gICAgICAgICAgLy8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcbiAgICAgICAgICBpZiAoIWNvbnYpIHtcbiAgICAgICAgICAgIGZvciAoY29udjIgaW4gY29udmVydGVycykge1xuICAgICAgICAgICAgICAvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcbiAgICAgICAgICAgICAgdG1wID0gY29udjIuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICBpZiAodG1wWzFdID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG4gICAgICAgICAgICAgICAgY29udiA9XG4gICAgICAgICAgICAgICAgICBjb252ZXJ0ZXJzW3ByZXYgKyBcIiBcIiArIHRtcFswXV0gfHwgY29udmVydGVyc1tcIiogXCIgKyB0bXBbMF1dO1xuICAgICAgICAgICAgICAgIGlmIChjb252KSB7XG4gICAgICAgICAgICAgICAgICAvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG4gICAgICAgICAgICAgICAgICBpZiAoY29udiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1tjb252Ml07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb252ZXJ0ZXJzW2NvbnYyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdG1wWzBdO1xuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZXMudW5zaGlmdCh0bXBbMV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG4gICAgICAgICAgaWYgKGNvbnYgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cbiAgICAgICAgICAgIGlmIChjb252ICYmIHMudGhyb3dzKSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwicGFyc2VyZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBjb252XG4gICAgICAgICAgICAgICAgICAgID8gZVxuICAgICAgICAgICAgICAgICAgICA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG4gIH1cblxuICBqUXVlcnkuZXh0ZW5kKHtcbiAgICAvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcbiAgICBhY3RpdmU6IDAsXG5cbiAgICAvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG4gICAgbGFzdE1vZGlmaWVkOiB7fSxcbiAgICBldGFnOiB7fSxcblxuICAgIGFqYXhTZXR0aW5nczoge1xuICAgICAgdXJsOiBsb2NhdGlvbi5ocmVmLFxuICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgIGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QobG9jYXRpb24ucHJvdG9jb2wpLFxuICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgcHJvY2Vzc0RhdGE6IHRydWUsXG4gICAgICBhc3luYzogdHJ1ZSxcbiAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG4gICAgICAvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG4gICAgICBhY2NlcHRzOiB7XG4gICAgICAgIFwiKlwiOiBhbGxUeXBlcyxcbiAgICAgICAgdGV4dDogXCJ0ZXh0L3BsYWluXCIsXG4gICAgICAgIGh0bWw6IFwidGV4dC9odG1sXCIsXG4gICAgICAgIHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG4gICAgICAgIGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcbiAgICAgIH0sXG5cbiAgICAgIGNvbnRlbnRzOiB7XG4gICAgICAgIHhtbDogL1xcYnhtbFxcYi8sXG4gICAgICAgIGh0bWw6IC9cXGJodG1sLyxcbiAgICAgICAganNvbjogL1xcYmpzb25cXGIvXG4gICAgICB9LFxuXG4gICAgICByZXNwb25zZUZpZWxkczoge1xuICAgICAgICB4bWw6IFwicmVzcG9uc2VYTUxcIixcbiAgICAgICAgdGV4dDogXCJyZXNwb25zZVRleHRcIixcbiAgICAgICAganNvbjogXCJyZXNwb25zZUpTT05cIlxuICAgICAgfSxcblxuICAgICAgLy8gRGF0YSBjb252ZXJ0ZXJzXG4gICAgICAvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICBjb252ZXJ0ZXJzOiB7XG4gICAgICAgIC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuICAgICAgICBcIiogdGV4dFwiOiBTdHJpbmcsXG5cbiAgICAgICAgLy8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG4gICAgICAgIFwidGV4dCBodG1sXCI6IHRydWUsXG5cbiAgICAgICAgLy8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuICAgICAgICBcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG4gICAgICAgIC8vIFBhcnNlIHRleHQgYXMgeG1sXG4gICAgICAgIFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG4gICAgICB9LFxuXG4gICAgICAvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuICAgICAgLy8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuICAgICAgLy8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcbiAgICAgIC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuICAgICAgZmxhdE9wdGlvbnM6IHtcbiAgICAgICAgdXJsOiB0cnVlLFxuICAgICAgICBjb250ZXh0OiB0cnVlXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG4gICAgLy8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuICAgIC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG4gICAgYWpheFNldHVwOiBmdW5jdGlvbih0YXJnZXQsIHNldHRpbmdzKSB7XG4gICAgICByZXR1cm4gc2V0dGluZ3NcbiAgICAgICAgPyAvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgIGFqYXhFeHRlbmQoYWpheEV4dGVuZCh0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MpLCBzZXR0aW5ncylcbiAgICAgICAgOiAvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG4gICAgICAgICAgYWpheEV4dGVuZChqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQpO1xuICAgIH0sXG5cbiAgICBhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMocHJlZmlsdGVycyksXG4gICAgYWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHRyYW5zcG9ydHMpLFxuXG4gICAgLy8gTWFpbiBtZXRob2RcbiAgICBhamF4OiBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICAgIC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBvcHRpb25zID0gdXJsO1xuICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIHRyYW5zcG9ydCxcbiAgICAgICAgLy8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuICAgICAgICBjYWNoZVVSTCxcbiAgICAgICAgLy8gUmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgLy8gdGltZW91dCBoYW5kbGVcbiAgICAgICAgdGltZW91dFRpbWVyLFxuICAgICAgICAvLyBVcmwgY2xlYW51cCB2YXJcbiAgICAgICAgdXJsQW5jaG9yLFxuICAgICAgICAvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG4gICAgICAgIGNvbXBsZXRlZCxcbiAgICAgICAgLy8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG4gICAgICAgIGZpcmVHbG9iYWxzLFxuICAgICAgICAvLyBMb29wIHZhcmlhYmxlXG4gICAgICAgIGksXG4gICAgICAgIC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuICAgICAgICB1bmNhY2hlZCxcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuICAgICAgICBzID0galF1ZXJ5LmFqYXhTZXR1cCh7fSwgb3B0aW9ucyksXG4gICAgICAgIC8vIENhbGxiYWNrcyBjb250ZXh0XG4gICAgICAgIGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuICAgICAgICAvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG4gICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dCA9XG4gICAgICAgICAgcy5jb250ZXh0ICYmIChjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSlcbiAgICAgICAgICAgID8galF1ZXJ5KGNhbGxiYWNrQ29udGV4dClcbiAgICAgICAgICAgIDogalF1ZXJ5LmV2ZW50LFxuICAgICAgICAvLyBEZWZlcnJlZHNcbiAgICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcbiAgICAgICAgY29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcbiAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcbiAgICAgICAgc3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcbiAgICAgICAgLy8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcbiAgICAgICAgcmVxdWVzdEhlYWRlcnMgPSB7fSxcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuICAgICAgICAvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcbiAgICAgICAgc3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG4gICAgICAgIC8vIEZha2UgeGhyXG4gICAgICAgIGpxWEhSID0ge1xuICAgICAgICAgIHJlYWR5U3RhdGU6IDAsXG5cbiAgICAgICAgICAvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG4gICAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlSGVhZGVycykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSByaGVhZGVycy5leGVjKHJlc3BvbnNlSGVhZGVyc1N0cmluZykpKSB7XG4gICAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnNbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKV0gPSBtYXRjaFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWF0Y2ggPSByZXNwb25zZUhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIFJhdyBzdHJpbmdcbiAgICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIENhY2hlcyB0aGUgaGVhZGVyXG4gICAgICAgICAgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1tuYW1lLnRvTG93ZXJDYXNlKCldID1cbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyc05hbWVzW25hbWUudG9Mb3dlckNhc2UoKV0gfHwgbmFtZTtcbiAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuICAgICAgICAgIG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzLm1pbWVUeXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICAgIHN0YXR1c0NvZGU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICBqcVhIUi5hbHdheXMobWFwW2pxWEhSLnN0YXR1c10pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG4gICAgICAgICAgICAgICAgZm9yIChjb2RlIGluIG1hcCkge1xuICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZVtjb2RlXSA9IFtzdGF0dXNDb2RlW2NvZGVdLCBtYXBbY29kZV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuICAgICAgICAgIGFib3J0OiBmdW5jdGlvbihzdGF0dXNUZXh0KSB7XG4gICAgICAgICAgICB2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgdHJhbnNwb3J0LmFib3J0KGZpbmFsVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKDAsIGZpbmFsVGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgIC8vIEF0dGFjaCBkZWZlcnJlZHNcbiAgICAgIGRlZmVycmVkLnByb21pc2UoanFYSFIpO1xuXG4gICAgICAvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcbiAgICAgIC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG4gICAgICAvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcbiAgICAgIHMudXJsID0gKCh1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZikgKyBcIlwiKS5yZXBsYWNlKFxuICAgICAgICBycHJvdG9jb2wsXG4gICAgICAgIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiXG4gICAgICApO1xuXG4gICAgICAvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcbiAgICAgIHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cbiAgICAgIC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3RcbiAgICAgIHMuZGF0YVR5cGVzID0gKHMuZGF0YVR5cGUgfHwgXCIqXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2gocm5vdGh0bWx3aGl0ZSkgfHwgW1xuICAgICAgICBcIlwiXG4gICAgICBdO1xuXG4gICAgICAvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cbiAgICAgIGlmIChzLmNyb3NzRG9tYWluID09IG51bGwpIHtcbiAgICAgICAgdXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cbiAgICAgICAgLy8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxM1xuICAgICAgICAvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuICAgICAgICAvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcbiAgICAgICAgICAvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuICAgICAgICAgIHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG4gICAgICAgICAgcy5jcm9zc0RvbWFpbiA9XG4gICAgICAgICAgICBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cbiAgICAgICAgICAgIHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG4gICAgICAgICAgLy8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuICAgICAgICAgIHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuICAgICAgaWYgKHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcy5kYXRhID0galF1ZXJ5LnBhcmFtKHMuZGF0YSwgcy50cmFkaXRpb25hbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IHByZWZpbHRlcnNcbiAgICAgIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSKTtcblxuICAgICAgLy8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcbiAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuICAgICAgLy8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcbiAgICAgIGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG4gICAgICAvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG4gICAgICBpZiAoZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwKSB7XG4gICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcHBlcmNhc2UgdGhlIHR5cGVcbiAgICAgIHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuICAgICAgcy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdChzLnR5cGUpO1xuXG4gICAgICAvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2VcbiAgICAgIC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuICAgICAgLy8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuICAgICAgY2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKHJoYXNoLCBcIlwiKTtcblxuICAgICAgLy8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcbiAgICAgIGlmICghcy5oYXNDb250ZW50KSB7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuICAgICAgICB1bmNhY2hlZCA9IHMudXJsLnNsaWNlKGNhY2hlVVJMLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuICAgICAgICBpZiAocy5kYXRhKSB7XG4gICAgICAgICAgY2FjaGVVUkwgKz0gKHJxdWVyeS50ZXN0KGNhY2hlVVJMKSA/IFwiJlwiIDogXCI/XCIpICsgcy5kYXRhO1xuXG4gICAgICAgICAgLy8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuICAgICAgICAgIGRlbGV0ZSBzLmRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG4gICAgICAgIGlmIChzLmNhY2hlID09PSBmYWxzZSkge1xuICAgICAgICAgIGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZShyYW50aUNhY2hlLCBcIiQxXCIpO1xuICAgICAgICAgIHVuY2FjaGVkID1cbiAgICAgICAgICAgIChycXVlcnkudGVzdChjYWNoZVVSTCkgPyBcIiZcIiA6IFwiP1wiKSArIFwiXz1cIiArIG5vbmNlKysgKyB1bmNhY2hlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcbiAgICAgICAgcy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG4gICAgICAgIC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgcy5kYXRhICYmXG4gICAgICAgIHMucHJvY2Vzc0RhdGEgJiZcbiAgICAgICAgKHMuY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSA9PT0gMFxuICAgICAgKSB7XG4gICAgICAgIHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKHIyMCwgXCIrXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuICAgICAgaWYgKHMuaWZNb2RpZmllZCkge1xuICAgICAgICBpZiAoalF1ZXJ5Lmxhc3RNb2RpZmllZFtjYWNoZVVSTF0pIHtcbiAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuICAgICAgICAgICAgXCJJZi1Nb2RpZmllZC1TaW5jZVwiLFxuICAgICAgICAgICAgalF1ZXJ5Lmxhc3RNb2RpZmllZFtjYWNoZVVSTF1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqUXVlcnkuZXRhZ1tjYWNoZVVSTF0pIHtcbiAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1tjYWNoZVVSTF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuICAgICAgaWYgKFxuICAgICAgICAocy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSkgfHxcbiAgICAgICAgb3B0aW9ucy5jb250ZW50VHlwZVxuICAgICAgKSB7XG4gICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcbiAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG4gICAgICAgIFwiQWNjZXB0XCIsXG4gICAgICAgIHMuZGF0YVR5cGVzWzBdICYmIHMuYWNjZXB0c1tzLmRhdGFUeXBlc1swXV1cbiAgICAgICAgICA/IHMuYWNjZXB0c1tzLmRhdGFUeXBlc1swXV0gK1xuICAgICAgICAgICAgKHMuZGF0YVR5cGVzWzBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIilcbiAgICAgICAgICA6IHMuYWNjZXB0c1tcIipcIl1cbiAgICAgICk7XG5cbiAgICAgIC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuICAgICAgZm9yIChpIGluIHMuaGVhZGVycykge1xuICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKGksIHMuaGVhZGVyc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcbiAgICAgIGlmIChcbiAgICAgICAgcy5iZWZvcmVTZW5kICYmXG4gICAgICAgIChzLmJlZm9yZVNlbmQuY2FsbChjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkKVxuICAgICAgKSB7XG4gICAgICAgIC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG4gICAgICBzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuICAgICAgLy8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG4gICAgICBjb21wbGV0ZURlZmVycmVkLmFkZChzLmNvbXBsZXRlKTtcbiAgICAgIGpxWEhSLmRvbmUocy5zdWNjZXNzKTtcbiAgICAgIGpxWEhSLmZhaWwocy5lcnJvcik7XG5cbiAgICAgIC8vIEdldCB0cmFuc3BvcnRcbiAgICAgIHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSKTtcblxuICAgICAgLy8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG4gICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICBkb25lKC0xLCBcIk5vIFRyYW5zcG9ydFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG4gICAgICAgIC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG4gICAgICAgIGlmIChmaXJlR2xvYmFscykge1xuICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKFwiYWpheFNlbmRcIiwgW2pxWEhSLCBzXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuICAgICAgICBpZiAoY29tcGxldGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGpxWEhSO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGltZW91dFxuICAgICAgICBpZiAocy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgdGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBqcVhIUi5hYm9ydChcInRpbWVvdXRcIik7XG4gICAgICAgICAgfSwgcy50aW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQocmVxdWVzdEhlYWRlcnMsIGRvbmUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG4gICAgICAgICAgZG9uZSgtMSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG4gICAgICBmdW5jdGlvbiBkb25lKHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzKSB7XG4gICAgICAgIHZhciBpc1N1Y2Nlc3MsXG4gICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBtb2RpZmllZCxcbiAgICAgICAgICBzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuICAgICAgICAvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG4gICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmICh0aW1lb3V0VGltZXIpIHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgICAvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuICAgICAgICB0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cbiAgICAgICAgLy8gU2V0IHJlYWR5U3RhdGVcbiAgICAgICAganFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuICAgICAgICBpc1N1Y2Nlc3MgPSAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG4gICAgICAgIC8vIEdldCByZXNwb25zZSBkYXRhXG4gICAgICAgIGlmIChyZXNwb25zZXMpIHtcbiAgICAgICAgICByZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMocywganFYSFIsIHJlc3BvbnNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG4gICAgICAgIHJlc3BvbnNlID0gYWpheENvbnZlcnQocywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MpO1xuXG4gICAgICAgIC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG4gICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuICAgICAgICAgIGlmIChzLmlmTW9kaWZpZWQpIHtcbiAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpO1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiZXRhZ1wiKTtcbiAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgICAgICAgICBqUXVlcnkuZXRhZ1tjYWNoZVVSTF0gPSBtb2RpZmllZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiBubyBjb250ZW50XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG4gICAgICAgICAgICAvLyBpZiBub3QgbW9kaWZpZWRcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuICAgICAgICAgICAgc3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgaXNTdWNjZXNzID0gIWVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG4gICAgICAgICAgZXJyb3IgPSBzdGF0dXNUZXh0O1xuICAgICAgICAgIGlmIChzdGF0dXMgfHwgIXN0YXR1c1RleHQpIHtcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG4gICAgICAgICAgICBpZiAoc3RhdHVzIDwgMCkge1xuICAgICAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG4gICAgICAgIGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAganFYSFIuc3RhdHVzVGV4dCA9IChuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQpICsgXCJcIjtcblxuICAgICAgICAvLyBTdWNjZXNzL0Vycm9yXG4gICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChjYWxsYmFja0NvbnRleHQsIFtzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoY2FsbGJhY2tDb250ZXh0LCBbanFYSFIsIHN0YXR1c1RleHQsIGVycm9yXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuICAgICAgICBqcVhIUi5zdGF0dXNDb2RlKHN0YXR1c0NvZGUpO1xuICAgICAgICBzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChmaXJlR2xvYmFscykge1xuICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsIFtcbiAgICAgICAgICAgIGpxWEhSLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvclxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGxldGVcbiAgICAgICAgY29tcGxldGVEZWZlcnJlZC5maXJlV2l0aChjYWxsYmFja0NvbnRleHQsIFtqcVhIUiwgc3RhdHVzVGV4dF0pO1xuXG4gICAgICAgIGlmIChmaXJlR2xvYmFscykge1xuICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKFwiYWpheENvbXBsZXRlXCIsIFtqcVhIUiwgc10pO1xuXG4gICAgICAgICAgLy8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG4gICAgICAgICAgaWYgKCEtLWpRdWVyeS5hY3RpdmUpIHtcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqcVhIUjtcbiAgICB9LFxuXG4gICAgZ2V0SlNPTjogZnVuY3Rpb24odXJsLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGpRdWVyeS5nZXQodXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIpO1xuICAgIH0sXG5cbiAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBqUXVlcnkuZ2V0KHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIik7XG4gICAgfVxuICB9KTtcblxuICBqUXVlcnkuZWFjaChbXCJnZXRcIiwgXCJwb3N0XCJdLCBmdW5jdGlvbihpLCBtZXRob2QpIHtcbiAgICBqUXVlcnlbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgICAgIC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG4gICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oZGF0YSkpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG4gICAgICByZXR1cm4galF1ZXJ5LmFqYXgoXG4gICAgICAgIGpRdWVyeS5leHRlbmQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICB0eXBlOiBtZXRob2QsXG4gICAgICAgICAgICBkYXRhVHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBzdWNjZXNzOiBjYWxsYmFja1xuICAgICAgICAgIH0sXG4gICAgICAgICAgalF1ZXJ5LmlzUGxhaW5PYmplY3QodXJsKSAmJiB1cmxcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9O1xuICB9KTtcblxuICBqUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICByZXR1cm4galF1ZXJ5LmFqYXgoe1xuICAgICAgdXJsOiB1cmwsXG5cbiAgICAgIC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgIGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuICAgICAgY2FjaGU6IHRydWUsXG4gICAgICBhc3luYzogZmFsc2UsXG4gICAgICBnbG9iYWw6IGZhbHNlLFxuICAgICAgdGhyb3dzOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgd3JhcEFsbDogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgdmFyIHdyYXA7XG5cbiAgICAgIGlmICh0aGlzWzBdKSB7XG4gICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihodG1sKSkge1xuICAgICAgICAgIGh0bWwgPSBodG1sLmNhbGwodGhpc1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuICAgICAgICB3cmFwID0galF1ZXJ5KGh0bWwsIHRoaXNbMF0ub3duZXJEb2N1bWVudClcbiAgICAgICAgICAuZXEoMClcbiAgICAgICAgICAuY2xvbmUodHJ1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXNbMF0ucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgd3JhcFxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXM7XG5cbiAgICAgICAgICAgIHdoaWxlIChlbGVtLmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICAgIGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5hcHBlbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB3cmFwSW5uZXI6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihodG1sKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICBqUXVlcnkodGhpcykud3JhcElubmVyKGh0bWwuY2FsbCh0aGlzLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKSxcbiAgICAgICAgICBjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGVudHMud3JhcEFsbChodG1sKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmFwcGVuZChodG1sKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHdyYXA6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oaHRtbCk7XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBqUXVlcnkodGhpcykud3JhcEFsbChpc0Z1bmN0aW9uID8gaHRtbC5jYWxsKHRoaXMsIGkpIDogaHRtbCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgdW53cmFwOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgdGhpcy5wYXJlbnQoc2VsZWN0b3IpXG4gICAgICAgIC5ub3QoXCJib2R5XCIpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGpRdWVyeSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpO1xuICAgICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgalF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgcmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoZWxlbSk7XG4gIH07XG4gIGpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICByZXR1cm4gISEoXG4gICAgICBlbGVtLm9mZnNldFdpZHRoIHx8XG4gICAgICBlbGVtLm9mZnNldEhlaWdodCB8fFxuICAgICAgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aFxuICAgICk7XG4gIH07XG5cbiAgalF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9O1xuXG4gIHZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuICAgICAgLy8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcbiAgICAgIDA6IDIwMCxcblxuICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAgIC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuICAgICAgMTIyMzogMjA0XG4gICAgfSxcbiAgICB4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG4gIHN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkO1xuICBzdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxuICBqUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG4gICAgLy8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuICAgIGlmIChzdXBwb3J0LmNvcnMgfHwgKHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uKGhlYWRlcnMsIGNvbXBsZXRlKSB7XG4gICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICB4aHIgPSBvcHRpb25zLnhocigpO1xuXG4gICAgICAgICAgeGhyLm9wZW4oXG4gICAgICAgICAgICBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgICBvcHRpb25zLnVybCxcbiAgICAgICAgICAgIG9wdGlvbnMuYXN5bmMsXG4gICAgICAgICAgICBvcHRpb25zLnVzZXJuYW1lLFxuICAgICAgICAgICAgb3B0aW9ucy5wYXNzd29yZFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG4gICAgICAgICAgaWYgKG9wdGlvbnMueGhyRmllbGRzKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gb3B0aW9ucy54aHJGaWVsZHMpIHtcbiAgICAgICAgICAgICAgeGhyW2ldID0gb3B0aW9ucy54aHJGaWVsZHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuICAgICAgICAgIGlmIChvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XG4gICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShvcHRpb25zLm1pbWVUeXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuICAgICAgICAgIC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcbiAgICAgICAgICAvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuICAgICAgICAgIC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuICAgICAgICAgIC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuICAgICAgICAgIGlmICghb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCBoZWFkZXJzXG4gICAgICAgICAgZm9yIChpIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIGhlYWRlcnNbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPSB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhYm9ydFwiKSB7XG4gICAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAgICAgICAgICAgICAgIC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuICAgICAgICAgICAgICAgICAgLy8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKDAsIFwiZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29tcGxldGUoXG4gICAgICAgICAgICAgICAgICAgIHhoclN1Y2Nlc3NTdGF0dXNbeGhyLnN0YXR1c10gfHwgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHQsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgLy8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuICAgICAgICAgICAgICAgICAgICAoeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIikgIT09IFwidGV4dFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgPyB7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH1cbiAgICAgICAgICAgICAgICAgICAgICA6IHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBMaXN0ZW4gdG8gZXZlbnRzXG4gICAgICAgICAgeGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG4gICAgICAgICAgZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soXCJlcnJvclwiKTtcblxuICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgb25seVxuICAgICAgICAgIC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG4gICAgICAgICAgLy8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuICAgICAgICAgIGlmICh4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG4gICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuICAgICAgICAgICAgICAgIC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgLy8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKFwiYWJvcnRcIik7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuICAgICAgICAgICAgeGhyLnNlbmQoKG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEpIHx8IG51bGwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxuICBqUXVlcnkuYWpheFByZWZpbHRlcihmdW5jdGlvbihzKSB7XG4gICAgaWYgKHMuY3Jvc3NEb21haW4pIHtcbiAgICAgIHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxuICBqUXVlcnkuYWpheFNldHVwKHtcbiAgICBhY2NlcHRzOiB7XG4gICAgICBzY3JpcHQ6XG4gICAgICAgIFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG4gICAgICAgIFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcbiAgICB9LFxuICAgIGNvbnRlbnRzOiB7XG4gICAgICBzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuICAgIH0sXG4gICAgY29udmVydGVyczoge1xuICAgICAgXCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKHRleHQpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbiAgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIoXCJzY3JpcHRcIiwgZnVuY3Rpb24ocykge1xuICAgIGlmIChzLmNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMuY2FjaGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHMuY3Jvc3NEb21haW4pIHtcbiAgICAgIHMudHlwZSA9IFwiR0VUXCI7XG4gICAgfVxuICB9KTtcblxuICAvLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbiAgalF1ZXJ5LmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIiwgZnVuY3Rpb24ocykge1xuICAgIC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcbiAgICBpZiAocy5jcm9zc0RvbWFpbikge1xuICAgICAgdmFyIHNjcmlwdCwgY2FsbGJhY2s7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZW5kOiBmdW5jdGlvbihfLCBjb21wbGV0ZSkge1xuICAgICAgICAgIHNjcmlwdCA9IGpRdWVyeShcIjxzY3JpcHQ+XCIpXG4gICAgICAgICAgICAucHJvcCh7XG4gICAgICAgICAgICAgIGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcbiAgICAgICAgICAgICAgc3JjOiBzLnVybFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbihcbiAgICAgICAgICAgICAgXCJsb2FkIGVycm9yXCIsXG4gICAgICAgICAgICAgIChjYWxsYmFjayA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIHNjcmlwdC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgICAgICAgY29tcGxldGUoZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcbiAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdFswXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuICAgIHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbiAgLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xuICBqUXVlcnkuYWpheFNldHVwKHtcbiAgICBqc29ucDogXCJjYWxsYmFja1wiLFxuICAgIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8IGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyBub25jZSsrO1xuICAgICAgdGhpc1tjYWxsYmFja10gPSB0cnVlO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG4gIGpRdWVyeS5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLCBmdW5jdGlvbihzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUikge1xuICAgIHZhciBjYWxsYmFja05hbWUsXG4gICAgICBvdmVyd3JpdHRlbixcbiAgICAgIHJlc3BvbnNlQ29udGFpbmVyLFxuICAgICAganNvblByb3AgPVxuICAgICAgICBzLmpzb25wICE9PSBmYWxzZSAmJlxuICAgICAgICAocmpzb25wLnRlc3Qocy51cmwpXG4gICAgICAgICAgPyBcInVybFwiXG4gICAgICAgICAgOiB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAocy5jb250ZW50VHlwZSB8fCBcIlwiKS5pbmRleE9mKFxuICAgICAgICAgICAgICBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgICAgICAgICApID09PSAwICYmXG4gICAgICAgICAgICByanNvbnAudGVzdChzLmRhdGEpICYmXG4gICAgICAgICAgICBcImRhdGFcIik7XG5cbiAgICAvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG4gICAgaWYgKGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWzBdID09PSBcImpzb25wXCIpIHtcbiAgICAgIC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcbiAgICAgIGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKHMuanNvbnBDYWxsYmFjaylcbiAgICAgICAgPyBzLmpzb25wQ2FsbGJhY2soKVxuICAgICAgICA6IHMuanNvbnBDYWxsYmFjaztcblxuICAgICAgLy8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuICAgICAgaWYgKGpzb25Qcm9wKSB7XG4gICAgICAgIHNbanNvblByb3BdID0gc1tqc29uUHJvcF0ucmVwbGFjZShyanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHMuanNvbnAgIT09IGZhbHNlKSB7XG4gICAgICAgIHMudXJsICs9XG4gICAgICAgICAgKHJxdWVyeS50ZXN0KHMudXJsKSA/IFwiJlwiIDogXCI/XCIpICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG4gICAgICBzLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlQ29udGFpbmVyKSB7XG4gICAgICAgICAgalF1ZXJ5LmVycm9yKGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZUNvbnRhaW5lclswXTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcbiAgICAgIHMuZGF0YVR5cGVzWzBdID0gXCJqc29uXCI7XG5cbiAgICAgIC8vIEluc3RhbGwgY2FsbGJhY2tcbiAgICAgIG92ZXJ3cml0dGVuID0gd2luZG93W2NhbGxiYWNrTmFtZV07XG4gICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcbiAgICAgIH07XG5cbiAgICAgIC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuICAgICAganFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcbiAgICAgICAgaWYgKG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBqUXVlcnkod2luZG93KS5yZW1vdmVQcm9wKGNhbGxiYWNrTmFtZSk7XG5cbiAgICAgICAgICAvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gb3ZlcndyaXR0ZW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIGJhY2sgYXMgZnJlZVxuICAgICAgICBpZiAoc1tjYWxsYmFja05hbWVdKSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG4gICAgICAgICAgcy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG4gICAgICAgICAgLy8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuICAgICAgICAgIG9sZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2VcbiAgICAgICAgaWYgKHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKG92ZXJ3cml0dGVuKSkge1xuICAgICAgICAgIG92ZXJ3cml0dGVuKHJlc3BvbnNlQ29udGFpbmVyWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gRGVsZWdhdGUgdG8gc2NyaXB0XG4gICAgICByZXR1cm4gXCJzY3JpcHRcIjtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbiAgLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuICAvLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbiAgLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG4gIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpLmJvZHk7XG4gICAgYm9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG4gICAgcmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG4gIH0pKCk7XG5cbiAgLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4gIC8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbiAgLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbiAgLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xuICBqUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAga2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuICAgICAgY29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuICAgICAgLy8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cbiAgICAgIGlmIChzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCkge1xuICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiXCIpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuICAgICAgICAvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuICAgICAgICAvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuICAgICAgICBiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKTtcbiAgICAgICAgYmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgICAgICAgY29udGV4dC5oZWFkLmFwcGVuZENoaWxkKGJhc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dCA9IGRvY3VtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyhkYXRhKTtcbiAgICBzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG4gICAgLy8gU2luZ2xlIHRhZ1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBbY29udGV4dC5jcmVhdGVFbGVtZW50KHBhcnNlZFsxXSldO1xuICAgIH1cblxuICAgIHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoW2RhdGFdLCBjb250ZXh0LCBzY3JpcHRzKTtcblxuICAgIGlmIChzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgICBqUXVlcnkoc2NyaXB0cykucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpRdWVyeS5tZXJnZShbXSwgcGFyc2VkLmNoaWxkTm9kZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gICAqL1xuICBqUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKHVybCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxlY3RvcixcbiAgICAgIHR5cGUsXG4gICAgICByZXNwb25zZSxcbiAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgb2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xuXG4gICAgaWYgKG9mZiA+IC0xKSB7XG4gICAgICBzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UodXJsLnNsaWNlKG9mZikpO1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIG9mZik7XG4gICAgfVxuXG4gICAgLy8gSWYgaXQncyBhIGZ1bmN0aW9uXG4gICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHBhcmFtcykpIHtcbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHR5cGUgPSBcIlBPU1RcIjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuICAgIGlmIChzZWxmLmxlbmd0aCA+IDApIHtcbiAgICAgIGpRdWVyeVxuICAgICAgICAuYWpheCh7XG4gICAgICAgICAgdXJsOiB1cmwsXG5cbiAgICAgICAgICAvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgIC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuICAgICAgICAgIC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuICAgICAgICAgIHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcbiAgICAgICAgICBkYXRhVHlwZTogXCJodG1sXCIsXG4gICAgICAgICAgZGF0YTogcGFyYW1zXG4gICAgICAgIH0pXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uKHJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuICAgICAgICAgIHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG4gICAgICAgICAgc2VsZi5odG1sKFxuICAgICAgICAgICAgc2VsZWN0b3JcbiAgICAgICAgICAgICAgPyAvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcbiAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcbiAgICAgICAgICAgICAgICBqUXVlcnkoXCI8ZGl2PlwiKVxuICAgICAgICAgICAgICAgICAgLmFwcGVuZChqUXVlcnkucGFyc2VIVE1MKHJlc3BvbnNlVGV4dCkpXG4gICAgICAgICAgICAgICAgICAuZmluZChzZWxlY3RvcilcbiAgICAgICAgICAgICAgOiAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcbiAgICAgICAgICAvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG4gICAgICAgICAgLy8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuICAgICAgICB9KVxuICAgICAgICAuYWx3YXlzKFxuICAgICAgICAgIGNhbGxiYWNrICYmXG4gICAgICAgICAgICBmdW5jdGlvbihqcVhIUiwgc3RhdHVzKSB7XG4gICAgICAgICAgICAgIHNlbGYuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShcbiAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZSB8fCBbanFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG4gIGpRdWVyeS5lYWNoKFxuICAgIFtcbiAgICAgIFwiYWpheFN0YXJ0XCIsXG4gICAgICBcImFqYXhTdG9wXCIsXG4gICAgICBcImFqYXhDb21wbGV0ZVwiLFxuICAgICAgXCJhamF4RXJyb3JcIixcbiAgICAgIFwiYWpheFN1Y2Nlc3NcIixcbiAgICAgIFwiYWpheFNlbmRcIlxuICAgIF0sXG4gICAgZnVuY3Rpb24oaSwgdHlwZSkge1xuICAgICAgalF1ZXJ5LmZuW3R5cGVdID0gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24odHlwZSwgZm4pO1xuICAgICAgfTtcbiAgICB9XG4gICk7XG5cbiAgalF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICByZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oZm4pIHtcbiAgICAgIHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuICAgIH0pLmxlbmd0aDtcbiAgfTtcblxuICBqUXVlcnkub2Zmc2V0ID0ge1xuICAgIHNldE9mZnNldDogZnVuY3Rpb24oZWxlbSwgb3B0aW9ucywgaSkge1xuICAgICAgdmFyIGN1clBvc2l0aW9uLFxuICAgICAgICBjdXJMZWZ0LFxuICAgICAgICBjdXJDU1NUb3AsXG4gICAgICAgIGN1clRvcCxcbiAgICAgICAgY3VyT2Zmc2V0LFxuICAgICAgICBjdXJDU1NMZWZ0LFxuICAgICAgICBjYWxjdWxhdGVQb3NpdGlvbixcbiAgICAgICAgcG9zaXRpb24gPSBqUXVlcnkuY3NzKGVsZW0sIFwicG9zaXRpb25cIiksXG4gICAgICAgIGN1ckVsZW0gPSBqUXVlcnkoZWxlbSksXG4gICAgICAgIHByb3BzID0ge307XG5cbiAgICAgIC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgfVxuXG4gICAgICBjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuICAgICAgY3VyQ1NTVG9wID0galF1ZXJ5LmNzcyhlbGVtLCBcInRvcFwiKTtcbiAgICAgIGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKGVsZW0sIFwibGVmdFwiKTtcbiAgICAgIGNhbGN1bGF0ZVBvc2l0aW9uID1cbiAgICAgICAgKHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIikgJiZcbiAgICAgICAgKGN1ckNTU1RvcCArIGN1ckNTU0xlZnQpLmluZGV4T2YoXCJhdXRvXCIpID4gLTE7XG5cbiAgICAgIC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG4gICAgICAvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcbiAgICAgIGlmIChjYWxjdWxhdGVQb3NpdGlvbikge1xuICAgICAgICBjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcbiAgICAgICAgY3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuICAgICAgICBjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1clRvcCA9IHBhcnNlRmxvYXQoY3VyQ1NTVG9wKSB8fCAwO1xuICAgICAgICBjdXJMZWZ0ID0gcGFyc2VGbG9hdChjdXJDU1NMZWZ0KSB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgLy8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCh7fSwgY3VyT2Zmc2V0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRvcCAhPSBudWxsKSB7XG4gICAgICAgIHByb3BzLnRvcCA9IG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCArIGN1clRvcDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmxlZnQgIT0gbnVsbCkge1xuICAgICAgICBwcm9wcy5sZWZ0ID0gb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKyBjdXJMZWZ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoXCJ1c2luZ1wiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy51c2luZy5jYWxsKGVsZW0sIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1ckVsZW0uY3NzKHByb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XG4gICAgb2Zmc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgOiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICBqUXVlcnkub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBvcHRpb25zLCBpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZG9jLFxuICAgICAgICBkb2NFbGVtLFxuICAgICAgICByZWN0LFxuICAgICAgICB3aW4sXG4gICAgICAgIGVsZW0gPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcbiAgICAgIC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuICAgICAgLy8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuICAgICAgLy8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG4gICAgICBpZiAoIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICB9XG5cbiAgICAgIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG4gICAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpc1swXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXRQYXJlbnQsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgZWxlbSA9IHRoaXNbMF0sXG4gICAgICAgIHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cbiAgICAgIC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcbiAgICAgIGlmIChqUXVlcnkuY3NzKGVsZW0sIFwicG9zaXRpb25cIikgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcbiAgICAgICAgb2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG4gICAgICAgIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cbiAgICAgICAgLy8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuICAgICAgICBpZiAoIW5vZGVOYW1lKG9mZnNldFBhcmVudFswXSwgXCJodG1sXCIpKSB7XG4gICAgICAgICAgcGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG4gICAgICAgIHBhcmVudE9mZnNldCA9IHtcbiAgICAgICAgICB0b3A6XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQudG9wICtcbiAgICAgICAgICAgIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50WzBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUpLFxuICAgICAgICAgIGxlZnQ6XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQubGVmdCArXG4gICAgICAgICAgICBqUXVlcnkuY3NzKG9mZnNldFBhcmVudFswXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOlxuICAgICAgICAgIG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyhlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlKSxcbiAgICAgICAgbGVmdDpcbiAgICAgICAgICBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyhlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgIC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cbiAgICAvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcbiAgICAvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG4gICAgLy8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuICAgIC8vXG4gICAgLy8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG4gICAgLy8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG4gICAgLy9cbiAgICAvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgb2Zmc2V0UGFyZW50ICYmXG4gICAgICAgICAgalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIikgPT09IFwic3RhdGljXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbiAgalF1ZXJ5LmVhY2goeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKFxuICAgIG1ldGhvZCxcbiAgICBwcm9wXG4gICkge1xuICAgIHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cbiAgICBqUXVlcnkuZm5bbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuIGFjY2VzcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgZnVuY3Rpb24oZWxlbSwgbWV0aG9kLCB2YWwpIHtcbiAgICAgICAgICAvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3NcbiAgICAgICAgICB2YXIgd2luO1xuICAgICAgICAgIGlmIChqUXVlcnkuaXNXaW5kb3coZWxlbSkpIHtcbiAgICAgICAgICAgIHdpbiA9IGVsZW07XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtLm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgICAgICB3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbiA/IHdpbltwcm9wXSA6IGVsZW1bbWV0aG9kXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod2luKSB7XG4gICAgICAgICAgICB3aW4uc2Nyb2xsVG8oXG4gICAgICAgICAgICAgICF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgIHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbVttZXRob2RdID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICB2YWwsXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuICAvLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuICAvLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbiAgLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbiAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbiAgLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbiAgalF1ZXJ5LmVhY2goW1widG9wXCIsIFwibGVmdFwiXSwgZnVuY3Rpb24oaSwgcHJvcCkge1xuICAgIGpRdWVyeS5jc3NIb29rc1twcm9wXSA9IGFkZEdldEhvb2tJZihzdXBwb3J0LnBpeGVsUG9zaXRpb24sIGZ1bmN0aW9uKFxuICAgICAgZWxlbSxcbiAgICAgIGNvbXB1dGVkXG4gICAgKSB7XG4gICAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBjdXJDU1MoZWxlbSwgcHJvcCk7XG5cbiAgICAgICAgLy8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG4gICAgICAgIHJldHVybiBybnVtbm9ucHgudGVzdChjb21wdXRlZClcbiAgICAgICAgICA/IGpRdWVyeShlbGVtKS5wb3NpdGlvbigpW3Byb3BdICsgXCJweFwiXG4gICAgICAgICAgOiBjb21wdXRlZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG4gIGpRdWVyeS5lYWNoKHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKG5hbWUsIHR5cGUpIHtcbiAgICBqUXVlcnkuZWFjaChcbiAgICAgIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuICAgICAgZnVuY3Rpb24oZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSkge1xuICAgICAgICAvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcbiAgICAgICAgalF1ZXJ5LmZuW2Z1bmNOYW1lXSA9IGZ1bmN0aW9uKG1hcmdpbiwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgY2hhaW5hYmxlID1cbiAgICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCAmJiAoZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiKSxcbiAgICAgICAgICAgIGV4dHJhID1cbiAgICAgICAgICAgICAgZGVmYXVsdEV4dHJhIHx8XG4gICAgICAgICAgICAgIChtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIik7XG5cbiAgICAgICAgICByZXR1cm4gYWNjZXNzKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVsZW0sIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciBkb2M7XG5cbiAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc1dpbmRvdyhlbGVtKSkge1xuICAgICAgICAgICAgICAgIC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoXCJvdXRlclwiKSA9PT0gMFxuICAgICAgICAgICAgICAgICAgPyBlbGVtW1wiaW5uZXJcIiArIG5hbWVdXG4gICAgICAgICAgICAgICAgICA6IGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W1wiY2xpZW50XCIgKyBuYW1lXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICBkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3RcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICBlbGVtLmJvZHlbXCJzY3JvbGxcIiArIG5hbWVdLFxuICAgICAgICAgICAgICAgICAgZG9jW1wic2Nyb2xsXCIgKyBuYW1lXSxcbiAgICAgICAgICAgICAgICAgIGVsZW0uYm9keVtcIm9mZnNldFwiICsgbmFtZV0sXG4gICAgICAgICAgICAgICAgICBkb2NbXCJvZmZzZXRcIiArIG5hbWVdLFxuICAgICAgICAgICAgICAgICAgZG9jW1wiY2xpZW50XCIgKyBuYW1lXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gLy8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCB0eXBlLCBleHRyYSlcbiAgICAgICAgICAgICAgICA6IC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFpbmFibGVcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xuICAgIGJpbmQ6IGZ1bmN0aW9uKHR5cGVzLCBkYXRhLCBmbikge1xuICAgICAgcmV0dXJuIHRoaXMub24odHlwZXMsIG51bGwsIGRhdGEsIGZuKTtcbiAgICB9LFxuICAgIHVuYmluZDogZnVuY3Rpb24odHlwZXMsIGZuKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmYodHlwZXMsIG51bGwsIGZuKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uKHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4pIHtcbiAgICAgIHJldHVybiB0aGlzLm9uKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pO1xuICAgIH0sXG4gICAgdW5kZWxlZ2F0ZTogZnVuY3Rpb24oc2VsZWN0b3IsIHR5cGVzLCBmbikge1xuICAgICAgLy8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyB0aGlzLm9mZihzZWxlY3RvciwgXCIqKlwiKVxuICAgICAgICA6IHRoaXMub2ZmKHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuKTtcbiAgICB9XG4gIH0pO1xuXG4gIGpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbihob2xkKSB7XG4gICAgaWYgKGhvbGQpIHtcbiAgICAgIGpRdWVyeS5yZWFkeVdhaXQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgalF1ZXJ5LnJlYWR5KHRydWUpO1xuICAgIH1cbiAgfTtcbiAgalF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICBqUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbiAgalF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5cbiAgLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4gIC8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbiAgLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4gIC8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbiAgLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4gIC8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuICAvLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbiAgLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbiAgLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuICAvLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBqUXVlcnk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgLy8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgX2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG4gICAgLy8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICBfJCA9IHdpbmRvdy4kO1xuXG4gIGpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oZGVlcCkge1xuICAgIGlmICh3aW5kb3cuJCA9PT0galF1ZXJ5KSB7XG4gICAgICB3aW5kb3cuJCA9IF8kO1xuICAgIH1cblxuICAgIGlmIChkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSkge1xuICAgICAgd2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpRdWVyeTtcbiAgfTtcblxuICAvLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuICAvLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4gIC8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbiAgaWYgKCFub0dsb2JhbCkge1xuICAgIHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbiAgfVxuXG4gIHJldHVybiBqUXVlcnk7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gKG1vZHVsZS5leHBvcnRzID1cbiAgdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIHNlbGYgIT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLk1hdGggPT0gTWF0aFxuICAgICAgPyBzZWxmXG4gICAgICA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgICBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkpO1xuaWYgKHR5cGVvZiBfX2cgPT0gXCJudW1iZXJcIikgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoXCIuL19nbG9iYWxcIik7XG52YXIgY29yZSA9IHJlcXVpcmUoXCIuL19jb3JlXCIpO1xudmFyIGN0eCA9IHJlcXVpcmUoXCIuL19jdHhcIik7XG52YXIgaGlkZSA9IHJlcXVpcmUoXCIuL19oaWRlXCIpO1xudmFyIFBST1RPVFlQRSA9IFwicHJvdG90eXBlXCI7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUxcbiAgICA/IGdsb2JhbFxuICAgIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBrZXkgaW4gZXhwb3J0cykgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9XG4gICAgICBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IHNvdXJjZVtrZXldXG4gICAgICAgIDogLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICAgICAgICBJU19CSU5EICYmIG93blxuICAgICAgICAgID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgICAgICAgIDogLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICAgICAgICAgIElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0XG4gICAgICAgICAgICA/IChmdW5jdGlvbihDKSB7XG4gICAgICAgICAgICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgICAgICAgICAgIHJldHVybiBGO1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgICAgICAgICAgICB9KShvdXQpXG4gICAgICAgICAgICA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dClcbiAgICAgICAgICAgICAgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYgKElTX1BST1RPKSB7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pXG4gICAgICAgIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7IC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7IC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgZGVmYXVsdDogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoXCIuL19pcy1vYmplY3RcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyBcIiBpcyBub3QgYW4gb2JqZWN0IVwiKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9XG4gICFyZXF1aXJlKFwiLi9fZGVzY3JpcHRvcnNcIikgJiZcbiAgIXJlcXVpcmUoXCIuL19mYWlsc1wiKShmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoXCIuL19kb20tY3JlYXRlXCIpKFwiZGl2XCIpLCBcImFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICB9XG4gICAgICB9KS5hICE9IDdcbiAgICApO1xuICB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoXCIuL19pcy1vYmplY3RcIik7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChcbiAgICBTICYmXG4gICAgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAhaXNPYmplY3QoKHZhbCA9IGZuLmNhbGwoaXQpKSlcbiAgKVxuICAgIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gXCJmdW5jdGlvblwiICYmICFpc09iamVjdCgodmFsID0gZm4uY2FsbChpdCkpKSlcbiAgICByZXR1cm4gdmFsO1xuICBpZiAoXG4gICAgIVMgJiZcbiAgICB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09IFwiZnVuY3Rpb25cIiAmJlxuICAgICFpc09iamVjdCgodmFsID0gZm4uY2FsbChpdCkpKVxuICApXG4gICAgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoXCIuL19pb2JqZWN0XCIpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKFwiLi9fZGVmaW5lZFwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24od2luZG93LCBmYWN0b3J5KSB7XG4gIHZhciBsYXp5U2l6ZXMgPSBmYWN0b3J5KHdpbmRvdywgd2luZG93LmRvY3VtZW50KTtcbiAgd2luZG93LmxhenlTaXplcyA9IGxhenlTaXplcztcbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbGF6eVNpemVzO1xuICB9XG59KSh3aW5kb3csIGZ1bmN0aW9uIGwod2luZG93LCBkb2N1bWVudCkge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhenlzaXplcywgbGF6eVNpemVzQ29uZmlnO1xuXG4gIHZhciBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gIHZhciBEYXRlID0gd2luZG93LkRhdGU7XG5cbiAgdmFyIHN1cHBvcnRQaWN0dXJlID0gd2luZG93LkhUTUxQaWN0dXJlRWxlbWVudDtcblxuICB2YXIgX2FkZEV2ZW50TGlzdGVuZXIgPSBcImFkZEV2ZW50TGlzdGVuZXJcIjtcblxuICB2YXIgX2dldEF0dHJpYnV0ZSA9IFwiZ2V0QXR0cmlidXRlXCI7XG5cbiAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSB3aW5kb3dbX2FkZEV2ZW50TGlzdGVuZXJdO1xuXG4gIHZhciBzZXRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQ7XG5cbiAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgc2V0VGltZW91dDtcblxuICB2YXIgcmVxdWVzdElkbGVDYWxsYmFjayA9IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrO1xuXG4gIHZhciByZWdQaWN0dXJlID0gL15waWN0dXJlJC9pO1xuXG4gIHZhciBsb2FkRXZlbnRzID0gW1wibG9hZFwiLCBcImVycm9yXCIsIFwibGF6eWluY2x1ZGVkXCIsIFwiX2xhenlsb2FkZWRcIl07XG5cbiAgdmFyIHJlZ0NsYXNzQ2FjaGUgPSB7fTtcblxuICB2YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuXG4gIHZhciBoYXNDbGFzcyA9IGZ1bmN0aW9uKGVsZSwgY2xzKSB7XG4gICAgaWYgKCFyZWdDbGFzc0NhY2hlW2Nsc10pIHtcbiAgICAgIHJlZ0NsYXNzQ2FjaGVbY2xzXSA9IG5ldyBSZWdFeHAoXCIoXFxcXHN8XilcIiArIGNscyArIFwiKFxcXFxzfCQpXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgcmVnQ2xhc3NDYWNoZVtjbHNdLnRlc3QoZWxlW19nZXRBdHRyaWJ1dGVdKFwiY2xhc3NcIikgfHwgXCJcIikgJiZcbiAgICAgIHJlZ0NsYXNzQ2FjaGVbY2xzXVxuICAgICk7XG4gIH07XG5cbiAgdmFyIGFkZENsYXNzID0gZnVuY3Rpb24oZWxlLCBjbHMpIHtcbiAgICBpZiAoIWhhc0NsYXNzKGVsZSwgY2xzKSkge1xuICAgICAgZWxlLnNldEF0dHJpYnV0ZShcbiAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAoZWxlW19nZXRBdHRyaWJ1dGVdKFwiY2xhc3NcIikgfHwgXCJcIikudHJpbSgpICsgXCIgXCIgKyBjbHNcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsZSwgY2xzKSB7XG4gICAgdmFyIHJlZztcbiAgICBpZiAoKHJlZyA9IGhhc0NsYXNzKGVsZSwgY2xzKSkpIHtcbiAgICAgIGVsZS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgIFwiY2xhc3NcIixcbiAgICAgICAgKGVsZVtfZ2V0QXR0cmlidXRlXShcImNsYXNzXCIpIHx8IFwiXCIpLnJlcGxhY2UocmVnLCBcIiBcIilcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhZGRSZW1vdmVMb2FkRXZlbnRzID0gZnVuY3Rpb24oZG9tLCBmbiwgYWRkKSB7XG4gICAgdmFyIGFjdGlvbiA9IGFkZCA/IF9hZGRFdmVudExpc3RlbmVyIDogXCJyZW1vdmVFdmVudExpc3RlbmVyXCI7XG4gICAgaWYgKGFkZCkge1xuICAgICAgYWRkUmVtb3ZlTG9hZEV2ZW50cyhkb20sIGZuKTtcbiAgICB9XG4gICAgbG9hZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgZG9tW2FjdGlvbl0oZXZ0LCBmbik7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIGRldGFpbCwgbm9CdWJibGVzLCBub0NhbmNlbGFibGUpIHtcbiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuXG4gICAgaWYgKCFkZXRhaWwpIHtcbiAgICAgIGRldGFpbCA9IHt9O1xuICAgIH1cblxuICAgIGRldGFpbC5pbnN0YW5jZSA9IGxhenlzaXplcztcblxuICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChuYW1lLCAhbm9CdWJibGVzLCAhbm9DYW5jZWxhYmxlLCBkZXRhaWwpO1xuXG4gICAgZWxlbS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVBvbHlmaWxsID0gZnVuY3Rpb24oZWwsIGZ1bGwpIHtcbiAgICB2YXIgcG9seWZpbGw7XG4gICAgaWYgKFxuICAgICAgIXN1cHBvcnRQaWN0dXJlICYmXG4gICAgICAocG9seWZpbGwgPSB3aW5kb3cucGljdHVyZWZpbGwgfHwgbGF6eVNpemVzQ29uZmlnLnBmKVxuICAgICkge1xuICAgICAgcG9seWZpbGwoeyByZWV2YWx1YXRlOiB0cnVlLCBlbGVtZW50czogW2VsXSB9KTtcbiAgICB9IGVsc2UgaWYgKGZ1bGwgJiYgZnVsbC5zcmMpIHtcbiAgICAgIGVsLnNyYyA9IGZ1bGwuc3JjO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0Q1NTID0gZnVuY3Rpb24oZWxlbSwgc3R5bGUpIHtcbiAgICByZXR1cm4gKGdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCkgfHwge30pW3N0eWxlXTtcbiAgfTtcblxuICB2YXIgZ2V0V2lkdGggPSBmdW5jdGlvbihlbGVtLCBwYXJlbnQsIHdpZHRoKSB7XG4gICAgd2lkdGggPSB3aWR0aCB8fCBlbGVtLm9mZnNldFdpZHRoO1xuXG4gICAgd2hpbGUgKHdpZHRoIDwgbGF6eVNpemVzQ29uZmlnLm1pblNpemUgJiYgcGFyZW50ICYmICFlbGVtLl9sYXp5c2l6ZXNXaWR0aCkge1xuICAgICAgd2lkdGggPSBwYXJlbnQub2Zmc2V0V2lkdGg7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2lkdGg7XG4gIH07XG5cbiAgdmFyIHJBRiA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgcnVubmluZywgd2FpdGluZztcbiAgICB2YXIgZmlyc3RGbnMgPSBbXTtcbiAgICB2YXIgc2Vjb25kRm5zID0gW107XG4gICAgdmFyIGZucyA9IGZpcnN0Rm5zO1xuXG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJ1bkZucyA9IGZucztcblxuICAgICAgZm5zID0gZmlyc3RGbnMubGVuZ3RoID8gc2Vjb25kRm5zIDogZmlyc3RGbnM7XG5cbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgd2FpdGluZyA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAocnVuRm5zLmxlbmd0aCkge1xuICAgICAgICBydW5GbnMuc2hpZnQoKSgpO1xuICAgICAgfVxuXG4gICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciByYWZCYXRjaCA9IGZ1bmN0aW9uKGZuLCBxdWV1ZSkge1xuICAgICAgaWYgKHJ1bm5pbmcgJiYgIXF1ZXVlKSB7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbnMucHVzaChmbik7XG5cbiAgICAgICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgKGRvY3VtZW50LmhpZGRlbiA/IHNldFRpbWVvdXQgOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpKHJ1bik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmFmQmF0Y2guX2xzRmx1c2ggPSBydW47XG5cbiAgICByZXR1cm4gcmFmQmF0Y2g7XG4gIH0pKCk7XG5cbiAgdmFyIHJBRkl0ID0gZnVuY3Rpb24oZm4sIHNpbXBsZSkge1xuICAgIHJldHVybiBzaW1wbGVcbiAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgckFGKGZuKTtcbiAgICAgICAgfVxuICAgICAgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgckFGKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gIH07XG5cbiAgdmFyIHRocm90dGxlID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcnVubmluZztcbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgIHZhciBnRGVsYXkgPSAxMjU7XG4gICAgdmFyIHJJQ1RpbWVvdXQgPSBsYXp5U2l6ZXNDb25maWcucmljVGltZW91dDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24oKSB7XG4gICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICBsYXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBmbigpO1xuICAgIH07XG4gICAgdmFyIGlkbGVDYWxsYmFjayA9XG4gICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrICYmIGxhenlTaXplc0NvbmZpZy5yaWNUaW1lb3V0XG4gICAgICAgID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKHJ1biwgeyB0aW1lb3V0OiBySUNUaW1lb3V0IH0pO1xuXG4gICAgICAgICAgICBpZiAocklDVGltZW91dCAhPT0gbGF6eVNpemVzQ29uZmlnLnJpY1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgcklDVGltZW91dCA9IGxhenlTaXplc0NvbmZpZy5yaWNUaW1lb3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgOiByQUZJdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuKTtcbiAgICAgICAgICB9LCB0cnVlKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihpc1ByaW9yaXR5KSB7XG4gICAgICB2YXIgZGVsYXk7XG5cbiAgICAgIGlmICgoaXNQcmlvcml0eSA9IGlzUHJpb3JpdHkgPT09IHRydWUpKSB7XG4gICAgICAgIHJJQ1RpbWVvdXQgPSAzMztcbiAgICAgIH1cblxuICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgZGVsYXkgPSBnRGVsYXkgLSAoRGF0ZS5ub3coKSAtIGxhc3RUaW1lKTtcblxuICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1ByaW9yaXR5IHx8IChkZWxheSA8IDkgJiYgcmVxdWVzdElkbGVDYWxsYmFjaykpIHtcbiAgICAgICAgaWRsZUNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KGlkbGVDYWxsYmFjaywgZGVsYXkpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy9iYXNlZCBvbiBodHRwOi8vbW9kZXJuamF2YXNjcmlwdC5ibG9nc3BvdC5kZS8yMDEzLzA4L2J1aWxkaW5nLWJldHRlci1kZWJvdW5jZS5odG1sXG4gIHZhciBkZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgdGltZW91dCwgdGltZXN0YW1wO1xuICAgIHZhciB3YWl0ID0gOTk7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBmdW5jKCk7XG4gICAgfTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXN0ID0gRGF0ZS5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgICAgaWYgKGxhc3QgPCB3YWl0KSB7XG4gICAgICAgIHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChyZXF1ZXN0SWRsZUNhbGxiYWNrIHx8IHJ1bikocnVuKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvcDtcblxuICAgIHZhciBsYXp5U2l6ZXNEZWZhdWx0cyA9IHtcbiAgICAgIGxhenlDbGFzczogXCJsYXp5bG9hZFwiLFxuICAgICAgbG9hZGVkQ2xhc3M6IFwibGF6eWxvYWRlZFwiLFxuICAgICAgbG9hZGluZ0NsYXNzOiBcImxhenlsb2FkaW5nXCIsXG4gICAgICBwcmVsb2FkQ2xhc3M6IFwibGF6eXByZWxvYWRcIixcbiAgICAgIGVycm9yQ2xhc3M6IFwibGF6eWVycm9yXCIsXG4gICAgICAvL3N0cmljdENsYXNzOiAnbGF6eXN0cmljdCcsXG4gICAgICBhdXRvc2l6ZXNDbGFzczogXCJsYXp5YXV0b3NpemVzXCIsXG4gICAgICBzcmNBdHRyOiBcImRhdGEtc3JjXCIsXG4gICAgICBzcmNzZXRBdHRyOiBcImRhdGEtc3Jjc2V0XCIsXG4gICAgICBzaXplc0F0dHI6IFwiZGF0YS1zaXplc1wiLFxuICAgICAgLy9wcmVsb2FkQWZ0ZXJMb2FkOiBmYWxzZSxcbiAgICAgIG1pblNpemU6IDQwLFxuICAgICAgY3VzdG9tTWVkaWE6IHt9LFxuICAgICAgaW5pdDogdHJ1ZSxcbiAgICAgIGV4cEZhY3RvcjogMS41LFxuICAgICAgaEZhYzogMC44LFxuICAgICAgbG9hZE1vZGU6IDIsXG4gICAgICBsb2FkSGlkZGVuOiB0cnVlLFxuICAgICAgcmljVGltZW91dDogMzAwXG4gICAgfTtcblxuICAgIGxhenlTaXplc0NvbmZpZyA9IHdpbmRvdy5sYXp5U2l6ZXNDb25maWcgfHwgd2luZG93LmxhenlzaXplc0NvbmZpZyB8fCB7fTtcblxuICAgIGZvciAocHJvcCBpbiBsYXp5U2l6ZXNEZWZhdWx0cykge1xuICAgICAgaWYgKCEocHJvcCBpbiBsYXp5U2l6ZXNDb25maWcpKSB7XG4gICAgICAgIGxhenlTaXplc0NvbmZpZ1twcm9wXSA9IGxhenlTaXplc0RlZmF1bHRzW3Byb3BdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5sYXp5U2l6ZXNDb25maWcgPSBsYXp5U2l6ZXNDb25maWc7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGxhenlTaXplc0NvbmZpZy5pbml0KSB7XG4gICAgICAgIGluaXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoKTtcblxuICB2YXIgbG9hZGVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcmVsb2FkRWxlbXMsIGlzQ29tcGxldGVkLCByZXNldFByZWxvYWRpbmdUaW1lciwgbG9hZE1vZGUsIHN0YXJ0ZWQ7XG5cbiAgICB2YXIgZUx2VywgZWx2SCwgZUx0b3AsIGVMbGVmdCwgZUxyaWdodCwgZUxib3R0b207XG5cbiAgICB2YXIgZGVmYXVsdEV4cGFuZCwgcHJlbG9hZEV4cGFuZCwgaEZhYztcblxuICAgIHZhciByZWdJbWcgPSAvXmltZyQvaTtcbiAgICB2YXIgcmVnSWZyYW1lID0gL15pZnJhbWUkL2k7XG5cbiAgICB2YXIgc3VwcG9ydFNjcm9sbCA9XG4gICAgICBcIm9uc2Nyb2xsXCIgaW4gd2luZG93ICYmICEvZ2xlYm90Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4gICAgdmFyIHNocmlua0V4cGFuZCA9IDA7XG4gICAgdmFyIGN1cnJlbnRFeHBhbmQgPSAwO1xuXG4gICAgdmFyIGlzTG9hZGluZyA9IDA7XG4gICAgdmFyIGxvd1J1bnMgPSAtMTtcblxuICAgIHZhciByZXNldFByZWxvYWRpbmcgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpc0xvYWRpbmctLTtcbiAgICAgIGlmIChlICYmIGUudGFyZ2V0KSB7XG4gICAgICAgIGFkZFJlbW92ZUxvYWRFdmVudHMoZS50YXJnZXQsIHJlc2V0UHJlbG9hZGluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZSB8fCBpc0xvYWRpbmcgPCAwIHx8ICFlLnRhcmdldCkge1xuICAgICAgICBpc0xvYWRpbmcgPSAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaXNOZXN0ZWRWaXNpYmxlID0gZnVuY3Rpb24oZWxlbSwgZWxlbUV4cGFuZCkge1xuICAgICAgdmFyIG91dGVyUmVjdDtcbiAgICAgIHZhciBwYXJlbnQgPSBlbGVtO1xuICAgICAgdmFyIHZpc2libGUgPVxuICAgICAgICBnZXRDU1MoZG9jdW1lbnQuYm9keSwgXCJ2aXNpYmlsaXR5XCIpID09IFwiaGlkZGVuXCIgfHxcbiAgICAgICAgZ2V0Q1NTKGVsZW0sIFwidmlzaWJpbGl0eVwiKSAhPSBcImhpZGRlblwiO1xuXG4gICAgICBlTHRvcCAtPSBlbGVtRXhwYW5kO1xuICAgICAgZUxib3R0b20gKz0gZWxlbUV4cGFuZDtcbiAgICAgIGVMbGVmdCAtPSBlbGVtRXhwYW5kO1xuICAgICAgZUxyaWdodCArPSBlbGVtRXhwYW5kO1xuXG4gICAgICB3aGlsZSAoXG4gICAgICAgIHZpc2libGUgJiZcbiAgICAgICAgKHBhcmVudCA9IHBhcmVudC5vZmZzZXRQYXJlbnQpICYmXG4gICAgICAgIHBhcmVudCAhPSBkb2N1bWVudC5ib2R5ICYmXG4gICAgICAgIHBhcmVudCAhPSBkb2NFbGVtXG4gICAgICApIHtcbiAgICAgICAgdmlzaWJsZSA9IChnZXRDU1MocGFyZW50LCBcIm9wYWNpdHlcIikgfHwgMSkgPiAwO1xuXG4gICAgICAgIGlmICh2aXNpYmxlICYmIGdldENTUyhwYXJlbnQsIFwib3ZlcmZsb3dcIikgIT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgICBvdXRlclJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgdmlzaWJsZSA9XG4gICAgICAgICAgICBlTHJpZ2h0ID4gb3V0ZXJSZWN0LmxlZnQgJiZcbiAgICAgICAgICAgIGVMbGVmdCA8IG91dGVyUmVjdC5yaWdodCAmJlxuICAgICAgICAgICAgZUxib3R0b20gPiBvdXRlclJlY3QudG9wIC0gMSAmJlxuICAgICAgICAgICAgZUx0b3AgPCBvdXRlclJlY3QuYm90dG9tICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlTGxlbixcbiAgICAgICAgaSxcbiAgICAgICAgcmVjdCxcbiAgICAgICAgYXV0b0xvYWRFbGVtLFxuICAgICAgICBsb2FkZWRTb21ldGhpbmcsXG4gICAgICAgIGVsZW1FeHBhbmQsXG4gICAgICAgIGVsZW1OZWdhdGl2ZUV4cGFuZCxcbiAgICAgICAgZWxlbUV4cGFuZFZhbCxcbiAgICAgICAgYmVmb3JlRXhwYW5kVmFsO1xuXG4gICAgICB2YXIgbGF6eWxvYWRFbGVtcyA9IGxhenlzaXplcy5lbGVtZW50cztcblxuICAgICAgaWYgKFxuICAgICAgICAobG9hZE1vZGUgPSBsYXp5U2l6ZXNDb25maWcubG9hZE1vZGUpICYmXG4gICAgICAgIGlzTG9hZGluZyA8IDggJiZcbiAgICAgICAgKGVMbGVuID0gbGF6eWxvYWRFbGVtcy5sZW5ndGgpXG4gICAgICApIHtcbiAgICAgICAgaSA9IDA7XG5cbiAgICAgICAgbG93UnVucysrO1xuXG4gICAgICAgIGlmIChwcmVsb2FkRXhwYW5kID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIShcImV4cGFuZFwiIGluIGxhenlTaXplc0NvbmZpZykpIHtcbiAgICAgICAgICAgIGxhenlTaXplc0NvbmZpZy5leHBhbmQgPVxuICAgICAgICAgICAgICBkb2NFbGVtLmNsaWVudEhlaWdodCA+IDUwMCAmJiBkb2NFbGVtLmNsaWVudFdpZHRoID4gNTAwXG4gICAgICAgICAgICAgICAgPyA1MDBcbiAgICAgICAgICAgICAgICA6IDM3MDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0RXhwYW5kID0gbGF6eVNpemVzQ29uZmlnLmV4cGFuZDtcbiAgICAgICAgICBwcmVsb2FkRXhwYW5kID0gZGVmYXVsdEV4cGFuZCAqIGxhenlTaXplc0NvbmZpZy5leHBGYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VycmVudEV4cGFuZCA8IHByZWxvYWRFeHBhbmQgJiZcbiAgICAgICAgICBpc0xvYWRpbmcgPCAxICYmXG4gICAgICAgICAgbG93UnVucyA+IDIgJiZcbiAgICAgICAgICBsb2FkTW9kZSA+IDIgJiZcbiAgICAgICAgICAhZG9jdW1lbnQuaGlkZGVuXG4gICAgICAgICkge1xuICAgICAgICAgIGN1cnJlbnRFeHBhbmQgPSBwcmVsb2FkRXhwYW5kO1xuICAgICAgICAgIGxvd1J1bnMgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGxvYWRNb2RlID4gMSAmJiBsb3dSdW5zID4gMSAmJiBpc0xvYWRpbmcgPCA2KSB7XG4gICAgICAgICAgY3VycmVudEV4cGFuZCA9IGRlZmF1bHRFeHBhbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudEV4cGFuZCA9IHNocmlua0V4cGFuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBpIDwgZUxsZW47IGkrKykge1xuICAgICAgICAgIGlmICghbGF6eWxvYWRFbGVtc1tpXSB8fCBsYXp5bG9hZEVsZW1zW2ldLl9sYXp5UmFjZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzdXBwb3J0U2Nyb2xsKSB7XG4gICAgICAgICAgICB1bnZlaWxFbGVtZW50KGxhenlsb2FkRWxlbXNbaV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShlbGVtRXhwYW5kVmFsID0gbGF6eWxvYWRFbGVtc1tpXVtfZ2V0QXR0cmlidXRlXShcImRhdGEtZXhwYW5kXCIpKSB8fFxuICAgICAgICAgICAgIShlbGVtRXhwYW5kID0gZWxlbUV4cGFuZFZhbCAqIDEpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBlbGVtRXhwYW5kID0gY3VycmVudEV4cGFuZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmVmb3JlRXhwYW5kVmFsICE9PSBlbGVtRXhwYW5kKSB7XG4gICAgICAgICAgICBlTHZXID0gaW5uZXJXaWR0aCArIGVsZW1FeHBhbmQgKiBoRmFjO1xuICAgICAgICAgICAgZWx2SCA9IGlubmVySGVpZ2h0ICsgZWxlbUV4cGFuZDtcbiAgICAgICAgICAgIGVsZW1OZWdhdGl2ZUV4cGFuZCA9IGVsZW1FeHBhbmQgKiAtMTtcbiAgICAgICAgICAgIGJlZm9yZUV4cGFuZFZhbCA9IGVsZW1FeHBhbmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVjdCA9IGxhenlsb2FkRWxlbXNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoZUxib3R0b20gPSByZWN0LmJvdHRvbSkgPj0gZWxlbU5lZ2F0aXZlRXhwYW5kICYmXG4gICAgICAgICAgICAoZUx0b3AgPSByZWN0LnRvcCkgPD0gZWx2SCAmJlxuICAgICAgICAgICAgKGVMcmlnaHQgPSByZWN0LnJpZ2h0KSA+PSBlbGVtTmVnYXRpdmVFeHBhbmQgKiBoRmFjICYmXG4gICAgICAgICAgICAoZUxsZWZ0ID0gcmVjdC5sZWZ0KSA8PSBlTHZXICYmXG4gICAgICAgICAgICAoZUxib3R0b20gfHwgZUxyaWdodCB8fCBlTGxlZnQgfHwgZUx0b3ApICYmXG4gICAgICAgICAgICAobGF6eVNpemVzQ29uZmlnLmxvYWRIaWRkZW4gfHxcbiAgICAgICAgICAgICAgZ2V0Q1NTKGxhenlsb2FkRWxlbXNbaV0sIFwidmlzaWJpbGl0eVwiKSAhPSBcImhpZGRlblwiKSAmJlxuICAgICAgICAgICAgKChpc0NvbXBsZXRlZCAmJlxuICAgICAgICAgICAgICBpc0xvYWRpbmcgPCAzICYmXG4gICAgICAgICAgICAgICFlbGVtRXhwYW5kVmFsICYmXG4gICAgICAgICAgICAgIChsb2FkTW9kZSA8IDMgfHwgbG93UnVucyA8IDQpKSB8fFxuICAgICAgICAgICAgICBpc05lc3RlZFZpc2libGUobGF6eWxvYWRFbGVtc1tpXSwgZWxlbUV4cGFuZCkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB1bnZlaWxFbGVtZW50KGxhenlsb2FkRWxlbXNbaV0pO1xuICAgICAgICAgICAgbG9hZGVkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpc0xvYWRpbmcgPiA5KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAhbG9hZGVkU29tZXRoaW5nICYmXG4gICAgICAgICAgICBpc0NvbXBsZXRlZCAmJlxuICAgICAgICAgICAgIWF1dG9Mb2FkRWxlbSAmJlxuICAgICAgICAgICAgaXNMb2FkaW5nIDwgNCAmJlxuICAgICAgICAgICAgbG93UnVucyA8IDQgJiZcbiAgICAgICAgICAgIGxvYWRNb2RlID4gMiAmJlxuICAgICAgICAgICAgKHByZWxvYWRFbGVtc1swXSB8fCBsYXp5U2l6ZXNDb25maWcucHJlbG9hZEFmdGVyTG9hZCkgJiZcbiAgICAgICAgICAgIChwcmVsb2FkRWxlbXNbMF0gfHxcbiAgICAgICAgICAgICAgKCFlbGVtRXhwYW5kVmFsICYmXG4gICAgICAgICAgICAgICAgKGVMYm90dG9tIHx8XG4gICAgICAgICAgICAgICAgICBlTHJpZ2h0IHx8XG4gICAgICAgICAgICAgICAgICBlTGxlZnQgfHxcbiAgICAgICAgICAgICAgICAgIGVMdG9wIHx8XG4gICAgICAgICAgICAgICAgICBsYXp5bG9hZEVsZW1zW2ldW19nZXRBdHRyaWJ1dGVdKGxhenlTaXplc0NvbmZpZy5zaXplc0F0dHIpICE9XG4gICAgICAgICAgICAgICAgICAgIFwiYXV0b1wiKSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBhdXRvTG9hZEVsZW0gPSBwcmVsb2FkRWxlbXNbMF0gfHwgbGF6eWxvYWRFbGVtc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXV0b0xvYWRFbGVtICYmICFsb2FkZWRTb21ldGhpbmcpIHtcbiAgICAgICAgICB1bnZlaWxFbGVtZW50KGF1dG9Mb2FkRWxlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRocm90dGxlZENoZWNrRWxlbWVudHMgPSB0aHJvdHRsZShjaGVja0VsZW1lbnRzKTtcblxuICAgIHZhciBzd2l0Y2hMb2FkaW5nQ2xhc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICBhZGRDbGFzcyhlLnRhcmdldCwgbGF6eVNpemVzQ29uZmlnLmxvYWRlZENsYXNzKTtcbiAgICAgIHJlbW92ZUNsYXNzKGUudGFyZ2V0LCBsYXp5U2l6ZXNDb25maWcubG9hZGluZ0NsYXNzKTtcbiAgICAgIGFkZFJlbW92ZUxvYWRFdmVudHMoZS50YXJnZXQsIHJhZlN3aXRjaExvYWRpbmdDbGFzcyk7XG4gICAgICB0cmlnZ2VyRXZlbnQoZS50YXJnZXQsIFwibGF6eWxvYWRlZFwiKTtcbiAgICB9O1xuICAgIHZhciByYWZlZFN3aXRjaExvYWRpbmdDbGFzcyA9IHJBRkl0KHN3aXRjaExvYWRpbmdDbGFzcyk7XG4gICAgdmFyIHJhZlN3aXRjaExvYWRpbmdDbGFzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJhZmVkU3dpdGNoTG9hZGluZ0NsYXNzKHsgdGFyZ2V0OiBlLnRhcmdldCB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNoYW5nZUlmcmFtZVNyYyA9IGZ1bmN0aW9uKGVsZW0sIHNyYykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZWxlbS5jb250ZW50V2luZG93LmxvY2F0aW9uLnJlcGxhY2Uoc3JjKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZWxlbS5zcmMgPSBzcmM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBoYW5kbGVTb3VyY2VzID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICB2YXIgY3VzdG9tTWVkaWE7XG5cbiAgICAgIHZhciBzb3VyY2VTcmNzZXQgPSBzb3VyY2VbX2dldEF0dHJpYnV0ZV0obGF6eVNpemVzQ29uZmlnLnNyY3NldEF0dHIpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIChjdXN0b21NZWRpYSA9XG4gICAgICAgICAgbGF6eVNpemVzQ29uZmlnLmN1c3RvbU1lZGlhW1xuICAgICAgICAgICAgc291cmNlW19nZXRBdHRyaWJ1dGVdKFwiZGF0YS1tZWRpYVwiKSB8fFxuICAgICAgICAgICAgICBzb3VyY2VbX2dldEF0dHJpYnV0ZV0oXCJtZWRpYVwiKVxuICAgICAgICAgIF0pXG4gICAgICApIHtcbiAgICAgICAgc291cmNlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIGN1c3RvbU1lZGlhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZVNyY3NldCkge1xuICAgICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKFwic3Jjc2V0XCIsIHNvdXJjZVNyY3NldCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsYXp5VW52ZWlsID0gckFGSXQoZnVuY3Rpb24oZWxlbSwgZGV0YWlsLCBpc0F1dG8sIHNpemVzLCBpc0ltZykge1xuICAgICAgdmFyIHNyYywgc3Jjc2V0LCBwYXJlbnQsIGlzUGljdHVyZSwgZXZlbnQsIGZpcmVzTG9hZDtcblxuICAgICAgaWYgKFxuICAgICAgICAhKGV2ZW50ID0gdHJpZ2dlckV2ZW50KGVsZW0sIFwibGF6eWJlZm9yZXVudmVpbFwiLCBkZXRhaWwpKVxuICAgICAgICAgIC5kZWZhdWx0UHJldmVudGVkXG4gICAgICApIHtcbiAgICAgICAgaWYgKHNpemVzKSB7XG4gICAgICAgICAgaWYgKGlzQXV0bykge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbSwgbGF6eVNpemVzQ29uZmlnLmF1dG9zaXplc0NsYXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJzaXplc1wiLCBzaXplcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3Jjc2V0ID0gZWxlbVtfZ2V0QXR0cmlidXRlXShsYXp5U2l6ZXNDb25maWcuc3Jjc2V0QXR0cik7XG4gICAgICAgIHNyYyA9IGVsZW1bX2dldEF0dHJpYnV0ZV0obGF6eVNpemVzQ29uZmlnLnNyY0F0dHIpO1xuXG4gICAgICAgIGlmIChpc0ltZykge1xuICAgICAgICAgIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcbiAgICAgICAgICBpc1BpY3R1cmUgPSBwYXJlbnQgJiYgcmVnUGljdHVyZS50ZXN0KHBhcmVudC5ub2RlTmFtZSB8fCBcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpcmVzTG9hZCA9XG4gICAgICAgICAgZGV0YWlsLmZpcmVzTG9hZCB8fCAoXCJzcmNcIiBpbiBlbGVtICYmIChzcmNzZXQgfHwgc3JjIHx8IGlzUGljdHVyZSkpO1xuXG4gICAgICAgIGV2ZW50ID0geyB0YXJnZXQ6IGVsZW0gfTtcblxuICAgICAgICBpZiAoZmlyZXNMb2FkKSB7XG4gICAgICAgICAgYWRkUmVtb3ZlTG9hZEV2ZW50cyhlbGVtLCByZXNldFByZWxvYWRpbmcsIHRydWUpO1xuICAgICAgICAgIGNsZWFyVGltZW91dChyZXNldFByZWxvYWRpbmdUaW1lcik7XG4gICAgICAgICAgcmVzZXRQcmVsb2FkaW5nVGltZXIgPSBzZXRUaW1lb3V0KHJlc2V0UHJlbG9hZGluZywgMjUwMCk7XG5cbiAgICAgICAgICBhZGRDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcubG9hZGluZ0NsYXNzKTtcbiAgICAgICAgICBhZGRSZW1vdmVMb2FkRXZlbnRzKGVsZW0sIHJhZlN3aXRjaExvYWRpbmdDbGFzcywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQaWN0dXJlKSB7XG4gICAgICAgICAgZm9yRWFjaC5jYWxsKHBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNvdXJjZVwiKSwgaGFuZGxlU291cmNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3Jjc2V0KSB7XG4gICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJzcmNzZXRcIiwgc3Jjc2V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChzcmMgJiYgIWlzUGljdHVyZSkge1xuICAgICAgICAgIGlmIChyZWdJZnJhbWUudGVzdChlbGVtLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgY2hhbmdlSWZyYW1lU3JjKGVsZW0sIHNyYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0uc3JjID0gc3JjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ltZyAmJiAoc3Jjc2V0IHx8IGlzUGljdHVyZSkpIHtcbiAgICAgICAgICB1cGRhdGVQb2x5ZmlsbChlbGVtLCB7IHNyYzogc3JjIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtLl9sYXp5UmFjZSkge1xuICAgICAgICBkZWxldGUgZWxlbS5fbGF6eVJhY2U7XG4gICAgICB9XG4gICAgICByZW1vdmVDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcubGF6eUNsYXNzKTtcblxuICAgICAgckFGKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWZpcmVzTG9hZCB8fCAoZWxlbS5jb21wbGV0ZSAmJiBlbGVtLm5hdHVyYWxXaWR0aCA+IDEpKSB7XG4gICAgICAgICAgaWYgKGZpcmVzTG9hZCkge1xuICAgICAgICAgICAgcmVzZXRQcmVsb2FkaW5nKGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNMb2FkaW5nLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaExvYWRpbmdDbGFzcyhldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRydWUpO1xuICAgIH0pO1xuXG4gICAgdmFyIHVudmVpbEVsZW1lbnQgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgICB2YXIgZGV0YWlsO1xuXG4gICAgICB2YXIgaXNJbWcgPSByZWdJbWcudGVzdChlbGVtLm5vZGVOYW1lKTtcblxuICAgICAgLy9hbGxvdyB1c2luZyBzaXplcz1cImF1dG9cIiwgYnV0IGRvbid0IHVzZS4gaXQncyBpbnZhbGlkLiBVc2UgZGF0YS1zaXplcz1cImF1dG9cIiBvciBhIHZhbGlkIHZhbHVlIGZvciBzaXplcyBpbnN0ZWFkIChpLmUuOiBzaXplcz1cIjgwdndcIilcbiAgICAgIHZhciBzaXplcyA9XG4gICAgICAgIGlzSW1nICYmXG4gICAgICAgIChlbGVtW19nZXRBdHRyaWJ1dGVdKGxhenlTaXplc0NvbmZpZy5zaXplc0F0dHIpIHx8XG4gICAgICAgICAgZWxlbVtfZ2V0QXR0cmlidXRlXShcInNpemVzXCIpKTtcbiAgICAgIHZhciBpc0F1dG8gPSBzaXplcyA9PSBcImF1dG9cIjtcblxuICAgICAgaWYgKFxuICAgICAgICAoaXNBdXRvIHx8ICFpc0NvbXBsZXRlZCkgJiZcbiAgICAgICAgaXNJbWcgJiZcbiAgICAgICAgKGVsZW1bX2dldEF0dHJpYnV0ZV0oXCJzcmNcIikgfHwgZWxlbS5zcmNzZXQpICYmXG4gICAgICAgICFlbGVtLmNvbXBsZXRlICYmXG4gICAgICAgICFoYXNDbGFzcyhlbGVtLCBsYXp5U2l6ZXNDb25maWcuZXJyb3JDbGFzcykgJiZcbiAgICAgICAgaGFzQ2xhc3MoZWxlbSwgbGF6eVNpemVzQ29uZmlnLmxhenlDbGFzcylcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRldGFpbCA9IHRyaWdnZXJFdmVudChlbGVtLCBcImxhenl1bnZlaWxyZWFkXCIpLmRldGFpbDtcblxuICAgICAgaWYgKGlzQXV0bykge1xuICAgICAgICBhdXRvU2l6ZXIudXBkYXRlRWxlbShlbGVtLCB0cnVlLCBlbGVtLm9mZnNldFdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgZWxlbS5fbGF6eVJhY2UgPSB0cnVlO1xuICAgICAgaXNMb2FkaW5nKys7XG5cbiAgICAgIGxhenlVbnZlaWwoZWxlbSwgZGV0YWlsLCBpc0F1dG8sIHNpemVzLCBpc0ltZyk7XG4gICAgfTtcblxuICAgIHZhciBvbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChpc0NvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0ZWQgPCA5OTkpIHtcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWQsIDk5OSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhZnRlclNjcm9sbCA9IGRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICBsYXp5U2l6ZXNDb25maWcubG9hZE1vZGUgPSAzO1xuICAgICAgICB0aHJvdHRsZWRDaGVja0VsZW1lbnRzKCk7XG4gICAgICB9KTtcblxuICAgICAgaXNDb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICBsYXp5U2l6ZXNDb25maWcubG9hZE1vZGUgPSAzO1xuXG4gICAgICB0aHJvdHRsZWRDaGVja0VsZW1lbnRzKCk7XG5cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwic2Nyb2xsXCIsXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChsYXp5U2l6ZXNDb25maWcubG9hZE1vZGUgPT0gMykge1xuICAgICAgICAgICAgbGF6eVNpemVzQ29uZmlnLmxvYWRNb2RlID0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWZ0ZXJTY3JvbGwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIF86IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGFydGVkID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBsYXp5c2l6ZXMuZWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxuICAgICAgICAgIGxhenlTaXplc0NvbmZpZy5sYXp5Q2xhc3NcbiAgICAgICAgKTtcbiAgICAgICAgcHJlbG9hZEVsZW1zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcbiAgICAgICAgICBsYXp5U2l6ZXNDb25maWcubGF6eUNsYXNzICsgXCIgXCIgKyBsYXp5U2l6ZXNDb25maWcucHJlbG9hZENsYXNzXG4gICAgICAgICk7XG4gICAgICAgIGhGYWMgPSBsYXp5U2l6ZXNDb25maWcuaEZhYztcblxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRocm90dGxlZENoZWNrRWxlbWVudHMsIHRydWUpO1xuXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhyb3R0bGVkQ2hlY2tFbGVtZW50cykub2JzZXJ2ZShkb2NFbGVtLCB7XG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY0VsZW1bX2FkZEV2ZW50TGlzdGVuZXJdKFxuICAgICAgICAgICAgXCJET01Ob2RlSW5zZXJ0ZWRcIixcbiAgICAgICAgICAgIHRocm90dGxlZENoZWNrRWxlbWVudHMsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkb2NFbGVtW19hZGRFdmVudExpc3RlbmVyXShcbiAgICAgICAgICAgIFwiRE9NQXR0ck1vZGlmaWVkXCIsXG4gICAgICAgICAgICB0aHJvdHRsZWRDaGVja0VsZW1lbnRzLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0SW50ZXJ2YWwodGhyb3R0bGVkQ2hlY2tFbGVtZW50cywgOTk5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIHRocm90dGxlZENoZWNrRWxlbWVudHMsIHRydWUpO1xuXG4gICAgICAgIC8vLCAnZnVsbHNjcmVlbmNoYW5nZSdcbiAgICAgICAgW1xuICAgICAgICAgIFwiZm9jdXNcIixcbiAgICAgICAgICBcIm1vdXNlb3ZlclwiLFxuICAgICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgICBcImxvYWRcIixcbiAgICAgICAgICBcInRyYW5zaXRpb25lbmRcIixcbiAgICAgICAgICBcImFuaW1hdGlvbmVuZFwiLFxuICAgICAgICAgIFwid2Via2l0QW5pbWF0aW9uRW5kXCJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBkb2N1bWVudFtfYWRkRXZlbnRMaXN0ZW5lcl0obmFtZSwgdGhyb3R0bGVkQ2hlY2tFbGVtZW50cywgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgvZCR8XmMvLnRlc3QoZG9jdW1lbnQucmVhZHlTdGF0ZSkpIHtcbiAgICAgICAgICBvbmxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbmxvYWQpO1xuICAgICAgICAgIGRvY3VtZW50W19hZGRFdmVudExpc3RlbmVyXShcbiAgICAgICAgICAgIFwiRE9NQ29udGVudExvYWRlZFwiLFxuICAgICAgICAgICAgdGhyb3R0bGVkQ2hlY2tFbGVtZW50c1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2V0VGltZW91dChvbmxvYWQsIDIwMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXp5c2l6ZXMuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgY2hlY2tFbGVtZW50cygpO1xuICAgICAgICAgIHJBRi5fbHNGbHVzaCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm90dGxlZENoZWNrRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNoZWNrRWxlbXM6IHRocm90dGxlZENoZWNrRWxlbWVudHMsXG4gICAgICB1bnZlaWw6IHVudmVpbEVsZW1lbnRcbiAgICB9O1xuICB9KSgpO1xuXG4gIHZhciBhdXRvU2l6ZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGF1dG9zaXplc0VsZW1zO1xuXG4gICAgdmFyIHNpemVFbGVtZW50ID0gckFGSXQoZnVuY3Rpb24oZWxlbSwgcGFyZW50LCBldmVudCwgd2lkdGgpIHtcbiAgICAgIHZhciBzb3VyY2VzLCBpLCBsZW47XG4gICAgICBlbGVtLl9sYXp5c2l6ZXNXaWR0aCA9IHdpZHRoO1xuICAgICAgd2lkdGggKz0gXCJweFwiO1xuXG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZShcInNpemVzXCIsIHdpZHRoKTtcblxuICAgICAgaWYgKHJlZ1BpY3R1cmUudGVzdChwYXJlbnQubm9kZU5hbWUgfHwgXCJcIikpIHtcbiAgICAgICAgc291cmNlcyA9IHBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNvdXJjZVwiKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHNvdXJjZXNbaV0uc2V0QXR0cmlidXRlKFwic2l6ZXNcIiwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXZlbnQuZGV0YWlsLmRhdGFBdHRyKSB7XG4gICAgICAgIHVwZGF0ZVBvbHlmaWxsKGVsZW0sIGV2ZW50LmRldGFpbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGdldFNpemVFbGVtZW50ID0gZnVuY3Rpb24oZWxlbSwgZGF0YUF0dHIsIHdpZHRoKSB7XG4gICAgICB2YXIgZXZlbnQ7XG4gICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHdpZHRoID0gZ2V0V2lkdGgoZWxlbSwgcGFyZW50LCB3aWR0aCk7XG4gICAgICAgIGV2ZW50ID0gdHJpZ2dlckV2ZW50KGVsZW0sIFwibGF6eWJlZm9yZXNpemVzXCIsIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgZGF0YUF0dHI6ICEhZGF0YUF0dHJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgd2lkdGggPSBldmVudC5kZXRhaWwud2lkdGg7XG5cbiAgICAgICAgICBpZiAod2lkdGggJiYgd2lkdGggIT09IGVsZW0uX2xhenlzaXplc1dpZHRoKSB7XG4gICAgICAgICAgICBzaXplRWxlbWVudChlbGVtLCBwYXJlbnQsIGV2ZW50LCB3aWR0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVFbGVtZW50c1NpemVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBhdXRvc2l6ZXNFbGVtcy5sZW5ndGg7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBnZXRTaXplRWxlbWVudChhdXRvc2l6ZXNFbGVtc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRlYm91bmNlZFVwZGF0ZUVsZW1lbnRzU2l6ZXMgPSBkZWJvdW5jZSh1cGRhdGVFbGVtZW50c1NpemVzKTtcblxuICAgIHJldHVybiB7XG4gICAgICBfOiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXV0b3NpemVzRWxlbXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxuICAgICAgICAgIGxhenlTaXplc0NvbmZpZy5hdXRvc2l6ZXNDbGFzc1xuICAgICAgICApO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGRlYm91bmNlZFVwZGF0ZUVsZW1lbnRzU2l6ZXMpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrRWxlbXM6IGRlYm91bmNlZFVwZGF0ZUVsZW1lbnRzU2l6ZXMsXG4gICAgICB1cGRhdGVFbGVtOiBnZXRTaXplRWxlbWVudFxuICAgIH07XG4gIH0pKCk7XG5cbiAgdmFyIGluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWluaXQuaSkge1xuICAgICAgaW5pdC5pID0gdHJ1ZTtcbiAgICAgIGF1dG9TaXplci5fKCk7XG4gICAgICBsb2FkZXIuXygpO1xuICAgIH1cbiAgfTtcblxuICBsYXp5c2l6ZXMgPSB7XG4gICAgY2ZnOiBsYXp5U2l6ZXNDb25maWcsXG4gICAgYXV0b1NpemVyOiBhdXRvU2l6ZXIsXG4gICAgbG9hZGVyOiBsb2FkZXIsXG4gICAgaW5pdDogaW5pdCxcbiAgICB1UDogdXBkYXRlUG9seWZpbGwsXG4gICAgYUM6IGFkZENsYXNzLFxuICAgIHJDOiByZW1vdmVDbGFzcyxcbiAgICBoQzogaGFzQ2xhc3MsXG4gICAgZmlyZTogdHJpZ2dlckV2ZW50LFxuICAgIGdXOiBnZXRXaWR0aCxcbiAgICByQUY6IHJBRlxuICB9O1xuXG4gIHJldHVybiBsYXp5c2l6ZXM7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xhenlzaXplcy9sYXp5c2l6ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJyZXF1aXJlKFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eVwiKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZShcIi4uLy4uL21vZHVsZXMvX2NvcmVcIikuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciAkZXhwb3J0ID0gcmVxdWlyZShcIi4vX2V4cG9ydFwiKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKFwiLi9fZGVzY3JpcHRvcnNcIiksIFwiT2JqZWN0XCIsIHtcbiAgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoXCIuL19vYmplY3QtZHBcIikuZlxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKFwiLi9fYS1mdW5jdGlvblwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgICB9O1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgICAgfTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSBcImZ1bmN0aW9uXCIpIHRocm93IFR5cGVFcnJvcihpdCArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uIVwiKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBkUCA9IHJlcXVpcmUoXCIuL19vYmplY3QtZHBcIik7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoXCIuL19wcm9wZXJ0eS1kZXNjXCIpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9fZGVzY3JpcHRvcnNcIilcbiAgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfVxuICA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoXCIuL19pcy1vYmplY3RcIik7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKFwiLi9fZ2xvYmFsXCIpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoXCIuL19leHBvcnRcIik7XG52YXIgY29yZSA9IHJlcXVpcmUoXCIuL19jb3JlXCIpO1xudmFyIGZhaWxzID0gcmVxdWlyZShcIi4vX2ZhaWxzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoXG4gICAgJGV4cG9ydC5TICtcbiAgICAgICRleHBvcnQuRiAqXG4gICAgICAgIGZhaWxzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZuKDEpO1xuICAgICAgICB9KSxcbiAgICBcIk9iamVjdFwiLFxuICAgIGV4cFxuICApO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgcmV0dXJuIGlzTmFOKChpdCA9ICtpdCkpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSkge1xuICByZXR1cm4gXCJTeW1ib2woXCIuY29uY2F0KFxuICAgIGtleSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGtleSxcbiAgICBcIilfXCIsXG4gICAgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpXG4gICk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGpxdWVyeSBmcm9tICdqcXVlcnknO1xuaW1wb3J0IE1vZGVybml6ciBmcm9tICdtb2Rlcm5penInO1xuaW1wb3J0IGRlZGVudCBmcm9tICdkZWRlbnQnO1xuaW1wb3J0IHBpY3R1cmVmaWxsIGZyb20gJ3BpY3R1cmVmaWxsJztcbmltcG9ydCBXZWJGb250IGZyb20gJ3dlYmZvbnRsb2FkZXInO1xuaW1wb3J0IHJlc3BvbnNpdmVOYXYgZnJvbSAncmVzcG9uc2l2ZS1uYXYnO1xuaW1wb3J0IGxzQXNwZWN0cmF0aW8gZnJvbSAnbGF6eXNpemVzL3BsdWdpbnMvYXNwZWN0cmF0aW8vbHMuYXNwZWN0cmF0aW8nO1xuaW1wb3J0IGxzQmdzZXQgZnJvbSAnbGF6eXNpemVzL3BsdWdpbnMvYmdzZXQvbHMuYmdzZXQnO1xuaW1wb3J0IGxzVW52ZWlsaG9va3MgZnJvbSAnbGF6eXNpemVzL3BsdWdpbnMvdW52ZWlsaG9va3MvbHMudW52ZWlsaG9va3MnO1xuaW1wb3J0IGxhenlzaXplcyBmcm9tICdsYXp5c2l6ZXMnO1xuaW1wb3J0IGlzbW9iaWxlanMgZnJvbSAnaXNtb2JpbGVqcyc7XG5pbXBvcnQgYm93c2VyIGZyb20gJ2Jvd3Nlcic7XG5pbXBvcnQgKiBhcyBSIGZyb20gJ3JhbWJkYSc7XG5cbndpbmRvdy4kID0ganF1ZXJ5O1xud2luZG93LmpRdWVyeSA9IGpxdWVyeTtcbndpbmRvdy5SID0gUjtcbmdsb2JhbC5pc01vYmlsZSA9IGlzbW9iaWxlanM7XG5nbG9iYWwuYm93c2VyID0gYm93c2VyO1xuXG5yZXF1aXJlKCdqcXVlcnkuZWFzaW5nJyk7XG5yZXF1aXJlKCdqcXVlcnktc21vb3RoLXNjcm9sbCcpO1xucmVxdWlyZSgnanF1ZXJ5LmRvdGRvdGRvdCcpO1xucmVxdWlyZSgnanF1ZXJ5LW1hdGNoLWhlaWdodC1icm93c2VyaWZ5Jyk7XG5cbmNvbnN0IF9fc3ZnX18gPSB7XG4gIHBhdGg6ICcuLi8uLi8uLi9zcmMvYXNzZXRzL2ltYWdlcy9zdmcvcmF3LyoqLyouc3ZnJyxcbiAgbmFtZTogJy4uLy4uL2Fzc2V0cy9pbWFnZXMvc3ZnL3N5bWJvbC5zdmcnLFxufTtcbnJlcXVpcmUoJ3dlYnBhY2stc3Znc3RvcmUtcGx1Z2luL3NyYy9oZWxwZXJzL3N2Z3hocicpKF9fc3ZnX18pO1xuXG5jb25zdCBkZXRlY3QgPSB7XG4gIGRlc2t0b3A6ICFpc01vYmlsZS5hbnksXG4gIG1vYmlsZTogaXNNb2JpbGUuYW55LFxuICBwaG9uZTogaXNNb2JpbGUucGhvbmUsXG4gIHRhYmxldDogaXNNb2JpbGUudGFibGV0LFxuICBjaHJvbWU6IChib3dzZXIuY2hyb21lKSA/IGJvd3Nlci52ZXJzaW9uIDogZmFsc2UsXG4gIGZpcmVmb3g6IChib3dzZXIuZmlyZWZveCkgPyBib3dzZXIudmVyc2lvbiA6IGZhbHNlLFxuICBzYWZhcmk6IChib3dzZXIuc2FmYXJpKSA/IGJvd3Nlci52ZXJzaW9uIDogZmFsc2UsXG4gIG1zaWU6IChib3dzZXIubXNpZSkgPyBib3dzZXIudmVyc2lvbiA6IGZhbHNlLFxuICBtc2VkZ2U6IChib3dzZXIubXNlZGdlKSA/IGJvd3Nlci52ZXJzaW9uIDogZmFsc2UsXG4gIGlQaG9uZTogaXNNb2JpbGUuYXBwbGUucGhvbmUsXG4gIGFuZHJvaWRwaG9uZTogaXNNb2JpbGUuYW5kcm9pZC5waG9uZSxcbiAgaU9TOiBpc01vYmlsZS5hcHBsZS5kZXZpY2UsXG4gIGFuZHJvaWRPUzogaXNNb2JpbGUuYW5kcm9pZC5kZXZpY2UsXG59O1xuY29uc29sZS5sb2coZGV0ZWN0KTtcblxuaWYgKCFNb2Rlcm5penIub2JqZWN0Zml0KSB7XG4gIGNvbnNvbGUubG9nKCdub24tb2JqZWN0Zml0Jyk7XG59IGVsc2Uge1xuICBjb25zb2xlLmxvZygnb2JqZWN0Zml0Jyk7XG59XG5cbi8vIEZvciBkZWRlbnRcbmNvbnN0IHNlY3RzZWN0ID0gZGVkZW50YEEgc3RyaW5nIHRoYXQgZ2V0cyBzbyBsb25nIHlvdSBuZWVkIHRvIGJyZWFrIGl0IG92ZXJcbiAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlIGxpbmVzLiBMdWNraWx5IGRlZGVudCBpcyBoZXJlIHRvIGtlZXAgaXRcbiAgICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlIHdpdGhvdXQgbG90cyBvZiBzcGFjZXMgZW5kaW5nIHVwIGluIHRoZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgIGl0c2VsZi5gO1xuY29uc29sZS5sb2coc2VjdHNlY3QpO1xuXG4vLyBpZiAodHlwZW9mIHBpY3R1cmVmaWxsID09PSAnZnVuY3Rpb24nKSB7XG4vLyAgIGNvbnNvbGUubG9nKCdwaWN0dXJlISEhISEhISEnKTtcbi8vIH1cbi8vIGlmICh0eXBlb2YgV2ViRm9udCA9PT0gJ29iamVjdCcpIHtcbi8vICAgY29uc29sZS5sb2coJ1dlYkZvbnQhISEhISEhIScpO1xuLy8gfVxuLy8gaWYgKHR5cGVvZiByZXNwb25zaXZlTmF2ID09PSAnZnVuY3Rpb24nKSB7XG4vLyAgIGNvbnNvbGUubG9nKCdyZXNwb25zaXZlTmF2ISEhISEhISEnKTtcbi8vIH1cblxuJCgnYm9keScpLmFkZENsYXNzKCdzZWt0c2VrdCcpO1xuXG5jb25zdCBhcnkgPSBSLmFwcGVuZCgnZm9vJywgWydiYXInLCAnYmF6J10pO1xuY29uc29sZS5sb2coYXJ5KTtcblxuLyo9ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbkdvb2dsZSB3ZWItZm9udHNcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5XZWJGb250LmxvYWQoe1xuICBnb29nbGU6IHtcbiAgICBmYW1pbGllczogWydDcmltc29uK1RleHQ6OmxhdGluJywgJ0NpbnplbDo6bGF0aW4nLCAnSXRhbGlhbm5vOjpsYXRpbicsICdQaW55b24rU2NyaXB0OjpsYXRpbiddLFxuICB9LFxufSk7XG5cbmpRdWVyeSgoKSA9PiB7XG4gIC8qPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHN3aXRjaCB2aWV3cG9ydCBmb3IgdGFibGV0XG4gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gIGlmIChpc01vYmlsZS50YWJsZXQpIHtcbiAgICBqUXVlcnkoJyN2aWV3cG9ydCcpLmF0dHIoJ2NvbnRlbnQnLCAnd2lkdGg9MTAyNCcpO1xuICB9XG4gIC8qPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIERldGVjdCB0aGUgZGV2aWNlUGl4ZWxSYXRpb1xuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICBjb25zdCBoaURQSSA9ICEhKCgnZGV2aWNlUGl4ZWxSYXRpbycgaW4gd2luZG93ICYmIGRldmljZVBpeGVsUmF0aW8gPiAxKSk7XG4gIC8vIGNvbnNvbGUubG9nKGhpRFBJKTtcbiAgLyo9ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgUmVzcG9uc2libGUgbWVudSAocmVzcG9uc2l2ZS1uYXYubWluLmpzKVxuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICByZXNwb25zaXZlTmF2KCcjbmF2JywgeyAvLyBTZWxlY3RvclxuICAgIC8vXHRhbmltYXRlIFx0XHQ6IHRydWUsXHRcdFx0XHRcdFx0XHRcdCAgLy8gQm9vbGVhbjogVXNlIENTUzMgdHJhbnNpdGlvbnMsIHRydWUgb3IgZmFsc2VcbiAgICB0cmFuc2l0aW9uOiAxNTAsIC8vIEludGVnZXI6IFNwZWVkIG9mIHRoZSB0cmFuc2l0aW9uLCBpbiBtaWxsaXNlY29uZHNcbiAgICAvL1x0bGFiZWwgXHRcdFx0OiBcIjxzcGFuPk1lbnU8L3NwYW4+XCIsXHQvLyBTdHJpbmc6IExhYmVsIGZvciB0aGUgbmF2aWdhdGlvbiB0b2dnbGVcbiAgICBsYWJlbDogJzxzcGFuPmJhcjwvc3Bhbj48aT5NRU5VPC9pPicsIC8vIFN0cmluZzogTGFiZWwgZm9yIHRoZSBuYXZpZ2F0aW9uIHRvZ2dsZVxuICAgIC8vXHRpbnNlcnQgXHRcdFx0OiBcImJlZm9yZVwiLFx0XHRcdFx0XHRcdFx0Ly8gU3RyaW5nOiBJbnNlcnQgdGhlIHRvZ2dsZSBiZWZvcmUgb3IgYWZ0ZXIgdGhlIG5hdmlnYXRpb25cbiAgICAvL1x0Y3VzdG9tVG9nZ2xlIFx0OiBcIiNuYXYtdG9nZ2xlXCIsXHRcdFx0Ly8gU2VsZWN0b3I6IFNwZWNpZnkgdGhlIElEIG9mIGEgY3VzdG9tIHRvZ2dsZVxuICAgIC8vXHRjbG9zZU9uTmF2Q2xpY2tcdDogZmFsc2UsXHRcdFx0XHRcdFx0Ly8gQm9vbGVhbjogQ2xvc2UgdGhlIG5hdmlnYXRpb24gd2hlbiBvbmUgb2YgdGhlIGxpbmtzIGFyZSBjbGlja2VkXG4gICAgLy9cdG9wZW5Qb3NcdFx0XHQ6IFwic3RhdGljXCIsXHRcdFx0XHRcdFx0XHQvLyBTdHJpbmc6IFBvc2l0aW9uIG9mIHRoZSBvcGVuZWQgbmF2LCByZWxhdGl2ZSBvciBzdGF0aWNcbiAgICAvL1x0bmF2Q2xhc3NcdFx0OiBcIm5hdi1jb2xsYXBzZVwiLFx0XHRcdFx0Ly8gU3RyaW5nOiBEZWZhdWx0IENTUyBjbGFzcy4gSWYgY2hhbmdlZCwgeW91IG5lZWQgdG8gZWRpdCB0aGUgQ1NTIHRvbyFcbiAgICAvL1x0bmF2QWN0aXZlQ2xhc3NcdDogXCJqcy1uYXYtYWN0aXZlXCIsXHQvLyBTdHJpbmc6IENsYXNzIHRoYXQgaXMgYWRkZWQgdG8gZWxlbWVudCB3aGVuIG5hdiBpcyBhY3RpdmVcbiAgICAvL1x0anNDbGFzc1x0XHRcdDogXCJqc1wiLFx0XHRcdFx0XHRcdFx0XHQgIC8vIFN0cmluZzogJ0pTIGVuYWJsZWQnIGNsYXNzIHdoaWNoIGlzIGFkZGVkIHRvIGVsZW1lbnRcbiAgICBpbml0KCkge1xuICAgICAgalF1ZXJ5KCcjbmF2Jykuc2hvdygpO1xuICAgIH0sIC8vIEZ1bmN0aW9uOiBJbml0IGNhbGxiYWNrXG4gICAgLy9cdG9wZW5cdDogZnVuY3Rpb24oKSB7fSxcdFx0XHRcdFx0XHRcdC8vIEZ1bmN0aW9uOiBPcGVuIGNhbGxiYWNrXG4gICAgLy9cdGNsb3NlXHQ6IGZ1bmN0aW9uKCkge31cdFx0XHRcdFx0XHRcdFx0Ly8gRnVuY3Rpb246IENsb3NlIGNhbGxiYWNrXG4gIH0pO1xuICAvKj0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmYWRlaW4gL2ZhZGVvdXQgYnV0dG9uIFBhZ2V0b3BcbiAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgLyogaWYgKCFpc01vYmlsZS5waG9uZSkge1xuXHQgIGNvbnN0IHRvcEJ0biA9IGpRdWVyeSgnI3BhZ2V0b3AnKTtcblx0ICAvL1x044K544Kv44Ot44O844Or44GMMTAw44Gr6YGU44GX44Gf44KJ44Oc44K/44Oz6KGo56S6XG5cdCAgalF1ZXJ5KHdpbmRvdykuc2Nyb2xsKGZ1bmN0aW9uICgpIHtcblx0XHQgIGlmIChqUXVlcnkodGhpcykuc2Nyb2xsVG9wKCkgPiAxMDApIHtcblx0XHQgIHRvcEJ0bi5hZGRDbGFzcygnc2hvdycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9wQnRuLnJlbW92ZUNsYXNzKCdzaG93Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiovXG4gIC8qPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdEltYWdlIGZhZGVJbiAvIGZhZGVPdXRcblx0PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgLy8gLy8gd2UgdXNlIHRvdWNoc3RhcnQgYW5kIHRvdWNoZW5kIGV2ZW50cyBvbiBidXR0b25zXG4gIC8vIGxldCBlbnRlckV2ZW50ID0gJ3RvdWNoc3RhcnQnO1xuICAvLyBsZXQgbGVhdmVFdmVudCA9ICd0b3VjaGVuZCc7XG4gIC8vIC8vIHdlIHVzZSBtb3VzZWRvd24gYW5kIG1vdXNldXAgZXZlbnRzIG9uIGJpZyBpdGVtc1xuICAvLyBsZXQgZW50ZXJCaWdFdmVudCA9ICdtb3VzZWRvd24nO1xuICAvLyBsZXQgbGVhdmVCaWdFdmVudCA9ICdtb3VzZXVwJztcbiAgLy8gaWYgKCEoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSkge1xuICAvLyAgIGVudGVyRXZlbnQgPSAnbW91c2VlbnRlcic7XG4gIC8vICAgZW50ZXJCaWdFdmVudCA9ICdtb3VzZWVudGVyJztcbiAgLy8gICBsZWF2ZUV2ZW50ID0gJ21vdXNlbGVhdmUnO1xuICAvLyAgIGxlYXZlQmlnRXZlbnQgPSAnbW91c2VsZWF2ZSc7XG4gIC8vIH1cbiAgLy8galF1ZXJ5KCdtYWluIGEnKS5ub3QoJy5ob21lICNzZWNfcmVjb21tZW5kIC5ieHNsaWRlciBsaSBhJykub24oZW50ZXJFdmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgLy8gICBqUXVlcnkodGhpcykuZmluZCgnaW1nJykuYWRkQ2xhc3MoJ29uJyk7XG4gIC8vIH0pO1xuICAvLyBqUXVlcnkoJ21haW4gYScpLm5vdCgnLmhvbWUgI3NlY19yZWNvbW1lbmQgLmJ4c2xpZGVyIGxpIGEnKS5vbihsZWF2ZUV2ZW50LCBmdW5jdGlvbiAoZSkge1xuICAvLyAgIGpRdWVyeSh0aGlzKS5maW5kKCdpbWcnKS5yZW1vdmVDbGFzcygnb24nKTtcbiAgLy8gfSk7XG59KTtcblxualF1ZXJ5LmV2ZW50LmFkZCh3aW5kb3csICdsb2FkJywgKCkgPT4ge1xuICAvKj0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBcdFRleHQgVHJ1bmNhdGlvblxuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICBpZiAoalF1ZXJ5KCcudHJ1bmNhdGlvbicpLmxlbmd0aCkge1xuICAgIGpRdWVyeSgnLnRydW5jYXRpb24nKS5kb3Rkb3Rkb3Qoe1xuICAgICAgd2F0Y2g6ICd3aW5kb3cnLFxuICAgICAgdHJ1bmNhdGU6ICdsZXR0ZXInLFxuICAgICAgY2FsbGJhY2soaXNUcnVuY2F0ZWQpIHtcbiAgICAgICAgalF1ZXJ5KHRoaXMpLmFkZENsYXNzKCdyZWFkeScpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuICAvKj0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdHNtb290aCBzY3JvbGxcblx0PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgY29uc3QgaCA9IHBhcnNlSW50KGAtJHtqUXVlcnkoJyNoZWFkZXInKS5vdXRlckhlaWdodCh0cnVlKX1gLCAxMCk7XG4gIGpRdWVyeShcImFbaHJlZl49JyMnXVwiKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKGpRdWVyeSh0aGlzKS5wYXJlbnQoKS5oYXNDbGFzcygncGFnZVRvcCcpKSA/IDAgOiBoO1xuICAgIGNvbnN0IHRhcmdldCA9IGpRdWVyeSh0aGlzKS5hdHRyKCdocmVmJyk7XG4gICAgJC5zbW9vdGhTY3JvbGwoe1xuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1aW50JyxcbiAgICAgIHNwZWVkOiA4MDAsXG4gICAgICBvZmZzZXQsXG4gICAgICBzY3JvbGxUYXJnZXQ6IHRhcmdldCxcbiAgICB9KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICBjb25zdCBoZWFkZXJIID0galF1ZXJ5KCcjaGVhZGVyJykub3V0ZXJIZWlnaHQodHJ1ZSk7XG4gIC8vXHTlpJbpg6jjgYvjgonjg5rjg7zjgrjjg6rjg7Pjgq/jgafpo5vjgpPjgafjgY3jgZ/loLTlkIhcbiAgY29uc3QgdXJsID0galF1ZXJ5KHdpbmRvdy5sb2NhdGlvbikuYXR0cignaHJlZicpO1xuICBpZiAodXJsLmluZGV4T2YoJz9pZD0nKSA9PT0gLTEpIHtcbiAgICAvL1x0RG8gTm90aW5nXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdXJsc3AgPSB1cmwuc3BsaXQoJz9pZD0nKTtcbiAgICBjb25zdCBoYXNoID0gYCMke3VybHNwW3VybHNwLmxlbmd0aCAtIDFdfWA7XG4gICAgY29uc3QgdGd0ID0galF1ZXJ5KGhhc2gpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgcG9zID0gdGd0Lm9mZnNldCgpLnRvcCAtIGhlYWRlckg7IC8vXHRoZWFkZXJIIOOBp+OCquODleOCu+ODg+ODiOWIhuOCkuW8leOBj1xuICAgICAgalF1ZXJ5KCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XG4gICAgICAgIHNjcm9sbFRvcDogcG9zLFxuICAgICAgfSwgMTAwMCwgJ2Vhc2VPdXRRdWludCcpO1xuICAgIH0sIDMwMCk7XG4gIH1cbn0pO1xuXG5qUXVlcnkod2luZG93KS5vbignbG9hZCBvcmllbnRhdGlvbmNoYW5nZSByZXNpemUnLCAoKSA9PiB7XG4gIC8qPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0TGF6eWxvYWRcblx0PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cbiAgLy8gLy8gQ0FTRTogTGVzcyB0aGFuIEVxdWFsIFwiSUU4XCJcbiAgLy8gaWYgKHR5cGVvZiBMYXp5TG9hZCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgLy8gXHRuZXcgTGF6eUxvYWQoe1xuICAvLyBcdFx0ZGF0YV9zcmMgICAgICAgICAgOiBcInNyY1wiLFxuICAvLyBcdFx0ZGF0YV9zcmNzZXQgICAgICAgOiBcInNyY3NldFwiLFxuICAvLyBcdFx0dGhyZXNob2xkICAgICAgICAgOiAyMDAsXG4gIC8vIFx0XHRzaG93X3doaWxlX2xvYWRpbmc6IHRydWUsXG4gIC8vIFx0XHRwbGFjZWhvbGRlciAgICAgICA6IHRydWUsXG4gIC8vIFx0XHRjYWxsYmFja19zZXQgICAgICA6IGZ1bmN0aW9uKGltZykge1xuICAvLyBcdFx0XHRwaWN0dXJlZmlsbCh7XG4gIC8vIFx0XHRcdFx0ZWxlbWVudHMgIDogW2ltZ11cbiAgLy8gXHRcdFx0fSk7XG4gIC8vIFx0XHR9XG4gIC8vIFx0fSk7XG4gIC8vIH0gZWxzZSBpZiAodHlwZW9mIGxhenlTaXplcyA9PSBcIm9iamVjdFwiKSB7XG4gIC8vIFx0bGF6eVNpemVzLmluaXQoKTtcbiAgLy8gfVxuICAvKj0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHRcdFRyaW0gd29yZHNcdChTdXBwb3J0ZWQgTW9iaWxlLURldmljZSkgJiBTZXR0aW5nIHNhbWUgaGVpZ2h0IG9uIGNvbHVtblxuXHQ9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuICAvLyBpZiAoalF1ZXJ5KCcudHJpbV9saW5lMScpLmxlbmd0aCkge1xuICAvLyBcdGpRdWVyeSgnLnRyaW1fbGluZTEnKS50cnVuazgoe1xuICAvLyBcdFx0dG9vbHRpcDogZmFsc2VcbiAgLy8gXHR9KTtcbiAgLy8gfVxuICAvLyBpZiAoalF1ZXJ5KCcudHJpbV9saW5lMicpLmxlbmd0aCkge1xuICAvLyBcdGpRdWVyeSgnLnRyaW1fbGluZTInKS50cnVuazgoe1xuICAvLyBcdFx0dG9vbHRpcDogZmFsc2UsXG4gIC8vIFx0XHRsaW5lczogMlxuICAvLyBcdH0pO1xuICAvLyB9XG4gIC8vIGlmIChqUXVlcnkoJy50cmltX2xpbmUzJykubGVuZ3RoKSB7XG4gIC8vIFx0alF1ZXJ5KCcudHJpbV9saW5lMycpLnRydW5rOCh7XG4gIC8vIFx0XHR0b29sdGlwOiBmYWxzZSxcbiAgLy8gXHRcdGxpbmVzOiAzXG4gIC8vIFx0fSk7XG4gIC8vIH1cbiAgLy8gaWYgKGpRdWVyeSgnLnRyaW1fbGluZTQnKS5sZW5ndGgpIHtcbiAgLy8gXHRqUXVlcnkoJy50cmltX2xpbmU0JykudHJ1bms4KHtcbiAgLy8gXHRcdHRvb2x0aXA6IGZhbHNlLFxuICAvLyBcdFx0bGluZXM6IDRcbiAgLy8gXHR9KTtcbiAgLy8gfVxuICAvLyBpZiAoalF1ZXJ5KCcudHJpbV9saW5lNScpLmxlbmd0aCkge1xuICAvLyBcdGpRdWVyeSgnLnRyaW1fbGluZTUnKS50cnVuazgoe1xuICAvLyBcdFx0dG9vbHRpcDogZmFsc2UsXG4gIC8vIFx0XHRsaW5lczogNVxuICAvLyBcdH0pO1xuICAvLyB9XG4gIC8qPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdFx0bWF0Y2ggaGVpZ2h0IChqUXVlcnkubWF0Y2hoZWlnaHQuanMpXG5cdD09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG4gIGpRdWVyeSgnLm1oLWJ5cm93JykubWF0Y2hIZWlnaHQoKTtcbiAgalF1ZXJ5KCcubWgnKS5tYXRjaEhlaWdodCh7IGJ5Um93OiBmYWxzZSB9KTtcbiAgLy8g4pa8VVNBR0U6XHRDYXNlOiBtdWx0aXBsZVxuICAvLyA8dWw+XG4gIC8vIFx0PGxpIGRhdGEtbWg9XCJncm91cC0wMVwiIGNsYXNzPVwibWhcIj5NeSB0ZXh0PC9saT5cbiAgLy8gXHQ8bGkgZGF0YS1taD1cImdyb3VwLTAxXCIgY2xhc3M9XCJtaFwiPk15IHRleHQ8L2xpPlxuICAvLyA8L3VsPlxuICAvLyA8dWw+XG4gIC8vIFx0PGxpIGRhdGEtbWg9XCJncm91cC0wMlwiIGNsYXNzPVwibWhcIj5NeSB0ZXh0PC9saT5cbiAgLy8gXHQ8bGkgZGF0YS1taD1cImdyb3VwLTAyXCIgY2xhc3M9XCJtaFwiPk15IHRleHQ8L2xpPlxuICAvLyA8L3VsPlxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXNzZXRzL2pzL3NjcmlwdHMuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG4gIC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG4gIGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgLy8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKTtcblxudmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5ld09iaiA9IHt9O1xuXG4gICAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGRlc2MgPSBfT2JqZWN0JGRlZmluZVByb3BlcnR5ICYmIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307XG5cbiAgICAgICAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHtcbiAgICAgICAgICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgIHJldHVybiBuZXdPYmo7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmQuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICByZXR1cm4gJE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoXCIuL19jb2ZcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdChcInpcIikucHJvcGVydHlJc0VudW1lcmFibGUoMClcbiAgPyBPYmplY3RcbiAgOiBmdW5jdGlvbihpdCkge1xuICAgICAgcmV0dXJuIGNvZihpdCkgPT0gXCJTdHJpbmdcIiA/IGl0LnNwbGl0KFwiXCIpIDogT2JqZWN0KGl0KTtcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzXCIpO1xuXG52YXIgX09iamVjdCRmcmVlemUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZnJlZXplXCIpO1xuXG5mdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKHN0cmluZ3MsIHJhdykge1xuICByZXR1cm4gX09iamVjdCRmcmVlemUoX09iamVjdCRkZWZpbmVQcm9wZXJ0aWVzKHN0cmluZ3MsIHtcbiAgICByYXc6IHtcbiAgICAgIHZhbHVlOiBfT2JqZWN0JGZyZWV6ZShyYXcpXG4gICAgfVxuICB9KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydGllc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZShcIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllc1wiKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZShcIi4uLy4uL21vZHVsZXMvX2NvcmVcIikuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKFQsIEQpIHtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhULCBEKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoXCIuL19leHBvcnRcIik7XG4vLyAxOS4xLjIuMyAvIDE1LjIuMy43IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKFwiLi9fZGVzY3JpcHRvcnNcIiksIFwiT2JqZWN0XCIsIHtcbiAgZGVmaW5lUHJvcGVydGllczogcmVxdWlyZShcIi4vX29iamVjdC1kcHNcIilcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRQID0gcmVxdWlyZShcIi4vX29iamVjdC1kcFwiKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoXCIuL19hbi1vYmplY3RcIik7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoXCIuL19vYmplY3Qta2V5c1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9fZGVzY3JpcHRvcnNcIilcbiAgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICAgICAgYW5PYmplY3QoTyk7XG4gICAgICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gICAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgUDtcbiAgICAgIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIChQID0ga2V5c1tpKytdKSwgUHJvcGVydGllc1tQXSk7XG4gICAgICByZXR1cm4gTztcbiAgICB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZShcIi4vX29iamVjdC1rZXlzLWludGVybmFsXCIpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZShcIi4vX2VudW0tYnVnLWtleXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID1cbiAgT2JqZWN0LmtleXMgfHxcbiAgZnVuY3Rpb24ga2V5cyhPKSB7XG4gICAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbiAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGhhcyA9IHJlcXVpcmUoXCIuL19oYXNcIik7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZShcIi4vX3RvLWlvYmplY3RcIik7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZShcIi4vX2FycmF5LWluY2x1ZGVzXCIpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoXCIuL19zaGFyZWQta2V5XCIpKFwiSUVfUFJPVE9cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSlcbiAgICBpZiAoaGFzKE8sIChrZXkgPSBuYW1lc1tpKytdKSkpIHtcbiAgICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKFwiLi9fdG8taW9iamVjdFwiKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoXCIuL190by1sZW5ndGhcIik7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZShcIi4vX3RvLWFic29sdXRlLWluZGV4XCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbClcbiAgICAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKylcbiAgICAgICAgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICAgICAgfVxuICAgIHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKFwiLi9fdG8taW50ZWdlclwiKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZShcIi4vX3RvLWludGVnZXJcIik7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBzaGFyZWQgPSByZXF1aXJlKFwiLi9fc2hhcmVkXCIpKFwia2V5c1wiKTtcbnZhciB1aWQgPSByZXF1aXJlKFwiLi9fdWlkXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoXCIuL19nbG9iYWxcIik7XG52YXIgU0hBUkVEID0gXCJfX2NvcmUtanNfc2hhcmVkX19cIjtcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gXCJjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2ZcIi5zcGxpdChcbiAgXCIsXCJcbik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9mcmVlemVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvY29yZS1qcy9vYmplY3QvZnJlZXplLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKFwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL21vZHVsZXMvX2NvcmVcIikuT2JqZWN0LmZyZWV6ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZnJlZXplLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAxOS4xLjIuNSBPYmplY3QuZnJlZXplKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKFwiLi9faXMtb2JqZWN0XCIpO1xudmFyIG1ldGEgPSByZXF1aXJlKFwiLi9fbWV0YVwiKS5vbkZyZWV6ZTtcblxucmVxdWlyZShcIi4vX29iamVjdC1zYXBcIikoXCJmcmVlemVcIiwgZnVuY3Rpb24oJGZyZWV6ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KSB7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNRVRBID0gcmVxdWlyZShcIi4vX3VpZFwiKShcIm1ldGFcIik7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKFwiLi9faXMtb2JqZWN0XCIpO1xudmFyIGhhcyA9IHJlcXVpcmUoXCIuL19oYXNcIik7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoXCIuL19vYmplY3QtZHBcIikuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID1cbiAgT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fFxuICBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZShcIi4vX2ZhaWxzXCIpKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHtcbiAgICB2YWx1ZToge1xuICAgICAgaTogXCJPXCIgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICAgIHc6IHt9IC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gICAgfVxuICB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSlcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09IFwic3ltYm9sXCJcbiAgICAgID8gaXRcbiAgICAgIDogKHR5cGVvZiBpdCA9PSBcInN0cmluZ1wiID8gXCJTXCIgOiBcIlBcIikgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiBcIkZcIjtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gXCJFXCI7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH1cbiAgcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9XG4gIHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uKHdpbmRvdyl7XG52YXIgaGFkR2xvYmFsID0gJ01vZGVybml6cicgaW4gd2luZG93O1xudmFyIG9sZEdsb2JhbCA9IHdpbmRvdy5Nb2Rlcm5penI7XG4vKiEgbW9kZXJuaXpyIDMuNS4wIChDdXN0b20gQnVpbGQpIHwgTUlUICpcbiAqIGh0dHBzOi8vbW9kZXJuaXpyLmNvbS9kb3dubG9hZC8/LWZsZXhib3gtZmxleGJveHR3ZWVuZXItb2JqZWN0Zml0LXNldGNsYXNzZXMgISovXG4hZnVuY3Rpb24oZSxuLHQpe2Z1bmN0aW9uIHIoZSxuKXtyZXR1cm4gdHlwZW9mIGU9PT1ufWZ1bmN0aW9uIG8oKXt2YXIgZSxuLHQsbyxpLHMsbDtmb3IodmFyIGEgaW4gQylpZihDLmhhc093blByb3BlcnR5KGEpKXtpZihlPVtdLG49Q1thXSxuLm5hbWUmJihlLnB1c2gobi5uYW1lLnRvTG93ZXJDYXNlKCkpLG4ub3B0aW9ucyYmbi5vcHRpb25zLmFsaWFzZXMmJm4ub3B0aW9ucy5hbGlhc2VzLmxlbmd0aCkpZm9yKHQ9MDt0PG4ub3B0aW9ucy5hbGlhc2VzLmxlbmd0aDt0KyspZS5wdXNoKG4ub3B0aW9ucy5hbGlhc2VzW3RdLnRvTG93ZXJDYXNlKCkpO2ZvcihvPXIobi5mbixcImZ1bmN0aW9uXCIpP24uZm4oKTpuLmZuLGk9MDtpPGUubGVuZ3RoO2krKylzPWVbaV0sbD1zLnNwbGl0KFwiLlwiKSwxPT09bC5sZW5ndGg/TW9kZXJuaXpyW2xbMF1dPW86KCFNb2Rlcm5penJbbFswXV18fE1vZGVybml6cltsWzBdXWluc3RhbmNlb2YgQm9vbGVhbnx8KE1vZGVybml6cltsWzBdXT1uZXcgQm9vbGVhbihNb2Rlcm5penJbbFswXV0pKSxNb2Rlcm5penJbbFswXV1bbFsxXV09byksUy5wdXNoKChvP1wiXCI6XCJuby1cIikrbC5qb2luKFwiLVwiKSl9fWZ1bmN0aW9uIGkoZSl7dmFyIG49dy5jbGFzc05hbWUsdD1Nb2Rlcm5penIuX2NvbmZpZy5jbGFzc1ByZWZpeHx8XCJcIjtpZihfJiYobj1uLmJhc2VWYWwpLE1vZGVybml6ci5fY29uZmlnLmVuYWJsZUpTQ2xhc3Mpe3ZhciByPW5ldyBSZWdFeHAoXCIoXnxcXFxccylcIit0K1wibm8tanMoXFxcXHN8JClcIik7bj1uLnJlcGxhY2UocixcIiQxXCIrdCtcImpzJDJcIil9TW9kZXJuaXpyLl9jb25maWcuZW5hYmxlQ2xhc3NlcyYmKG4rPVwiIFwiK3QrZS5qb2luKFwiIFwiK3QpLF8/dy5jbGFzc05hbWUuYmFzZVZhbD1uOncuY2xhc3NOYW1lPW4pfWZ1bmN0aW9uIHMoZSxuKXtyZXR1cm4hIX4oXCJcIitlKS5pbmRleE9mKG4pfWZ1bmN0aW9uIGwoKXtyZXR1cm5cImZ1bmN0aW9uXCIhPXR5cGVvZiBuLmNyZWF0ZUVsZW1lbnQ/bi5jcmVhdGVFbGVtZW50KGFyZ3VtZW50c1swXSk6Xz9uLmNyZWF0ZUVsZW1lbnROUy5jYWxsKG4sXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLGFyZ3VtZW50c1swXSk6bi5jcmVhdGVFbGVtZW50LmFwcGx5KG4sYXJndW1lbnRzKX1mdW5jdGlvbiBhKCl7dmFyIGU9bi5ib2R5O3JldHVybiBlfHwoZT1sKF8/XCJzdmdcIjpcImJvZHlcIiksZS5mYWtlPSEwKSxlfWZ1bmN0aW9uIGYoZSx0LHIsbyl7dmFyIGkscyxmLHUscD1cIm1vZGVybml6clwiLGQ9bChcImRpdlwiKSxjPWEoKTtpZihwYXJzZUludChyLDEwKSlmb3IoO3ItLTspZj1sKFwiZGl2XCIpLGYuaWQ9bz9vW3JdOnArKHIrMSksZC5hcHBlbmRDaGlsZChmKTtyZXR1cm4gaT1sKFwic3R5bGVcIiksaS50eXBlPVwidGV4dC9jc3NcIixpLmlkPVwic1wiK3AsKGMuZmFrZT9jOmQpLmFwcGVuZENoaWxkKGkpLGMuYXBwZW5kQ2hpbGQoZCksaS5zdHlsZVNoZWV0P2kuc3R5bGVTaGVldC5jc3NUZXh0PWU6aS5hcHBlbmRDaGlsZChuLmNyZWF0ZVRleHROb2RlKGUpKSxkLmlkPXAsYy5mYWtlJiYoYy5zdHlsZS5iYWNrZ3JvdW5kPVwiXCIsYy5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLHU9dy5zdHlsZS5vdmVyZmxvdyx3LnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsdy5hcHBlbmRDaGlsZChjKSkscz10KGQsZSksYy5mYWtlPyhjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyksdy5zdHlsZS5vdmVyZmxvdz11LHcub2Zmc2V0SGVpZ2h0KTpkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCksISFzfWZ1bmN0aW9uIHUoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFtBLVpdKS9nLGZ1bmN0aW9uKGUsbil7cmV0dXJuXCItXCIrbi50b0xvd2VyQ2FzZSgpfSkucmVwbGFjZSgvXm1zLS8sXCItbXMtXCIpfWZ1bmN0aW9uIHAobix0LHIpe3ZhciBvO2lmKFwiZ2V0Q29tcHV0ZWRTdHlsZVwiaW4gZSl7bz1nZXRDb21wdXRlZFN0eWxlLmNhbGwoZSxuLHQpO3ZhciBpPWUuY29uc29sZTtpZihudWxsIT09bylyJiYobz1vLmdldFByb3BlcnR5VmFsdWUocikpO2Vsc2UgaWYoaSl7dmFyIHM9aS5lcnJvcj9cImVycm9yXCI6XCJsb2dcIjtpW3NdLmNhbGwoaSxcImdldENvbXB1dGVkU3R5bGUgcmV0dXJuaW5nIG51bGwsIGl0cyBwb3NzaWJsZSBtb2Rlcm5penIgdGVzdCByZXN1bHRzIGFyZSBpbmFjY3VyYXRlXCIpfX1lbHNlIG89IXQmJm4uY3VycmVudFN0eWxlJiZuLmN1cnJlbnRTdHlsZVtyXTtyZXR1cm4gb31mdW5jdGlvbiBkKG4scil7dmFyIG89bi5sZW5ndGg7aWYoXCJDU1NcImluIGUmJlwic3VwcG9ydHNcImluIGUuQ1NTKXtmb3IoO28tLTspaWYoZS5DU1Muc3VwcG9ydHModShuW29dKSxyKSlyZXR1cm4hMDtyZXR1cm4hMX1pZihcIkNTU1N1cHBvcnRzUnVsZVwiaW4gZSl7Zm9yKHZhciBpPVtdO28tLTspaS5wdXNoKFwiKFwiK3UobltvXSkrXCI6XCIrcitcIilcIik7cmV0dXJuIGk9aS5qb2luKFwiIG9yIFwiKSxmKFwiQHN1cHBvcnRzIChcIitpK1wiKSB7ICNtb2Rlcm5penIgeyBwb3NpdGlvbjogYWJzb2x1dGU7IH0gfVwiLGZ1bmN0aW9uKGUpe3JldHVyblwiYWJzb2x1dGVcIj09cChlLG51bGwsXCJwb3NpdGlvblwiKX0pfXJldHVybiB0fWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFthLXpdKS0oW2Etel0pL2csZnVuY3Rpb24oZSxuLHQpe3JldHVybiBuK3QudG9VcHBlckNhc2UoKX0pLnJlcGxhY2UoL14tLyxcIlwiKX1mdW5jdGlvbiBtKGUsbixvLGkpe2Z1bmN0aW9uIGEoKXt1JiYoZGVsZXRlIGouc3R5bGUsZGVsZXRlIGoubW9kRWxlbSl9aWYoaT1yKGksXCJ1bmRlZmluZWRcIik/ITE6aSwhcihvLFwidW5kZWZpbmVkXCIpKXt2YXIgZj1kKGUsbyk7aWYoIXIoZixcInVuZGVmaW5lZFwiKSlyZXR1cm4gZn1mb3IodmFyIHUscCxtLHYseSxnPVtcIm1vZGVybml6clwiLFwidHNwYW5cIixcInNhbXBcIl07IWouc3R5bGUmJmcubGVuZ3RoOyl1PSEwLGoubW9kRWxlbT1sKGcuc2hpZnQoKSksai5zdHlsZT1qLm1vZEVsZW0uc3R5bGU7Zm9yKG09ZS5sZW5ndGgscD0wO20+cDtwKyspaWYodj1lW3BdLHk9ai5zdHlsZVt2XSxzKHYsXCItXCIpJiYodj1jKHYpKSxqLnN0eWxlW3ZdIT09dCl7aWYoaXx8cihvLFwidW5kZWZpbmVkXCIpKXJldHVybiBhKCksXCJwZnhcIj09bj92OiEwO3RyeXtqLnN0eWxlW3ZdPW99Y2F0Y2goaCl7fWlmKGouc3R5bGVbdl0hPXkpcmV0dXJuIGEoKSxcInBmeFwiPT1uP3Y6ITB9cmV0dXJuIGEoKSwhMX1mdW5jdGlvbiB2KGUsbil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXBwbHkobixhcmd1bWVudHMpfX1mdW5jdGlvbiB5KGUsbix0KXt2YXIgbztmb3IodmFyIGkgaW4gZSlpZihlW2ldaW4gbilyZXR1cm4gdD09PSExP2VbaV06KG89bltlW2ldXSxyKG8sXCJmdW5jdGlvblwiKT92KG8sdHx8bik6byk7cmV0dXJuITF9ZnVuY3Rpb24gZyhlLG4sdCxvLGkpe3ZhciBzPWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxsPShlK1wiIFwiK0Uuam9pbihzK1wiIFwiKStzKS5zcGxpdChcIiBcIik7cmV0dXJuIHIobixcInN0cmluZ1wiKXx8cihuLFwidW5kZWZpbmVkXCIpP20obCxuLG8saSk6KGw9KGUrXCIgXCIrei5qb2luKHMrXCIgXCIpK3MpLnNwbGl0KFwiIFwiKSx5KGwsbix0KSl9ZnVuY3Rpb24gaChlLG4scil7cmV0dXJuIGcoZSx0LHQsbixyKX12YXIgQz1bXSx4PXtfdmVyc2lvbjpcIjMuNS4wXCIsX2NvbmZpZzp7Y2xhc3NQcmVmaXg6XCJcIixlbmFibGVDbGFzc2VzOiEwLGVuYWJsZUpTQ2xhc3M6ITAsdXNlUHJlZml4ZXM6ITB9LF9xOltdLG9uOmZ1bmN0aW9uKGUsbil7dmFyIHQ9dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bih0W2VdKX0sMCl9LGFkZFRlc3Q6ZnVuY3Rpb24oZSxuLHQpe0MucHVzaCh7bmFtZTplLGZuOm4sb3B0aW9uczp0fSl9LGFkZEFzeW5jVGVzdDpmdW5jdGlvbihlKXtDLnB1c2goe25hbWU6bnVsbCxmbjplfSl9fSxNb2Rlcm5penI9ZnVuY3Rpb24oKXt9O01vZGVybml6ci5wcm90b3R5cGU9eCxNb2Rlcm5penI9bmV3IE1vZGVybml6cjt2YXIgUz1bXSx3PW4uZG9jdW1lbnRFbGVtZW50LF89XCJzdmdcIj09PXcubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxiPVwiTW96IE8gbXMgV2Via2l0XCIsRT14Ll9jb25maWcudXNlUHJlZml4ZXM/Yi5zcGxpdChcIiBcIik6W107eC5fY3Nzb21QcmVmaXhlcz1FO3ZhciBQPXtlbGVtOmwoXCJtb2Rlcm5penJcIil9O01vZGVybml6ci5fcS5wdXNoKGZ1bmN0aW9uKCl7ZGVsZXRlIFAuZWxlbX0pO3ZhciBqPXtzdHlsZTpQLmVsZW0uc3R5bGV9O01vZGVybml6ci5fcS51bnNoaWZ0KGZ1bmN0aW9uKCl7ZGVsZXRlIGouc3R5bGV9KTt2YXIgej14Ll9jb25maWcudXNlUHJlZml4ZXM/Yi50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiIFwiKTpbXTt4Ll9kb21QcmVmaXhlcz16LHgudGVzdEFsbFByb3BzPWc7dmFyIFQ9ZnVuY3Rpb24obil7dmFyIHIsbz1wcmVmaXhlcy5sZW5ndGgsaT1lLkNTU1J1bGU7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGkpcmV0dXJuIHQ7aWYoIW4pcmV0dXJuITE7aWYobj1uLnJlcGxhY2UoL15ALyxcIlwiKSxyPW4ucmVwbGFjZSgvLS9nLFwiX1wiKS50b1VwcGVyQ2FzZSgpK1wiX1JVTEVcIixyIGluIGkpcmV0dXJuXCJAXCIrbjtmb3IodmFyIHM9MDtvPnM7cysrKXt2YXIgbD1wcmVmaXhlc1tzXSxhPWwudG9VcHBlckNhc2UoKStcIl9cIityO2lmKGEgaW4gaSlyZXR1cm5cIkAtXCIrbC50b0xvd2VyQ2FzZSgpK1wiLVwiK259cmV0dXJuITF9O3guYXRSdWxlPVQ7dmFyIE49eC5wcmVmaXhlZD1mdW5jdGlvbihlLG4sdCl7cmV0dXJuIDA9PT1lLmluZGV4T2YoXCJAXCIpP1QoZSk6KC0xIT1lLmluZGV4T2YoXCItXCIpJiYoZT1jKGUpKSxuP2coZSxuLHQpOmcoZSxcInBmeFwiKSl9O01vZGVybml6ci5hZGRUZXN0KFwib2JqZWN0Zml0XCIsISFOKFwib2JqZWN0Rml0XCIpLHthbGlhc2VzOltcIm9iamVjdC1maXRcIl19KSx4LnRlc3RBbGxQcm9wcz1oLE1vZGVybml6ci5hZGRUZXN0KFwiZmxleGJveFwiLGgoXCJmbGV4QmFzaXNcIixcIjFweFwiLCEwKSksTW9kZXJuaXpyLmFkZFRlc3QoXCJmbGV4Ym94dHdlZW5lclwiLGgoXCJmbGV4QWxpZ25cIixcImVuZFwiLCEwKSksbygpLGkoUyksZGVsZXRlIHguYWRkVGVzdCxkZWxldGUgeC5hZGRBc3luY1Rlc3Q7Zm9yKHZhciBBPTA7QTxNb2Rlcm5penIuX3EubGVuZ3RoO0ErKylNb2Rlcm5penIuX3FbQV0oKTtlLk1vZGVybml6cj1Nb2Rlcm5penJ9KHdpbmRvdyxkb2N1bWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5Nb2Rlcm5penI7XG5pZiAoaGFkR2xvYmFsKSB7IHdpbmRvdy5Nb2Rlcm5penIgPSBvbGRHbG9iYWw7IH1cbmVsc2UgeyBkZWxldGUgd2luZG93Lk1vZGVybml6cjsgfVxufSkod2luZG93KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLy5tb2Rlcm5penJyY1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGRlZGVudChzdHJpbmdzKSB7XG4gIHZhciByYXcgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2Ygc3RyaW5ncyA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIGRlZGVudCBjYW4gYmUgdXNlZCBhcyBhIHBsYWluIGZ1bmN0aW9uXG4gICAgcmF3ID0gW3N0cmluZ3NdO1xuICB9IGVsc2Uge1xuICAgIHJhdyA9IHN0cmluZ3MucmF3O1xuICB9XG5cbiAgLy8gZmlyc3QsIHBlcmZvcm0gaW50ZXJwb2xhdGlvblxuICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgKz0gcmF3W2ldXG4gICAgICAvLyBqb2luIGxpbmVzIHdoZW4gdGhlcmUgaXMgYSBzdXBwcmVzc2VkIG5ld2xpbmVcbiAgICAgIC5yZXBsYWNlKC9cXFxcXFxuWyBcXHRdKi9nLCBcIlwiKVxuICAgICAgLy8gaGFuZGxlIGVzY2FwZWQgYmFja3RpY2tzXG4gICAgICAucmVwbGFjZSgvXFxcXGAvZywgXCJgXCIpO1xuXG4gICAgaWYgKGkgPCAoYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gMCA6IGFyZ3VtZW50cy5sZW5ndGggLSAxKSkge1xuICAgICAgcmVzdWx0ICs9IGFyZ3VtZW50cy5sZW5ndGggPD0gaSArIDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaSArIDFdO1xuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyBzdHJpcCBpbmRlbnRhdGlvblxuICB2YXIgbGluZXMgPSByZXN1bHQuc3BsaXQoXCJcXG5cIik7XG4gIHZhciBtaW5kZW50ID0gbnVsbDtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihsKSB7XG4gICAgdmFyIG0gPSBsLm1hdGNoKC9eKFxccyspXFxTKy8pO1xuICAgIGlmIChtKSB7XG4gICAgICB2YXIgaW5kZW50ID0gbVsxXS5sZW5ndGg7XG4gICAgICBpZiAoIW1pbmRlbnQpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZmlyc3QgaW5kZW50ZWQgbGluZVxuICAgICAgICBtaW5kZW50ID0gaW5kZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluZGVudCA9IE1hdGgubWluKG1pbmRlbnQsIGluZGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAobWluZGVudCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdCA9IGxpbmVzXG4gICAgICAubWFwKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgcmV0dXJuIGxbMF0gPT09IFwiIFwiID8gbC5zbGljZShtaW5kZW50KSA6IGw7XG4gICAgICB9KVxuICAgICAgLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICAvLyBkZWRlbnQgZWF0cyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIHRvb1xuICByZXN1bHQgPSByZXN1bHQudHJpbSgpO1xuXG4gIC8vIGhhbmRsZSBlc2NhcGVkIG5ld2xpbmVzIGF0IHRoZSBlbmQgdG8gZW5zdXJlIHRoZXkgZG9uJ3QgZ2V0IHN0cmlwcGVkIHRvb1xuICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1xcXFxuL2csIFwiXFxuXCIpO1xufVxuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IGRlZGVudDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RlZGVudC9kaXN0L2RlZGVudC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohIHBpY3R1cmVmaWxsIC0gdjMuMC4yIC0gMjAxNi0wMi0xMlxuICogaHR0cHM6Ly9zY290dGplaGwuZ2l0aHViLmlvL3BpY3R1cmVmaWxsL1xuICogQ29weXJpZ2h0IChjKSAyMDE2IGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGplaGwvcGljdHVyZWZpbGwvYmxvYi9tYXN0ZXIvQXV0aG9ycy50eHQ7IExpY2Vuc2VkIE1JVFxuICovXG4vKiEgR2Vja28tUGljdHVyZSAtIHYxLjBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGplaGwvcGljdHVyZWZpbGwvdHJlZS8zLjAvc3JjL3BsdWdpbnMvZ2Vja28tcGljdHVyZVxuICogRmlyZWZveCdzIGVhcmx5IHBpY3R1cmUgaW1wbGVtZW50YXRpb24gKHByaW9yIHRvIEZGNDEpIGlzIHN0YXRpYyBhbmQgZG9lc1xuICogbm90IHJlYWN0IHRvIHZpZXdwb3J0IGNoYW5nZXMuIFRoaXMgdGlueSBtb2R1bGUgZml4ZXMgdGhpcy5cbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdykge1xuICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmIChcbiAgICB3aW5kb3cuSFRNTFBpY3R1cmVFbGVtZW50ICYmXG4gICAgKC9lY2tvLy50ZXN0KHVhKSAmJiB1YS5tYXRjaCgvcnZcXDooXFxkKykvKSAmJiBSZWdFeHAuJDEgPCA0NSlcbiAgKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwicmVzaXplXCIsXG4gICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aW1lcjtcblxuICAgICAgICB2YXIgZHVtbXlTcmMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuXG4gICAgICAgIHZhciBmaXhSZXNwaW1nID0gZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSwgc2l6ZXM7XG4gICAgICAgICAgdmFyIHBpY3R1cmUgPSBpbWcucGFyZW50Tm9kZTtcblxuICAgICAgICAgIGlmIChwaWN0dXJlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUElDVFVSRVwiKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBkdW1teVNyYy5jbG9uZU5vZGUoKTtcblxuICAgICAgICAgICAgcGljdHVyZS5pbnNlcnRCZWZvcmUoc291cmNlLCBwaWN0dXJlLmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHBpY3R1cmUucmVtb3ZlQ2hpbGQoc291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWltZy5fcGZMYXN0U2l6ZSB8fCBpbWcub2Zmc2V0V2lkdGggPiBpbWcuX3BmTGFzdFNpemUpIHtcbiAgICAgICAgICAgIGltZy5fcGZMYXN0U2l6ZSA9IGltZy5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHNpemVzID0gaW1nLnNpemVzO1xuICAgICAgICAgICAgaW1nLnNpemVzICs9IFwiLDEwMHZ3XCI7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpbWcuc2l6ZXMgPSBzaXplcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZmluZFBpY3R1cmVJbWdzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgdmFyIGltZ3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgXCJwaWN0dXJlID4gaW1nLCBpbWdbc3Jjc2V0XVtzaXplc11cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGltZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZpeFJlc3BpbWcoaW1nc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgb25SZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmaW5kUGljdHVyZUltZ3MsIDk5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1xID0gd2luZG93Lm1hdGNoTWVkaWEgJiYgbWF0Y2hNZWRpYShcIihvcmllbnRhdGlvbjogbGFuZHNjYXBlKVwiKTtcbiAgICAgICAgdmFyIGluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBvblJlc2l6ZSgpO1xuXG4gICAgICAgICAgaWYgKG1xICYmIG1xLmFkZExpc3RlbmVyKSB7XG4gICAgICAgICAgICBtcS5hZGRMaXN0ZW5lcihvblJlc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGR1bW15U3JjLnNyY3NldCA9XG4gICAgICAgICAgXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO1xuXG4gICAgICAgIGlmICgvXltjfGldfGQkLy50ZXN0KGRvY3VtZW50LnJlYWR5U3RhdGUgfHwgXCJcIikpIHtcbiAgICAgICAgICBpbml0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgaW5pdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb25SZXNpemU7XG4gICAgICB9KSgpXG4gICAgKTtcbiAgfVxufSkod2luZG93KTtcblxuLyohIFBpY3R1cmVmaWxsIC0gdjMuMC4yXG4gKiBodHRwOi8vc2NvdHRqZWhsLmdpdGh1Yi5pby9waWN0dXJlZmlsbFxuICogQ29weXJpZ2h0IChjKSAyMDE1IGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGplaGwvcGljdHVyZWZpbGwvYmxvYi9tYXN0ZXIvQXV0aG9ycy50eHQ7XG4gKiAgTGljZW5zZTogTUlUXG4gKi9cblxuKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICAvLyBFbmFibGUgc3RyaWN0IG1vZGVcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gSFRNTCBzaGltfHYgaXQgZm9yIG9sZCBJRSAoSUU5IHdpbGwgc3RpbGwgbmVlZCB0aGUgSFRNTCB2aWRlbyB0YWcgd29ya2Fyb3VuZClcbiAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBpY3R1cmVcIik7XG5cbiAgdmFyIHdhcm4sIGVtaW5weCwgYWx3YXlzQ2hlY2tXRGVzY3JpcHRvciwgZXZhbElkO1xuICAvLyBsb2NhbCBvYmplY3QgZm9yIG1ldGhvZCByZWZlcmVuY2VzIGFuZCB0ZXN0aW5nIGV4cG9zdXJlXG4gIHZhciBwZiA9IHt9O1xuICB2YXIgaXNTdXBwb3J0VGVzdFJlYWR5ID0gZmFsc2U7XG4gIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgdmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgdmFyIGdldEltZ0F0dHIgPSBpbWFnZS5nZXRBdHRyaWJ1dGU7XG4gIHZhciBzZXRJbWdBdHRyID0gaW1hZ2Uuc2V0QXR0cmlidXRlO1xuICB2YXIgcmVtb3ZlSW1nQXR0ciA9IGltYWdlLnJlbW92ZUF0dHJpYnV0ZTtcbiAgdmFyIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciB0eXBlcyA9IHt9O1xuICB2YXIgY2ZnID0ge1xuICAgIC8vcmVzb3VyY2Ugc2VsZWN0aW9uOlxuICAgIGFsZ29yaXRobTogXCJcIlxuICB9O1xuICB2YXIgc3JjQXR0ciA9IFwiZGF0YS1wZnNyY1wiO1xuICB2YXIgc3Jjc2V0QXR0ciA9IHNyY0F0dHIgKyBcInNldFwiO1xuICAvLyB1YSBzbmlmZmluZyBpcyBkb25lIGZvciB1bmRldGVjdGFibGUgaW1nIGxvYWRpbmcgZmVhdHVyZXMsXG4gIC8vIHRvIGRvIHNvbWUgbm9uIGNydWNpYWwgcGVyZiBvcHRpbWl6YXRpb25zXG4gIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIHZhciBzdXBwb3J0QWJvcnQgPVxuICAgIC9yaWRlbnQvLnRlc3QodWEpIHx8XG4gICAgKC9lY2tvLy50ZXN0KHVhKSAmJiB1YS5tYXRjaCgvcnZcXDooXFxkKykvKSAmJiBSZWdFeHAuJDEgPiAzNSk7XG4gIHZhciBjdXJTcmNQcm9wID0gXCJjdXJyZW50U3JjXCI7XG4gIHZhciByZWdXRGVzYyA9IC9cXHMrXFwrP1xcZCsoZVxcZCspP3cvO1xuICB2YXIgcmVnU2l6ZSA9IC8oXFwoW14pXStcXCkpP1xccyooLispLztcbiAgdmFyIHNldE9wdGlvbnMgPSB3aW5kb3cucGljdHVyZWZpbGxDRkc7XG4gIC8qKlxuICAgKiBTaG9ydGN1dCBwcm9wZXJ0eSBmb3IgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy9zcGVjcy9taXhlZGNvbnRlbnQvI3Jlc3RyaWN0cy1taXhlZC1jb250ZW50ICggZm9yIGVhc3kgb3ZlcnJpZGluZyBpbiB0ZXN0cyApXG4gICAqL1xuICAvLyBiYXNlU3R5bGUgYWxzbyB1c2VkIGJ5IGdldEVtVmFsdWUgKGkuZS46IHdpZHRoOiAxZW0gaXMgaW1wb3J0YW50KVxuICB2YXIgYmFzZVN0eWxlID1cbiAgICBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt2aXNpYmlsaXR5OmhpZGRlbjtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6MDtib3JkZXI6bm9uZTtmb250LXNpemU6MWVtO3dpZHRoOjFlbTtvdmVyZmxvdzpoaWRkZW47Y2xpcDpyZWN0KDBweCwgMHB4LCAwcHgsIDBweClcIjtcbiAgdmFyIGZzQ3NzID0gXCJmb250LXNpemU6MTAwJSFpbXBvcnRhbnQ7XCI7XG4gIHZhciBpc1Z3RGlydHkgPSB0cnVlO1xuXG4gIHZhciBjc3NDYWNoZSA9IHt9O1xuICB2YXIgc2l6ZUxlbmd0aENhY2hlID0ge307XG4gIHZhciBEUFIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgdmFyIHVuaXRzID0ge1xuICAgIHB4OiAxLFxuICAgIGluOiA5NlxuICB9O1xuICB2YXIgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gIC8qKlxuICAgKiBhbHJlYWR5UnVuIGZsYWcgdXNlZCBmb3Igc2V0T3B0aW9ucy4gaXMgaXQgdHJ1ZSBzZXRPcHRpb25zIHdpbGwgcmVldmFsdWF0ZVxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHZhciBhbHJlYWR5UnVuID0gZmFsc2U7XG5cbiAgLy8gUmV1c2FibGUsIG5vbi1cImdcIiBSZWdleGVzXG5cbiAgLy8gKERvbid0IHVzZSBcXHMsIHRvIGF2b2lkIG1hdGNoaW5nIG5vbi1icmVha2luZyBzcGFjZS4pXG4gIHZhciByZWdleExlYWRpbmdTcGFjZXMgPSAvXlsgXFx0XFxuXFxyXFx1MDAwY10rLyxcbiAgICByZWdleExlYWRpbmdDb21tYXNPclNwYWNlcyA9IC9eWywgXFx0XFxuXFxyXFx1MDAwY10rLyxcbiAgICByZWdleExlYWRpbmdOb3RTcGFjZXMgPSAvXlteIFxcdFxcblxcclxcdTAwMGNdKy8sXG4gICAgcmVnZXhUcmFpbGluZ0NvbW1hcyA9IC9bLF0rJC8sXG4gICAgcmVnZXhOb25OZWdhdGl2ZUludGVnZXIgPSAvXlxcZCskLyxcbiAgICAvLyAoIFBvc2l0aXZlIG9yIG5lZ2F0aXZlIG9yIHVuc2lnbmVkIGludGVnZXJzIG9yIGRlY2ltYWxzLCB3aXRob3V0IG9yIHdpdGhvdXQgZXhwb25lbnRzLlxuICAgIC8vIE11c3QgaW5jbHVkZSBhdCBsZWFzdCBvbmUgZGlnaXQuXG4gICAgLy8gQWNjb3JkaW5nIHRvIHNwZWMgdGVzdHMgYW55IGRlY2ltYWwgcG9pbnQgbXVzdCBiZSBmb2xsb3dlZCBieSBhIGRpZ2l0LlxuICAgIC8vIE5vIGxlYWRpbmcgcGx1cyBzaWduIGlzIGFsbG93ZWQuKVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjdmFsaWQtZmxvYXRpbmctcG9pbnQtbnVtYmVyXG4gICAgcmVnZXhGbG9hdGluZ1BvaW50ID0gL14tPyg/OlswLTldK3xbMC05XSpcXC5bMC05XSspKD86W2VFXVsrLV0/WzAtOV0rKT8kLztcblxuICB2YXIgb24gPSBmdW5jdGlvbihvYmosIGV2dCwgZm4sIGNhcHR1cmUpIHtcbiAgICBpZiAob2JqLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyKGV2dCwgZm4sIGNhcHR1cmUgfHwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAob2JqLmF0dGFjaEV2ZW50KSB7XG4gICAgICBvYmouYXR0YWNoRXZlbnQoXCJvblwiICsgZXZ0LCBmbik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBzaW1wbGUgbWVtb2l6ZSBmdW5jdGlvbjpcbiAgICovXG5cbiAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgaWYgKCEoaW5wdXQgaW4gY2FjaGUpKSB7XG4gICAgICAgIGNhY2hlW2lucHV0XSA9IGZuKGlucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZVtpbnB1dF07XG4gICAgfTtcbiAgfTtcblxuICAvLyBVVElMSVRZIEZVTkNUSU9OU1xuXG4gIC8vIE1hbnVhbCBpcyBmYXN0ZXIgdGhhbiBSZWdFeFxuICAvLyBodHRwOi8vanNwZXJmLmNvbS93aGl0ZXNwYWNlLWNoYXJhY3Rlci81XG4gIGZ1bmN0aW9uIGlzU3BhY2UoYykge1xuICAgIHJldHVybiAoXG4gICAgICBjID09PSBcIlxcdTAwMjBcIiB8fCAvLyBzcGFjZVxuICAgICAgYyA9PT0gXCJcXHUwMDA5XCIgfHwgLy8gaG9yaXpvbnRhbCB0YWJcbiAgICAgIGMgPT09IFwiXFx1MDAwQVwiIHx8IC8vIG5ldyBsaW5lXG4gICAgICBjID09PSBcIlxcdTAwMENcIiB8fCAvLyBmb3JtIGZlZWRcbiAgICAgIGMgPT09IFwiXFx1MDAwRFwiXG4gICAgKTsgLy8gY2FycmlhZ2UgcmV0dXJuXG4gIH1cblxuICAvKipcbiAgICogZ2V0cyBhIG1lZGlhcXVlcnkgYW5kIHJldHVybnMgYSBib29sZWFuIG9yIGdldHMgYSBjc3MgbGVuZ3RoIGFuZCByZXR1cm5zIGEgbnVtYmVyXG4gICAqIEBwYXJhbSBjc3MgbWVkaWFxdWVyaWVzIG9yIGNzcyBsZW5ndGhcbiAgICogQHJldHVybnMge2Jvb2xlYW58bnVtYmVyfVxuICAgKlxuICAgKiBiYXNlZCBvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vam9uYXRoYW50bmVhbC9kYjRmNzcwMDliMTU1ZjA4MzczOFxuICAgKi9cbiAgdmFyIGV2YWxDU1MgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlZ0xlbmd0aCA9IC9eKFtcXGRcXC5dKykoZW18dnd8cHgpJC87XG4gICAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgIHN0cmluZyA9IGFyZ3NbMF07XG4gICAgICB3aGlsZSAoKytpbmRleCBpbiBhcmdzKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGFyZ3NbaW5kZXhdLCBhcmdzWysraW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfTtcblxuICAgIHZhciBidWlsZFN0ciA9IG1lbW9pemUoZnVuY3Rpb24oY3NzKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcInJldHVybiBcIiArXG4gICAgICAgIHJlcGxhY2UoXG4gICAgICAgICAgKGNzcyB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIC8vIGludGVycHJldCBgYW5kYFxuICAgICAgICAgIC9cXGJhbmRcXGIvZyxcbiAgICAgICAgICBcIiYmXCIsXG5cbiAgICAgICAgICAvLyBpbnRlcnByZXQgYCxgXG4gICAgICAgICAgLywvZyxcbiAgICAgICAgICBcInx8XCIsXG5cbiAgICAgICAgICAvLyBpbnRlcnByZXQgYG1pbi1gIGFzID49XG4gICAgICAgICAgL21pbi0oW2Etei1cXHNdKyk6L2csXG4gICAgICAgICAgXCJlLiQxPj1cIixcblxuICAgICAgICAgIC8vIGludGVycHJldCBgbWF4LWAgYXMgPD1cbiAgICAgICAgICAvbWF4LShbYS16LVxcc10rKTovZyxcbiAgICAgICAgICBcImUuJDE8PVwiLFxuXG4gICAgICAgICAgLy9jYWxjIHZhbHVlXG4gICAgICAgICAgL2NhbGMoW14pXSspL2csXG4gICAgICAgICAgXCIoJDEpXCIsXG5cbiAgICAgICAgICAvLyBpbnRlcnByZXQgY3NzIHZhbHVlc1xuICAgICAgICAgIC8oXFxkK1tcXC5dKltcXGRdKikoW2Etel0rKS9nLFxuICAgICAgICAgIFwiKCQxICogZS4kMilcIixcbiAgICAgICAgICAvL21ha2UgZXZhbCBsZXNzIGV2aWxcbiAgICAgICAgICAvXig/IShlLlthLXpdfFswLTlcXC4mPXw+PFxcK1xcLVxcKlxcKFxcKVxcL10pKS4qL2dpLFxuICAgICAgICAgIFwiXCJcbiAgICAgICAgKSArXG4gICAgICAgIFwiO1wiXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNzcywgbGVuZ3RoKSB7XG4gICAgICB2YXIgcGFyc2VkTGVuZ3RoO1xuICAgICAgaWYgKCEoY3NzIGluIGNzc0NhY2hlKSkge1xuICAgICAgICBjc3NDYWNoZVtjc3NdID0gZmFsc2U7XG4gICAgICAgIGlmIChsZW5ndGggJiYgKHBhcnNlZExlbmd0aCA9IGNzcy5tYXRjaChyZWdMZW5ndGgpKSkge1xuICAgICAgICAgIGNzc0NhY2hlW2Nzc10gPSBwYXJzZWRMZW5ndGhbMV0gKiB1bml0c1twYXJzZWRMZW5ndGhbMl1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qanNoaW50IGV2aWw6dHJ1ZSAqL1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjc3NDYWNoZVtjc3NdID0gbmV3IEZ1bmN0aW9uKFwiZVwiLCBidWlsZFN0cihjc3MpKSh1bml0cyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAvKmpzaGludCBldmlsOmZhbHNlICovXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjc3NDYWNoZVtjc3NdO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgdmFyIHNldFJlc29sdXRpb24gPSBmdW5jdGlvbihjYW5kaWRhdGUsIHNpemVzYXR0cikge1xuICAgIGlmIChjYW5kaWRhdGUudykge1xuICAgICAgLy8gaCA9IG1lYW5zIGhlaWdodDogfHwgZGVzY3JpcHRvci50eXBlID09PSAnaCcgZG8gbm90IGhhbmRsZSB5ZXQuLi5cbiAgICAgIGNhbmRpZGF0ZS5jV2lkdGggPSBwZi5jYWxjTGlzdExlbmd0aChzaXplc2F0dHIgfHwgXCIxMDB2d1wiKTtcbiAgICAgIGNhbmRpZGF0ZS5yZXMgPSBjYW5kaWRhdGUudyAvIGNhbmRpZGF0ZS5jV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbmRpZGF0ZS5yZXMgPSBjYW5kaWRhdGUuZDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG9wdFxuICAgKi9cbiAgdmFyIHBpY3R1cmVmaWxsID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgaWYgKCFpc1N1cHBvcnRUZXN0UmVhZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMsIGksIHBsZW47XG5cbiAgICB2YXIgb3B0aW9ucyA9IG9wdCB8fCB7fTtcblxuICAgIGlmIChvcHRpb25zLmVsZW1lbnRzICYmIG9wdGlvbnMuZWxlbWVudHMubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIGlmIChvcHRpb25zLmVsZW1lbnRzLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiSU1HXCIpIHtcbiAgICAgICAgb3B0aW9ucy5lbGVtZW50cyA9IFtvcHRpb25zLmVsZW1lbnRzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuY29udGV4dCA9IG9wdGlvbnMuZWxlbWVudHM7XG4gICAgICAgIG9wdGlvbnMuZWxlbWVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnRzID1cbiAgICAgIG9wdGlvbnMuZWxlbWVudHMgfHxcbiAgICAgIHBmLnFzYShcbiAgICAgICAgb3B0aW9ucy5jb250ZXh0IHx8IGRvY3VtZW50LFxuICAgICAgICBvcHRpb25zLnJlZXZhbHVhdGUgfHwgb3B0aW9ucy5yZXNlbGVjdCA/IHBmLnNlbCA6IHBmLnNlbFNob3J0XG4gICAgICApO1xuXG4gICAgaWYgKChwbGVuID0gZWxlbWVudHMubGVuZ3RoKSkge1xuICAgICAgcGYuc2V0dXBSdW4ob3B0aW9ucyk7XG4gICAgICBhbHJlYWR5UnVuID0gdHJ1ZTtcblxuICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBlbGVtZW50c1xuICAgICAgZm9yIChpID0gMDsgaSA8IHBsZW47IGkrKykge1xuICAgICAgICBwZi5maWxsSW1nKGVsZW1lbnRzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcGYudGVhcmRvd25SdW4ob3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBvdXRwdXRzIGEgd2FybmluZyBmb3IgdGhlIGRldmVsb3BlclxuICAgKiBAcGFyYW0ge21lc3NhZ2V9XG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIHdhcm4gPVxuICAgIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUud2FyblxuICAgICAgPyBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICA6IG5vb3A7XG5cbiAgaWYgKCEoY3VyU3JjUHJvcCBpbiBpbWFnZSkpIHtcbiAgICBjdXJTcmNQcm9wID0gXCJzcmNcIjtcbiAgfVxuXG4gIC8vIEFkZCBzdXBwb3J0IGZvciBzdGFuZGFyZCBtaW1lIHR5cGVzLlxuICB0eXBlc1tcImltYWdlL2pwZWdcIl0gPSB0cnVlO1xuICB0eXBlc1tcImltYWdlL2dpZlwiXSA9IHRydWU7XG4gIHR5cGVzW1wiaW1hZ2UvcG5nXCJdID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBkZXRlY3RUeXBlU3VwcG9ydCh0eXBlLCB0eXBlVXJpKSB7XG4gICAgLy8gYmFzZWQgb24gTW9kZXJuaXpyJ3MgbG9zc2xlc3MgaW1nLXdlYnAgdGVzdFxuICAgIC8vIG5vdGU6IGFzeW5jaHJvbm91c1xuICAgIHZhciBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB0eXBlc1t0eXBlXSA9IGZhbHNlO1xuICAgICAgcGljdHVyZWZpbGwoKTtcbiAgICB9O1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdHlwZXNbdHlwZV0gPSBpbWFnZS53aWR0aCA9PT0gMTtcbiAgICAgIHBpY3R1cmVmaWxsKCk7XG4gICAgfTtcbiAgICBpbWFnZS5zcmMgPSB0eXBlVXJpO1xuICAgIHJldHVybiBcInBlbmRpbmdcIjtcbiAgfVxuXG4gIC8vIHRlc3Qgc3ZnIHN1cHBvcnRcbiAgdHlwZXNbXCJpbWFnZS9zdmcreG1sXCJdID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcbiAgICBcImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjSW1hZ2VcIixcbiAgICBcIjEuMVwiXG4gICk7XG5cbiAgLyoqXG4gICAqIHVwZGF0ZXMgdGhlIGludGVybmFsIHZXIHByb3BlcnR5IHdpdGggdGhlIGN1cnJlbnQgdmlld3BvcnQgd2lkdGggaW4gcHhcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZU1ldHJpY3MoKSB7XG4gICAgaXNWd0RpcnR5ID0gZmFsc2U7XG4gICAgRFBSID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgY3NzQ2FjaGUgPSB7fTtcbiAgICBzaXplTGVuZ3RoQ2FjaGUgPSB7fTtcblxuICAgIHBmLkRQUiA9IERQUiB8fCAxO1xuXG4gICAgdW5pdHMud2lkdGggPSBNYXRoLm1heCh3aW5kb3cuaW5uZXJXaWR0aCB8fCAwLCBkb2NFbGVtLmNsaWVudFdpZHRoKTtcbiAgICB1bml0cy5oZWlnaHQgPSBNYXRoLm1heCh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCwgZG9jRWxlbS5jbGllbnRIZWlnaHQpO1xuXG4gICAgdW5pdHMudncgPSB1bml0cy53aWR0aCAvIDEwMDtcbiAgICB1bml0cy52aCA9IHVuaXRzLmhlaWdodCAvIDEwMDtcblxuICAgIGV2YWxJZCA9IFt1bml0cy5oZWlnaHQsIHVuaXRzLndpZHRoLCBEUFJdLmpvaW4oXCItXCIpO1xuXG4gICAgdW5pdHMuZW0gPSBwZi5nZXRFbVZhbHVlKCk7XG4gICAgdW5pdHMucmVtID0gdW5pdHMuZW07XG4gIH1cblxuICBmdW5jdGlvbiBjaG9vc2VMb3dSZXMobG93ZXJWYWx1ZSwgaGlnaGVyVmFsdWUsIGRwclZhbHVlLCBpc0NhY2hlZCkge1xuICAgIHZhciBib251c0ZhY3RvciwgdG9vTXVjaCwgYm9udXMsIG1lYW5EZW5zaXR5O1xuXG4gICAgLy9leHBlcmltZW50YWxcbiAgICBpZiAoY2ZnLmFsZ29yaXRobSA9PT0gXCJzYXZlRGF0YVwiKSB7XG4gICAgICBpZiAobG93ZXJWYWx1ZSA+IDIuNykge1xuICAgICAgICBtZWFuRGVuc2l0eSA9IGRwclZhbHVlICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvb011Y2ggPSBoaWdoZXJWYWx1ZSAtIGRwclZhbHVlO1xuICAgICAgICBib251c0ZhY3RvciA9IE1hdGgucG93KGxvd2VyVmFsdWUgLSAwLjYsIDEuNSk7XG5cbiAgICAgICAgYm9udXMgPSB0b29NdWNoICogYm9udXNGYWN0b3I7XG5cbiAgICAgICAgaWYgKGlzQ2FjaGVkKSB7XG4gICAgICAgICAgYm9udXMgKz0gMC4xICogYm9udXNGYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBtZWFuRGVuc2l0eSA9IGxvd2VyVmFsdWUgKyBib251cztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWVhbkRlbnNpdHkgPVxuICAgICAgICBkcHJWYWx1ZSA+IDEgPyBNYXRoLnNxcnQobG93ZXJWYWx1ZSAqIGhpZ2hlclZhbHVlKSA6IGxvd2VyVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lYW5EZW5zaXR5ID4gZHByVmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseUJlc3RDYW5kaWRhdGUoaW1nKSB7XG4gICAgdmFyIHNyY1NldENhbmRpZGF0ZXM7XG4gICAgdmFyIG1hdGNoaW5nU2V0ID0gcGYuZ2V0U2V0KGltZyk7XG4gICAgdmFyIGV2YWx1YXRlZCA9IGZhbHNlO1xuICAgIGlmIChtYXRjaGluZ1NldCAhPT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgIGV2YWx1YXRlZCA9IGV2YWxJZDtcbiAgICAgIGlmIChtYXRjaGluZ1NldCkge1xuICAgICAgICBzcmNTZXRDYW5kaWRhdGVzID0gcGYuc2V0UmVzKG1hdGNoaW5nU2V0KTtcbiAgICAgICAgcGYuYXBwbHlTZXRDYW5kaWRhdGUoc3JjU2V0Q2FuZGlkYXRlcywgaW1nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW1nW3BmLm5zXS5ldmFsZWQgPSBldmFsdWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBhc2NlbmRpbmdTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYS5yZXMgLSBiLnJlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNyY1RvQ3VyKGltZywgc3JjLCBzZXQpIHtcbiAgICB2YXIgY2FuZGlkYXRlO1xuICAgIGlmICghc2V0ICYmIHNyYykge1xuICAgICAgc2V0ID0gaW1nW3BmLm5zXS5zZXRzO1xuICAgICAgc2V0ID0gc2V0ICYmIHNldFtzZXQubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgY2FuZGlkYXRlID0gZ2V0Q2FuZGlkYXRlRm9yU3JjKHNyYywgc2V0KTtcblxuICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgIHNyYyA9IHBmLm1ha2VVcmwoc3JjKTtcbiAgICAgIGltZ1twZi5uc10uY3VyU3JjID0gc3JjO1xuICAgICAgaW1nW3BmLm5zXS5jdXJDYW4gPSBjYW5kaWRhdGU7XG5cbiAgICAgIGlmICghY2FuZGlkYXRlLnJlcykge1xuICAgICAgICBzZXRSZXNvbHV0aW9uKGNhbmRpZGF0ZSwgY2FuZGlkYXRlLnNldC5zaXplcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW5kaWRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDYW5kaWRhdGVGb3JTcmMoc3JjLCBzZXQpIHtcbiAgICB2YXIgaSwgY2FuZGlkYXRlLCBjYW5kaWRhdGVzO1xuICAgIGlmIChzcmMgJiYgc2V0KSB7XG4gICAgICBjYW5kaWRhdGVzID0gcGYucGFyc2VTZXQoc2V0KTtcbiAgICAgIHNyYyA9IHBmLm1ha2VVcmwoc3JjKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzcmMgPT09IHBmLm1ha2VVcmwoY2FuZGlkYXRlc1tpXS51cmwpKSB7XG4gICAgICAgICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuZGlkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QWxsU291cmNlRWxlbWVudHMocGljdHVyZSwgY2FuZGlkYXRlcykge1xuICAgIHZhciBpLCBsZW4sIHNvdXJjZSwgc3Jjc2V0O1xuXG4gICAgLy8gU1BFQyBtaXNtYXRjaCBpbnRlbmRlZCBmb3Igc2l6ZSBhbmQgcGVyZjpcbiAgICAvLyBhY3R1YWxseSBvbmx5IHNvdXJjZSBlbGVtZW50cyBwcmVjZWRpbmcgdGhlIGltZyBzaG91bGQgYmUgdXNlZFxuICAgIC8vIGFsc28gbm90ZTogZG9uJ3QgdXNlIHFzYSBoZXJlLCBiZWNhdXNlIElFOCBzb21ldGltZXMgZG9lc24ndCBsaWtlIHNvdXJjZSBhcyB0aGUga2V5IHBhcnQgaW4gYSBzZWxlY3RvclxuICAgIHZhciBzb3VyY2VzID0gcGljdHVyZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNvdXJjZVwiKTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICBzb3VyY2VbcGYubnNdID0gdHJ1ZTtcbiAgICAgIHNyY3NldCA9IHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJzcmNzZXRcIik7XG5cbiAgICAgIC8vIGlmIHNvdXJjZSBkb2VzIG5vdCBoYXZlIGEgc3Jjc2V0IGF0dHJpYnV0ZSwgc2tpcFxuICAgICAgaWYgKHNyY3NldCkge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgIHNyY3NldDogc3Jjc2V0LFxuICAgICAgICAgIG1lZGlhOiBzb3VyY2UuZ2V0QXR0cmlidXRlKFwibWVkaWFcIiksXG4gICAgICAgICAgdHlwZTogc291cmNlLmdldEF0dHJpYnV0ZShcInR5cGVcIiksXG4gICAgICAgICAgc2l6ZXM6IHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJzaXplc1wiKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Jjc2V0IFBhcnNlclxuICAgKiBCeSBBbGV4IEJlbGwgfCAgTUlUIExpY2Vuc2VcbiAgICpcbiAgICogQHJldHVybnMgQXJyYXkgW3t1cmw6IF8sIGQ6IF8sIHc6IF8sIGg6Xywgc2V0Ol8oPz8/Pyl9LCAuLi5dXG4gICAqXG4gICAqIEJhc2VkIHN1cGVyIGR1cGVyIGNsb3NlbHkgb24gdGhlIHJlZmVyZW5jZSBhbGdvcml0aG0gYXQ6XG4gICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNwYXJzZS1hLXNyY3NldC1hdHRyaWJ1dGVcbiAgICovXG5cbiAgLy8gMS4gTGV0IGlucHV0IGJlIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhpcyBhbGdvcml0aG0uXG4gIC8vIChUTy1ETyA6IEV4cGxhaW4gd2hhdCBcInNldFwiIGFyZ3VtZW50IGlzIGhlcmUuIE1heWJlIGNob29zZSBhIG1vcmVcbiAgLy8gZGVzY3JpcHRpdmUgJiBtb3JlIHNlYXJjaGFibGUgbmFtZS4gIFNpbmNlIHBhc3NpbmcgdGhlIFwic2V0XCIgaW4gcmVhbGx5IGhhc1xuICAvLyBub3RoaW5nIHRvIGRvIHdpdGggcGFyc2luZyBwcm9wZXIsIEkgd291bGQgcHJlZmVyIHRoaXMgYXNzaWdubWVudCBldmVudHVhbGx5XG4gIC8vIGdvIGluIGFuIGV4dGVybmFsIGZuLilcbiAgZnVuY3Rpb24gcGFyc2VTcmNzZXQoaW5wdXQsIHNldCkge1xuICAgIGZ1bmN0aW9uIGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ0V4KSB7XG4gICAgICB2YXIgY2hhcnMsXG4gICAgICAgIG1hdGNoID0gcmVnRXguZXhlYyhpbnB1dC5zdWJzdHJpbmcocG9zKSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY2hhcnMgPSBtYXRjaFswXTtcbiAgICAgICAgcG9zICs9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNoYXJzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIHVybCxcbiAgICAgIGRlc2NyaXB0b3JzLFxuICAgICAgY3VycmVudERlc2NyaXB0b3IsXG4gICAgICBzdGF0ZSxcbiAgICAgIGMsXG4gICAgICAvLyAyLiBMZXQgcG9zaXRpb24gYmUgYSBwb2ludGVyIGludG8gaW5wdXQsIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgc3RhcnRcbiAgICAgIC8vICAgIG9mIHRoZSBzdHJpbmcuXG4gICAgICBwb3MgPSAwLFxuICAgICAgLy8gMy4gTGV0IGNhbmRpZGF0ZXMgYmUgYW4gaW5pdGlhbGx5IGVtcHR5IHNvdXJjZSBzZXQuXG4gICAgICBjYW5kaWRhdGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGRlc2NyaXB0b3IgcHJvcGVydGllcyB0byBhIGNhbmRpZGF0ZSwgcHVzaGVzIHRvIHRoZSBjYW5kaWRhdGVzIGFycmF5XG4gICAgICogQHJldHVybiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICAvLyAoRGVjbGFyZWQgb3V0c2lkZSBvZiB0aGUgd2hpbGUgbG9vcCBzbyB0aGF0IGl0J3Mgb25seSBjcmVhdGVkIG9uY2UuXG4gICAgLy8gKFRoaXMgZm4gaXMgZGVmaW5lZCBiZWZvcmUgaXQgaXMgdXNlZCwgaW4gb3JkZXIgdG8gcGFzcyBKU0hJTlQuXG4gICAgLy8gVW5mb3J0dW5hdGVseSB0aGlzIGJyZWFrcyB0aGUgc2VxdWVuY2luZyBvZiB0aGUgc3BlYyBjb21tZW50cy4gOi8gKVxuICAgIGZ1bmN0aW9uIHBhcnNlRGVzY3JpcHRvcnMoKSB7XG4gICAgICAvLyA5LiBEZXNjcmlwdG9yIHBhcnNlcjogTGV0IGVycm9yIGJlIG5vLlxuICAgICAgdmFyIHBFcnJvciA9IGZhbHNlLFxuICAgICAgICAvLyAxMC4gTGV0IHdpZHRoIGJlIGFic2VudC5cbiAgICAgICAgLy8gMTEuIExldCBkZW5zaXR5IGJlIGFic2VudC5cbiAgICAgICAgLy8gMTIuIExldCBmdXR1cmUtY29tcGF0LWggYmUgYWJzZW50LiAoV2UncmUgaW1wbGVtZW50aW5nIGl0IG5vdyBhcyBoKVxuICAgICAgICB3LFxuICAgICAgICBkLFxuICAgICAgICBoLFxuICAgICAgICBpLFxuICAgICAgICBjYW5kaWRhdGUgPSB7fSxcbiAgICAgICAgZGVzYyxcbiAgICAgICAgbGFzdENoYXIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbnRWYWwsXG4gICAgICAgIGZsb2F0VmFsO1xuXG4gICAgICAvLyAxMy4gRm9yIGVhY2ggZGVzY3JpcHRvciBpbiBkZXNjcmlwdG9ycywgcnVuIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc3RlcHNcbiAgICAgIC8vIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlc2MgPSBkZXNjcmlwdG9yc1tpXTtcblxuICAgICAgICBsYXN0Q2hhciA9IGRlc2NbZGVzYy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFsdWUgPSBkZXNjLnN1YnN0cmluZygwLCBkZXNjLmxlbmd0aCAtIDEpO1xuICAgICAgICBpbnRWYWwgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICBmbG9hdFZhbCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgICAgIC8vIElmIHRoZSBkZXNjcmlwdG9yIGNvbnNpc3RzIG9mIGEgdmFsaWQgbm9uLW5lZ2F0aXZlIGludGVnZXIgZm9sbG93ZWQgYnlcbiAgICAgICAgLy8gYSBVKzAwNzcgTEFUSU4gU01BTEwgTEVUVEVSIFcgY2hhcmFjdGVyXG4gICAgICAgIGlmIChyZWdleE5vbk5lZ2F0aXZlSW50ZWdlci50ZXN0KHZhbHVlKSAmJiBsYXN0Q2hhciA9PT0gXCJ3XCIpIHtcbiAgICAgICAgICAvLyBJZiB3aWR0aCBhbmQgZGVuc2l0eSBhcmUgbm90IGJvdGggYWJzZW50LCB0aGVuIGxldCBlcnJvciBiZSB5ZXMuXG4gICAgICAgICAgaWYgKHcgfHwgZCkge1xuICAgICAgICAgICAgcEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBcHBseSB0aGUgcnVsZXMgZm9yIHBhcnNpbmcgbm9uLW5lZ2F0aXZlIGludGVnZXJzIHRvIHRoZSBkZXNjcmlwdG9yLlxuICAgICAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgemVybywgbGV0IGVycm9yIGJlIHllcy5cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGxldCB3aWR0aCBiZSB0aGUgcmVzdWx0LlxuICAgICAgICAgIGlmIChpbnRWYWwgPT09IDApIHtcbiAgICAgICAgICAgIHBFcnJvciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHcgPSBpbnRWYWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIGRlc2NyaXB0b3IgY29uc2lzdHMgb2YgYSB2YWxpZCBmbG9hdGluZy1wb2ludCBudW1iZXIgZm9sbG93ZWQgYnlcbiAgICAgICAgICAvLyBhIFUrMDA3OCBMQVRJTiBTTUFMTCBMRVRURVIgWCBjaGFyYWN0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChyZWdleEZsb2F0aW5nUG9pbnQudGVzdCh2YWx1ZSkgJiYgbGFzdENoYXIgPT09IFwieFwiKSB7XG4gICAgICAgICAgLy8gSWYgd2lkdGgsIGRlbnNpdHkgYW5kIGZ1dHVyZS1jb21wYXQtaCBhcmUgbm90IGFsbCBhYnNlbnQsIHRoZW4gbGV0IGVycm9yXG4gICAgICAgICAgLy8gYmUgeWVzLlxuICAgICAgICAgIGlmICh3IHx8IGQgfHwgaCkge1xuICAgICAgICAgICAgcEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBcHBseSB0aGUgcnVsZXMgZm9yIHBhcnNpbmcgZmxvYXRpbmctcG9pbnQgbnVtYmVyIHZhbHVlcyB0byB0aGUgZGVzY3JpcHRvci5cbiAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIGxlc3MgdGhhbiB6ZXJvLCBsZXQgZXJyb3IgYmUgeWVzLiBPdGhlcndpc2UsIGxldCBkZW5zaXR5XG4gICAgICAgICAgLy8gYmUgdGhlIHJlc3VsdC5cbiAgICAgICAgICBpZiAoZmxvYXRWYWwgPCAwKSB7XG4gICAgICAgICAgICBwRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkID0gZmxvYXRWYWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIGRlc2NyaXB0b3IgY29uc2lzdHMgb2YgYSB2YWxpZCBub24tbmVnYXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieVxuICAgICAgICAgIC8vIGEgVSswMDY4IExBVElOIFNNQUxMIExFVFRFUiBIIGNoYXJhY3RlclxuICAgICAgICB9IGVsc2UgaWYgKHJlZ2V4Tm9uTmVnYXRpdmVJbnRlZ2VyLnRlc3QodmFsdWUpICYmIGxhc3RDaGFyID09PSBcImhcIikge1xuICAgICAgICAgIC8vIElmIGhlaWdodCBhbmQgZGVuc2l0eSBhcmUgbm90IGJvdGggYWJzZW50LCB0aGVuIGxldCBlcnJvciBiZSB5ZXMuXG4gICAgICAgICAgaWYgKGggfHwgZCkge1xuICAgICAgICAgICAgcEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBcHBseSB0aGUgcnVsZXMgZm9yIHBhcnNpbmcgbm9uLW5lZ2F0aXZlIGludGVnZXJzIHRvIHRoZSBkZXNjcmlwdG9yLlxuICAgICAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgemVybywgbGV0IGVycm9yIGJlIHllcy4gT3RoZXJ3aXNlLCBsZXQgZnV0dXJlLWNvbXBhdC1oXG4gICAgICAgICAgLy8gYmUgdGhlIHJlc3VsdC5cbiAgICAgICAgICBpZiAoaW50VmFsID09PSAwKSB7XG4gICAgICAgICAgICBwRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoID0gaW50VmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEFueXRoaW5nIGVsc2UsIExldCBlcnJvciBiZSB5ZXMuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyAoY2xvc2Ugc3RlcCAxMyBmb3IgbG9vcClcblxuICAgICAgLy8gMTUuIElmIGVycm9yIGlzIHN0aWxsIG5vLCB0aGVuIGFwcGVuZCBhIG5ldyBpbWFnZSBzb3VyY2UgdG8gY2FuZGlkYXRlcyB3aG9zZVxuICAgICAgLy8gVVJMIGlzIHVybCwgYXNzb2NpYXRlZCB3aXRoIGEgd2lkdGggd2lkdGggaWYgbm90IGFic2VudCBhbmQgYSBwaXhlbFxuICAgICAgLy8gZGVuc2l0eSBkZW5zaXR5IGlmIG5vdCBhYnNlbnQuIE90aGVyd2lzZSwgdGhlcmUgaXMgYSBwYXJzZSBlcnJvci5cbiAgICAgIGlmICghcEVycm9yKSB7XG4gICAgICAgIGNhbmRpZGF0ZS51cmwgPSB1cmw7XG5cbiAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICBjYW5kaWRhdGUudyA9IHc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICBjYW5kaWRhdGUuZCA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICBjYW5kaWRhdGUuaCA9IGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoICYmICFkICYmICF3KSB7XG4gICAgICAgICAgY2FuZGlkYXRlLmQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5kaWRhdGUuZCA9PT0gMSkge1xuICAgICAgICAgIHNldC5oYXMxeCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FuZGlkYXRlLnNldCA9IHNldDtcblxuICAgICAgICBjYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgIH1cbiAgICB9IC8vIChjbG9zZSBwYXJzZURlc2NyaXB0b3JzIGZuKVxuXG4gICAgLyoqXG4gICAgICogVG9rZW5pemVzIGRlc2NyaXB0b3IgcHJvcGVydGllcyBwcmlvciB0byBwYXJzaW5nXG4gICAgICogUmV0dXJucyB1bmRlZmluZWQuXG4gICAgICogKEFnYWluLCB0aGlzIGZuIGlzIGRlZmluZWQgYmVmb3JlIGl0IGlzIHVzZWQsIGluIG9yZGVyIHRvIHBhc3MgSlNISU5ULlxuICAgICAqIFVuZm9ydHVuYXRlbHkgdGhpcyBicmVha3MgdGhlIGxvZ2ljYWwgc2VxdWVuY2luZyBvZiB0aGUgc3BlYyBjb21tZW50cy4gOi8gKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRva2VuaXplKCkge1xuICAgICAgLy8gOC4xLiBEZXNjcmlwdG9yIHRva2VuaXNlcjogU2tpcCB3aGl0ZXNwYWNlXG4gICAgICBjb2xsZWN0Q2hhcmFjdGVycyhyZWdleExlYWRpbmdTcGFjZXMpO1xuXG4gICAgICAvLyA4LjIuIExldCBjdXJyZW50IGRlc2NyaXB0b3IgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgIGN1cnJlbnREZXNjcmlwdG9yID0gXCJcIjtcblxuICAgICAgLy8gOC4zLiBMZXQgc3RhdGUgYmUgaW4gZGVzY3JpcHRvci5cbiAgICAgIHN0YXRlID0gXCJpbiBkZXNjcmlwdG9yXCI7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIC8vIDguNC4gTGV0IGMgYmUgdGhlIGNoYXJhY3RlciBhdCBwb3NpdGlvbi5cbiAgICAgICAgYyA9IGlucHV0LmNoYXJBdChwb3MpO1xuXG4gICAgICAgIC8vICBEbyB0aGUgZm9sbG93aW5nIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2Ygc3RhdGUuXG4gICAgICAgIC8vICBGb3IgdGhlIHB1cnBvc2Ugb2YgdGhpcyBzdGVwLCBcIkVPRlwiIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgcmVwcmVzZW50aW5nXG4gICAgICAgIC8vICB0aGF0IHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dC5cblxuICAgICAgICAvLyBJbiBkZXNjcmlwdG9yXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gXCJpbiBkZXNjcmlwdG9yXCIpIHtcbiAgICAgICAgICAvLyBEbyB0aGUgZm9sbG93aW5nLCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGM6XG5cbiAgICAgICAgICAvLyBTcGFjZSBjaGFyYWN0ZXJcbiAgICAgICAgICAvLyBJZiBjdXJyZW50IGRlc2NyaXB0b3IgaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvXG4gICAgICAgICAgLy8gZGVzY3JpcHRvcnMgYW5kIGxldCBjdXJyZW50IGRlc2NyaXB0b3IgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAvLyBTZXQgc3RhdGUgdG8gYWZ0ZXIgZGVzY3JpcHRvci5cbiAgICAgICAgICBpZiAoaXNTcGFjZShjKSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICBjdXJyZW50RGVzY3JpcHRvciA9IFwiXCI7XG4gICAgICAgICAgICAgIHN0YXRlID0gXCJhZnRlciBkZXNjcmlwdG9yXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFUrMDAyQyBDT01NQSAoLClcbiAgICAgICAgICAgIC8vIEFkdmFuY2UgcG9zaXRpb24gdG8gdGhlIG5leHQgY2hhcmFjdGVyIGluIGlucHV0LiBJZiBjdXJyZW50IGRlc2NyaXB0b3JcbiAgICAgICAgICAgIC8vIGlzIG5vdCBlbXB0eSwgYXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0byBkZXNjcmlwdG9ycy4gSnVtcCB0byB0aGUgc3RlcFxuICAgICAgICAgICAgLy8gbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICBkZXNjcmlwdG9ycy5wdXNoKGN1cnJlbnREZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlRGVzY3JpcHRvcnMoKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy8gVSswMDI4IExFRlQgUEFSRU5USEVTSVMgKCgpXG4gICAgICAgICAgICAvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuIFNldCBzdGF0ZSB0byBpbiBwYXJlbnMuXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIlxcdTAwMjhcIikge1xuICAgICAgICAgICAgY3VycmVudERlc2NyaXB0b3IgPSBjdXJyZW50RGVzY3JpcHRvciArIGM7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiaW4gcGFyZW5zXCI7XG5cbiAgICAgICAgICAgIC8vIEVPRlxuICAgICAgICAgICAgLy8gSWYgY3VycmVudCBkZXNjcmlwdG9yIGlzIG5vdCBlbXB0eSwgYXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0b1xuICAgICAgICAgICAgLy8gZGVzY3JpcHRvcnMuIEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICBkZXNjcmlwdG9ycy5wdXNoKGN1cnJlbnREZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlRGVzY3JpcHRvcnMoKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy8gQW55dGhpbmcgZWxzZVxuICAgICAgICAgICAgLy8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50RGVzY3JpcHRvciA9IGN1cnJlbnREZXNjcmlwdG9yICsgYztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gKGVuZCBcImluIGRlc2NyaXB0b3JcIlxuXG4gICAgICAgICAgLy8gSW4gcGFyZW5zXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFwiaW4gcGFyZW5zXCIpIHtcbiAgICAgICAgICAvLyBVKzAwMjkgUklHSFQgUEFSRU5USEVTSVMgKCkpXG4gICAgICAgICAgLy8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLiBTZXQgc3RhdGUgdG8gaW4gZGVzY3JpcHRvci5cbiAgICAgICAgICBpZiAoYyA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgIGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuICAgICAgICAgICAgc3RhdGUgPSBcImluIGRlc2NyaXB0b3JcIjtcblxuICAgICAgICAgICAgLy8gRU9GXG4gICAgICAgICAgICAvLyBBcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvIGRlc2NyaXB0b3JzLiBKdW1wIHRvIHRoZSBzdGVwIGxhYmVsZWRcbiAgICAgICAgICAgIC8vIGRlc2NyaXB0b3IgcGFyc2VyLlxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCJcIikge1xuICAgICAgICAgICAgZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG4gICAgICAgICAgICBwYXJzZURlc2NyaXB0b3JzKCk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIEFueXRoaW5nIGVsc2VcbiAgICAgICAgICAgIC8vIEFwcGVuZCBjIHRvIGN1cnJlbnQgZGVzY3JpcHRvci5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudERlc2NyaXB0b3IgPSBjdXJyZW50RGVzY3JpcHRvciArIGM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWZ0ZXIgZGVzY3JpcHRvclxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBcImFmdGVyIGRlc2NyaXB0b3JcIikge1xuICAgICAgICAgIC8vIERvIHRoZSBmb2xsb3dpbmcsIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2YgYzpcbiAgICAgICAgICAvLyBTcGFjZSBjaGFyYWN0ZXI6IFN0YXkgaW4gdGhpcyBzdGF0ZS5cbiAgICAgICAgICBpZiAoaXNTcGFjZShjKSkge1xuICAgICAgICAgICAgLy8gRU9GOiBKdW1wIHRvIHRoZSBzdGVwIGxhYmVsZWQgZGVzY3JpcHRvciBwYXJzZXIuXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIlwiKSB7XG4gICAgICAgICAgICBwYXJzZURlc2NyaXB0b3JzKCk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIEFueXRoaW5nIGVsc2VcbiAgICAgICAgICAgIC8vIFNldCBzdGF0ZSB0byBpbiBkZXNjcmlwdG9yLiBTZXQgcG9zaXRpb24gdG8gdGhlIHByZXZpb3VzIGNoYXJhY3RlciBpbiBpbnB1dC5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBcImluIGRlc2NyaXB0b3JcIjtcbiAgICAgICAgICAgIHBvcyAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkdmFuY2UgcG9zaXRpb24gdG8gdGhlIG5leHQgY2hhcmFjdGVyIGluIGlucHV0LlxuICAgICAgICBwb3MgKz0gMTtcblxuICAgICAgICAvLyBSZXBlYXQgdGhpcyBzdGVwLlxuICAgICAgfSAvLyAoY2xvc2Ugd2hpbGUgdHJ1ZSBsb29wKVxuICAgIH1cblxuICAgIC8vIDQuIFNwbGl0dGluZyBsb29wOiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBzcGFjZVxuICAgIC8vICAgIGNoYXJhY3RlcnMgb3IgVSswMDJDIENPTU1BIGNoYXJhY3RlcnMuIElmIGFueSBVKzAwMkMgQ09NTUEgY2hhcmFjdGVyc1xuICAgIC8vICAgIHdlcmUgY29sbGVjdGVkLCB0aGF0IGlzIGEgcGFyc2UgZXJyb3IuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ2V4TGVhZGluZ0NvbW1hc09yU3BhY2VzKTtcblxuICAgICAgLy8gNS4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCByZXR1cm4gY2FuZGlkYXRlcyBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXG4gICAgICBpZiAocG9zID49IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVzOyAvLyAod2UncmUgZG9uZSwgdGhpcyBpcyB0aGUgc29sZSByZXR1cm4gcGF0aClcbiAgICAgIH1cblxuICAgICAgLy8gNi4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IHNwYWNlIGNoYXJhY3RlcnMsXG4gICAgICAvLyAgICBhbmQgbGV0IHRoYXQgYmUgdXJsLlxuICAgICAgdXJsID0gY29sbGVjdENoYXJhY3RlcnMocmVnZXhMZWFkaW5nTm90U3BhY2VzKTtcblxuICAgICAgLy8gNy4gTGV0IGRlc2NyaXB0b3JzIGJlIGEgbmV3IGVtcHR5IGxpc3QuXG4gICAgICBkZXNjcmlwdG9ycyA9IFtdO1xuXG4gICAgICAvLyA4LiBJZiB1cmwgZW5kcyB3aXRoIGEgVSswMDJDIENPTU1BIGNoYXJhY3RlciAoLCksIGZvbGxvdyB0aGVzZSBzdWJzdGVwczpcbiAgICAgIC8vXHRcdCgxKS4gUmVtb3ZlIGFsbCB0cmFpbGluZyBVKzAwMkMgQ09NTUEgY2hhcmFjdGVycyBmcm9tIHVybC4gSWYgdGhpcyByZW1vdmVkXG4gICAgICAvLyAgICAgICAgIG1vcmUgdGhhbiBvbmUgY2hhcmFjdGVyLCB0aGF0IGlzIGEgcGFyc2UgZXJyb3IuXG4gICAgICBpZiAodXJsLnNsaWNlKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UocmVnZXhUcmFpbGluZ0NvbW1hcywgXCJcIik7XG4gICAgICAgIC8vIChKdW1wIGFoZWFkIHRvIHN0ZXAgOSB0byBza2lwIHRva2VuaXphdGlvbiBhbmQganVzdCBwdXNoIHRoZSBjYW5kaWRhdGUpLlxuICAgICAgICBwYXJzZURlc2NyaXB0b3JzKCk7XG5cbiAgICAgICAgLy9cdE90aGVyd2lzZSwgZm9sbG93IHRoZXNlIHN1YnN0ZXBzOlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5pemUoKTtcbiAgICAgIH0gLy8gKGNsb3NlIGVsc2Ugb2Ygc3RlcCA4KVxuXG4gICAgICAvLyAxNi4gUmV0dXJuIHRvIHRoZSBzdGVwIGxhYmVsZWQgc3BsaXR0aW5nIGxvb3AuXG4gICAgfSAvLyAoQ2xvc2Ugb2YgYmlnIHdoaWxlIGxvb3AuKVxuICB9XG5cbiAgLypcblx0ICogU2l6ZXMgUGFyc2VyXG5cdCAqXG5cdCAqIEJ5IEFsZXggQmVsbCB8ICBNSVQgTGljZW5zZVxuXHQgKlxuXHQgKiBOb24tc3RyaWN0IGJ1dCBhY2N1cmF0ZSBhbmQgbGlnaHR3ZWlnaHQgSlMgUGFyc2VyIGZvciB0aGUgc3RyaW5nIHZhbHVlIDxpbWcgc2l6ZXM9XCJoZXJlXCI+XG5cdCAqXG5cdCAqIFJlZmVyZW5jZSBhbGdvcml0aG0gYXQ6XG5cdCAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNwYXJzZS1hLXNpemVzLWF0dHJpYnV0ZVxuXHQgKlxuXHQgKiBNb3N0IGNvbW1lbnRzIGFyZSBjb3BpZWQgaW4gZGlyZWN0bHkgZnJvbSB0aGUgc3BlY1xuXHQgKiAoZXhjZXB0IGZvciBjb21tZW50cyBpbiBwYXJlbnMpLlxuXHQgKlxuXHQgKiBHcmFtbWFyIGlzOlxuXHQgKiA8c291cmNlLXNpemUtbGlzdD4gPSA8c291cmNlLXNpemU+IyBbICwgPHNvdXJjZS1zaXplLXZhbHVlPiBdPyB8IDxzb3VyY2Utc2l6ZS12YWx1ZT5cblx0ICogPHNvdXJjZS1zaXplPiA9IDxtZWRpYS1jb25kaXRpb24+IDxzb3VyY2Utc2l6ZS12YWx1ZT5cblx0ICogPHNvdXJjZS1zaXplLXZhbHVlPiA9IDxsZW5ndGg+XG5cdCAqIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdHRyLWltZy1zaXplc1xuXHQgKlxuXHQgKiBFLmcuIFwiKG1heC13aWR0aDogMzBlbSkgMTAwdncsIChtYXgtd2lkdGg6IDUwZW0pIDcwdncsIDEwMHZ3XCJcblx0ICogb3IgXCIobWluLXdpZHRoOiAzMGVtKSwgY2FsYygzMHZ3IC0gMTVweClcIiBvciBqdXN0IFwiMzB2d1wiXG5cdCAqXG5cdCAqIFJldHVybnMgdGhlIGZpcnN0IHZhbGlkIDxjc3MtbGVuZ3RoPiB3aXRoIGEgbWVkaWEgY29uZGl0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIHRydWUsXG5cdCAqIG9yIFwiMTAwdndcIiBpZiBhbGwgdmFsaWQgbWVkaWEgY29uZGl0aW9ucyBldmFsdWF0ZSB0byBmYWxzZS5cblx0ICpcblx0ICovXG5cbiAgZnVuY3Rpb24gcGFyc2VTaXplcyhzdHJWYWx1ZSkge1xuICAgIC8vIChQZXJjZW50YWdlIENTUyBsZW5ndGhzIGFyZSBub3QgYWxsb3dlZCBpbiB0aGlzIGNhc2UsIHRvIGF2b2lkIGNvbmZ1c2lvbjpcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdmFsaWQtc291cmNlLXNpemUtbGlzdFxuICAgIC8vIENTUyBhbGxvd3MgYSBzaW5nbGUgb3B0aW9uYWwgcGx1cyBvciBtaW51cyBzaWduOlxuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvc3luZGF0YS5odG1sI251bWJlcnNcbiAgICAvLyBDU1MgaXMgQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZTpcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyL3N5bmRhdGEuaHRtbCNjaGFyYWN0ZXJzIClcbiAgICAvLyBTcGVjIGFsbG93cyBleHBvbmVudGlhbCBub3RhdGlvbiBmb3IgPG51bWJlcj4gdHlwZTpcbiAgICAvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtdmFsdWVzLyNudW1iZXJzXG4gICAgdmFyIHJlZ2V4Q3NzTGVuZ3RoV2l0aFVuaXRzID0gL14oPzpbKy1dP1swLTldK3xbMC05XSpcXC5bMC05XSspKD86W2VFXVsrLV0/WzAtOV0rKT8oPzpjaHxjbXxlbXxleHxpbnxtbXxwY3xwdHxweHxyZW18dmh8dm1pbnx2bWF4fHZ3KSQvaTtcblxuICAgIC8vIChUaGlzIGlzIGEgcXVpY2sgYW5kIGxlbmllbnQgdGVzdC4gQmVjYXVzZSBvZiBvcHRpb25hbCB1bmxpbWl0ZWQtZGVwdGggaW50ZXJuYWxcbiAgICAvLyBncm91cGluZyBwYXJlbnMgYW5kIHN0cmljdCBzcGFjaW5nIHJ1bGVzLCB0aGlzIGNvdWxkIGdldCB2ZXJ5IGNvbXBsaWNhdGVkLilcbiAgICB2YXIgcmVnZXhDc3NDYWxjID0gL15jYWxjXFwoKD86WzAtOWEteiBcXC5cXCtcXC1cXCpcXC9cXChcXCldKylcXCkkL2k7XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgdW5wYXJzZWRTaXplc0xpc3Q7XG4gICAgdmFyIHVucGFyc2VkU2l6ZXNMaXN0TGVuZ3RoO1xuICAgIHZhciB1bnBhcnNlZFNpemU7XG4gICAgdmFyIGxhc3RDb21wb25lbnRWYWx1ZTtcbiAgICB2YXIgc2l6ZTtcblxuICAgIC8vIFVUSUxJVFkgRlVOQ1RJT05TXG5cbiAgICAvLyAgKFRveSBDU1MgcGFyc2VyLiBUaGUgZ29hbHMgaGVyZSBhcmU6XG4gICAgLy8gIDEpIGV4cGFuc2l2ZSB0ZXN0IGNvdmVyYWdlIHdpdGhvdXQgdGhlIHdlaWdodCBvZiBhIGZ1bGwgQ1NTIHBhcnNlci5cbiAgICAvLyAgMikgQXZvaWRpbmcgcmVnZXggd2hlcmV2ZXIgY29udmVuaWVudC5cbiAgICAvLyAgUXVpY2sgdGVzdHM6IGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZ3RudEw0Z3IvMy9cbiAgICAvLyAgUmV0dXJucyBhbiBhcnJheSBvZiBhcnJheXMuKVxuICAgIGZ1bmN0aW9uIHBhcnNlQ29tcG9uZW50VmFsdWVzKHN0cikge1xuICAgICAgdmFyIGNocmN0cjtcbiAgICAgIHZhciBjb21wb25lbnQgPSBcIlwiO1xuICAgICAgdmFyIGNvbXBvbmVudEFycmF5ID0gW107XG4gICAgICB2YXIgbGlzdEFycmF5ID0gW107XG4gICAgICB2YXIgcGFyZW5EZXB0aCA9IDA7XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHZhciBpbkNvbW1lbnQgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gcHVzaENvbXBvbmVudCgpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgIGNvbXBvbmVudEFycmF5LnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICBjb21wb25lbnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHB1c2hDb21wb25lbnRBcnJheSgpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudEFycmF5WzBdKSB7XG4gICAgICAgICAgbGlzdEFycmF5LnB1c2goY29tcG9uZW50QXJyYXkpO1xuICAgICAgICAgIGNvbXBvbmVudEFycmF5ID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gKExvb3AgZm9yd2FyZHMgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcuKVxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY2hyY3RyID0gc3RyLmNoYXJBdChwb3MpO1xuXG4gICAgICAgIGlmIChjaHJjdHIgPT09IFwiXCIpIHtcbiAgICAgICAgICAvLyAoIEVuZCBvZiBzdHJpbmcgcmVhY2hlZC4pXG4gICAgICAgICAgcHVzaENvbXBvbmVudCgpO1xuICAgICAgICAgIHB1c2hDb21wb25lbnRBcnJheSgpO1xuICAgICAgICAgIHJldHVybiBsaXN0QXJyYXk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5Db21tZW50KSB7XG4gICAgICAgICAgaWYgKGNocmN0ciA9PT0gXCIqXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi9cIikge1xuICAgICAgICAgICAgLy8gKEF0IGVuZCBvZiBhIGNvbW1lbnQuKVxuICAgICAgICAgICAgaW5Db21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIHB1c2hDb21wb25lbnQoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gMTsgLy8gKFNraXAgYWxsIGNoYXJhY3RlcnMgaW5zaWRlIGNvbW1lbnRzLilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1NwYWNlKGNocmN0cikpIHtcbiAgICAgICAgICAvLyAoSWYgcHJldmlvdXMgY2hhcmFjdGVyIGluIGxvb3Agd2FzIGFsc28gYSBzcGFjZSwgb3IgaWZcbiAgICAgICAgICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcsIGRvIG5vdCBhZGQgc3BhY2UgY2hhciB0b1xuICAgICAgICAgIC8vIGNvbXBvbmVudC4pXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHN0ci5jaGFyQXQocG9zIC0gMSkgJiYgaXNTcGFjZShzdHIuY2hhckF0KHBvcyAtIDEpKSkgfHxcbiAgICAgICAgICAgICFjb21wb25lbnRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJlbkRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICBwdXNoQ29tcG9uZW50KCk7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAoUmVwbGFjZSBhbnkgc3BhY2UgY2hhcmFjdGVyIHdpdGggYSBwbGFpbiBzcGFjZSBmb3IgbGVnaWJpbGl0eS4pXG4gICAgICAgICAgICBjaHJjdHIgPSBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2hyY3RyID09PSBcIihcIikge1xuICAgICAgICAgIHBhcmVuRGVwdGggKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChjaHJjdHIgPT09IFwiKVwiKSB7XG4gICAgICAgICAgcGFyZW5EZXB0aCAtPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGNocmN0ciA9PT0gXCIsXCIpIHtcbiAgICAgICAgICBwdXNoQ29tcG9uZW50KCk7XG4gICAgICAgICAgcHVzaENvbXBvbmVudEFycmF5KCk7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hyY3RyID09PSBcIi9cIiAmJiBzdHIuY2hhckF0KHBvcyArIDEpID09PSBcIipcIikge1xuICAgICAgICAgIGluQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnQgKyBjaHJjdHI7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWROb25OZWdhdGl2ZVNvdXJjZVNpemVWYWx1ZShzKSB7XG4gICAgICBpZiAocmVnZXhDc3NMZW5ndGhXaXRoVW5pdHMudGVzdChzKSAmJiBwYXJzZUZsb2F0KHMpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVnZXhDc3NDYWxjLnRlc3QocykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyAoIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvc3luZGF0YS5odG1sI251bWJlcnMgc2F5czpcbiAgICAgIC8vIFwiLTAgaXMgZXF1aXZhbGVudCB0byAwIGFuZCBpcyBub3QgYSBuZWdhdGl2ZSBudW1iZXIuXCIgd2hpY2ggbWVhbnMgdGhhdFxuICAgICAgLy8gdW5pdGxlc3MgemVybyBhbmQgdW5pdGxlc3MgbmVnYXRpdmUgemVybyBtdXN0IGJlIGFjY2VwdGVkIGFzIHNwZWNpYWwgY2FzZXMuKVxuICAgICAgaWYgKHMgPT09IFwiMFwiIHx8IHMgPT09IFwiLTBcIiB8fCBzID09PSBcIiswXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBhc2tlZCB0byBwYXJzZSBhIHNpemVzIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQsIHBhcnNlIGFcbiAgICAvLyBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBjb21wb25lbnQgdmFsdWVzIGZyb20gdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50J3NcbiAgICAvLyBzaXplcyBhdHRyaWJ1dGUgKG9yIHRoZSBlbXB0eSBzdHJpbmcsIGlmIHRoZSBhdHRyaWJ1dGUgaXMgYWJzZW50KSwgYW5kIGxldFxuICAgIC8vIHVucGFyc2VkIHNpemVzIGxpc3QgYmUgdGhlIHJlc3VsdC5cbiAgICAvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3Mtc3ludGF4LyNwYXJzZS1jb21tYS1zZXBhcmF0ZWQtbGlzdC1vZi1jb21wb25lbnQtdmFsdWVzXG5cbiAgICB1bnBhcnNlZFNpemVzTGlzdCA9IHBhcnNlQ29tcG9uZW50VmFsdWVzKHN0clZhbHVlKTtcbiAgICB1bnBhcnNlZFNpemVzTGlzdExlbmd0aCA9IHVucGFyc2VkU2l6ZXNMaXN0Lmxlbmd0aDtcblxuICAgIC8vIEZvciBlYWNoIHVucGFyc2VkIHNpemUgaW4gdW5wYXJzZWQgc2l6ZXMgbGlzdDpcbiAgICBmb3IgKGkgPSAwOyBpIDwgdW5wYXJzZWRTaXplc0xpc3RMZW5ndGg7IGkrKykge1xuICAgICAgdW5wYXJzZWRTaXplID0gdW5wYXJzZWRTaXplc0xpc3RbaV07XG5cbiAgICAgIC8vIDEuIFJlbW92ZSBhbGwgY29uc2VjdXRpdmUgPHdoaXRlc3BhY2UtdG9rZW4+cyBmcm9tIHRoZSBlbmQgb2YgdW5wYXJzZWQgc2l6ZS5cbiAgICAgIC8vICggcGFyc2VDb21wb25lbnRWYWx1ZXMoKSBhbHJlYWR5IG9taXRzIHNwYWNlcyBvdXRzaWRlIG9mIHBhcmVucy4gKVxuXG4gICAgICAvLyBJZiB1bnBhcnNlZCBzaXplIGlzIG5vdyBlbXB0eSwgdGhhdCBpcyBhIHBhcnNlIGVycm9yOyBjb250aW51ZSB0byB0aGUgbmV4dFxuICAgICAgLy8gaXRlcmF0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxuICAgICAgLy8gKCBwYXJzZUNvbXBvbmVudFZhbHVlcygpIHdvbid0IHB1c2ggYW4gZW1wdHkgYXJyYXkuIClcblxuICAgICAgLy8gMi4gSWYgdGhlIGxhc3QgY29tcG9uZW50IHZhbHVlIGluIHVucGFyc2VkIHNpemUgaXMgYSB2YWxpZCBub24tbmVnYXRpdmVcbiAgICAgIC8vIDxzb3VyY2Utc2l6ZS12YWx1ZT4sIGxldCBzaXplIGJlIGl0cyB2YWx1ZSBhbmQgcmVtb3ZlIHRoZSBjb21wb25lbnQgdmFsdWVcbiAgICAgIC8vIGZyb20gdW5wYXJzZWQgc2l6ZS4gQW55IENTUyBmdW5jdGlvbiBvdGhlciB0aGFuIHRoZSBjYWxjKCkgZnVuY3Rpb24gaXNcbiAgICAgIC8vIGludmFsaWQuIE90aGVyd2lzZSwgdGhlcmUgaXMgYSBwYXJzZSBlcnJvcjsgY29udGludWUgdG8gdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAvLyBvZiB0aGlzIGFsZ29yaXRobS5cbiAgICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1zeW50YXgvI3BhcnNlLWNvbXBvbmVudC12YWx1ZVxuICAgICAgbGFzdENvbXBvbmVudFZhbHVlID0gdW5wYXJzZWRTaXplW3VucGFyc2VkU2l6ZS5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKGlzVmFsaWROb25OZWdhdGl2ZVNvdXJjZVNpemVWYWx1ZShsYXN0Q29tcG9uZW50VmFsdWUpKSB7XG4gICAgICAgIHNpemUgPSBsYXN0Q29tcG9uZW50VmFsdWU7XG4gICAgICAgIHVucGFyc2VkU2l6ZS5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBSZW1vdmUgYWxsIGNvbnNlY3V0aXZlIDx3aGl0ZXNwYWNlLXRva2VuPnMgZnJvbSB0aGUgZW5kIG9mIHVucGFyc2VkXG4gICAgICAvLyBzaXplLiBJZiB1bnBhcnNlZCBzaXplIGlzIG5vdyBlbXB0eSwgcmV0dXJuIHNpemUgYW5kIGV4aXQgdGhpcyBhbGdvcml0aG0uXG4gICAgICAvLyBJZiB0aGlzIHdhcyBub3QgdGhlIGxhc3QgaXRlbSBpbiB1bnBhcnNlZCBzaXplcyBsaXN0LCB0aGF0IGlzIGEgcGFyc2UgZXJyb3IuXG4gICAgICBpZiAodW5wYXJzZWRTaXplLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgIH1cblxuICAgICAgLy8gNC4gUGFyc2UgdGhlIHJlbWFpbmluZyBjb21wb25lbnQgdmFsdWVzIGluIHVucGFyc2VkIHNpemUgYXMgYVxuICAgICAgLy8gPG1lZGlhLWNvbmRpdGlvbj4uIElmIGl0IGRvZXMgbm90IHBhcnNlIGNvcnJlY3RseSwgb3IgaXQgZG9lcyBwYXJzZVxuICAgICAgLy8gY29ycmVjdGx5IGJ1dCB0aGUgPG1lZGlhLWNvbmRpdGlvbj4gZXZhbHVhdGVzIHRvIGZhbHNlLCBjb250aW51ZSB0byB0aGVcbiAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxuICAgICAgLy8gKFBhcnNpbmcgYWxsIHBvc3NpYmxlIGNvbXBvdW5kIG1lZGlhIGNvbmRpdGlvbnMgaW4gSlMgaXMgaGVhdnksIGNvbXBsaWNhdGVkLFxuICAgICAgLy8gYW5kIHRoZSBwYXlvZmYgaXMgdW5jbGVhci4gSXMgdGhlcmUgZXZlciBhbiBzaXR1YXRpb24gd2hlcmUgdGhlXG4gICAgICAvLyBtZWRpYSBjb25kaXRpb24gcGFyc2VzIGluY29ycmVjdGx5IGJ1dCBzdGlsbCBzb21laG93IGV2YWx1YXRlcyB0byB0cnVlP1xuICAgICAgLy8gQ2FuIHdlIGp1c3QgcmVseSBvbiB0aGUgYnJvd3Nlci9wb2x5ZmlsbCB0byBkbyBpdD8pXG4gICAgICB1bnBhcnNlZFNpemUgPSB1bnBhcnNlZFNpemUuam9pbihcIiBcIik7XG4gICAgICBpZiAoIXBmLm1hdGNoZXNNZWRpYSh1bnBhcnNlZFNpemUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyA1LiBSZXR1cm4gc2l6ZSBhbmQgZXhpdCB0aGlzIGFsZ29yaXRobS5cbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBhYm92ZSBhbGdvcml0aG0gZXhoYXVzdHMgdW5wYXJzZWQgc2l6ZXMgbGlzdCB3aXRob3V0IHJldHVybmluZyBhXG4gICAgLy8gc2l6ZSB2YWx1ZSwgcmV0dXJuIDEwMHZ3LlxuICAgIHJldHVybiBcIjEwMHZ3XCI7XG4gIH1cblxuICAvLyBuYW1lc3BhY2VcbiAgcGYubnMgPSAoXCJwZlwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpLnN1YnN0cigwLCA5KTtcblxuICAvLyBzcmNzZXQgc3VwcG9ydCB0ZXN0XG4gIHBmLnN1cFNyY3NldCA9IFwic3Jjc2V0XCIgaW4gaW1hZ2U7XG4gIHBmLnN1cFNpemVzID0gXCJzaXplc1wiIGluIGltYWdlO1xuICBwZi5zdXBQaWN0dXJlID0gISF3aW5kb3cuSFRNTFBpY3R1cmVFbGVtZW50O1xuXG4gIC8vIFVDIGJyb3dzZXIgZG9lcyBjbGFpbSB0byBzdXBwb3J0IHNyY3NldCBhbmQgcGljdHVyZSwgYnV0IG5vdCBzaXplcyxcbiAgLy8gdGhpcyBleHRlbmRlZCB0ZXN0IHJldmVhbHMgdGhlIGJyb3dzZXIgZG9lcyBzdXBwb3J0IG5vdGhpbmdcbiAgaWYgKHBmLnN1cFNyY3NldCAmJiBwZi5zdXBQaWN0dXJlICYmICFwZi5zdXBTaXplcykge1xuICAgIChmdW5jdGlvbihpbWFnZTIpIHtcbiAgICAgIGltYWdlLnNyY3NldCA9IFwiZGF0YTosYVwiO1xuICAgICAgaW1hZ2UyLnNyYyA9IFwiZGF0YTosYVwiO1xuICAgICAgcGYuc3VwU3Jjc2V0ID0gaW1hZ2UuY29tcGxldGUgPT09IGltYWdlMi5jb21wbGV0ZTtcbiAgICAgIHBmLnN1cFBpY3R1cmUgPSBwZi5zdXBTcmNzZXQgJiYgcGYuc3VwUGljdHVyZTtcbiAgICB9KShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpKTtcbiAgfVxuXG4gIC8vIFNhZmFyaTkgaGFzIGJhc2ljIHN1cHBvcnQgZm9yIHNpemVzLCBidXQgZG9lcyd0IGV4cG9zZSB0aGUgYHNpemVzYCBpZGwgYXR0cmlidXRlXG4gIGlmIChwZi5zdXBTcmNzZXQgJiYgIXBmLnN1cFNpemVzKSB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdpZHRoMiA9XG4gICAgICAgIFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQWdBQkFQQUFBUC8vL3dBQUFDSDVCQUFBQUFBQUxBQUFBQUFDQUFFQUFBSUNCQW9BT3c9PVwiO1xuICAgICAgdmFyIHdpZHRoMSA9XG4gICAgICAgIFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFBQUFBQ0g1QkFFS0FBRUFMQUFBQUFBQkFBRUFBQUlDVEFFQU93PT1cIjtcbiAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgdmFyIHRlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gaW1nLndpZHRoO1xuXG4gICAgICAgIGlmICh3aWR0aCA9PT0gMikge1xuICAgICAgICAgIHBmLnN1cFNpemVzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFsd2F5c0NoZWNrV0Rlc2NyaXB0b3IgPSBwZi5zdXBTcmNzZXQgJiYgIXBmLnN1cFNpemVzO1xuXG4gICAgICAgIGlzU3VwcG9ydFRlc3RSZWFkeSA9IHRydWU7XG4gICAgICAgIC8vIGZvcmNlIGFzeW5jXG4gICAgICAgIHNldFRpbWVvdXQocGljdHVyZWZpbGwpO1xuICAgICAgfTtcblxuICAgICAgaW1nLm9ubG9hZCA9IHRlc3Q7XG4gICAgICBpbWcub25lcnJvciA9IHRlc3Q7XG4gICAgICBpbWcuc2V0QXR0cmlidXRlKFwic2l6ZXNcIiwgXCI5cHhcIik7XG5cbiAgICAgIGltZy5zcmNzZXQgPSB3aWR0aDEgKyBcIiAxdyxcIiArIHdpZHRoMiArIFwiIDl3XCI7XG4gICAgICBpbWcuc3JjID0gd2lkdGgxO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgaXNTdXBwb3J0VGVzdFJlYWR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHVzaW5nIHBmLnFzYSBpbnN0ZWFkIG9mIGRvbSB0cmF2ZXJzaW5nIGRvZXMgc2NhbGUgbXVjaCBiZXR0ZXIsXG4gIC8vIGVzcGVjaWFsbHkgb24gc2l0ZXMgbWl4aW5nIHJlc3BvbnNpdmUgYW5kIG5vbi1yZXNwb25zaXZlIGltYWdlc1xuICBwZi5zZWxTaG9ydCA9IFwicGljdHVyZT5pbWcsaW1nW3NyY3NldF1cIjtcbiAgcGYuc2VsID0gcGYuc2VsU2hvcnQ7XG4gIHBmLmNmZyA9IGNmZztcblxuICAvKipcbiAgICogU2hvcnRjdXQgcHJvcGVydHkgZm9yIGBkZXZpY2VQaXhlbFJhdGlvYCAoIGZvciBlYXN5IG92ZXJyaWRpbmcgaW4gdGVzdHMgKVxuICAgKi9cbiAgcGYuRFBSID0gRFBSIHx8IDE7XG4gIHBmLnUgPSB1bml0cztcblxuICAvLyBjb250YWluZXIgb2Ygc3VwcG9ydGVkIG1pbWUgdHlwZXMgdGhhdCBvbmUgbWlnaHQgbmVlZCB0byBxdWFsaWZ5IGJlZm9yZSB1c2luZ1xuICBwZi50eXBlcyA9IHR5cGVzO1xuXG4gIHBmLnNldFNpemUgPSBub29wO1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBhYnNvbHV0ZSBVUkxcbiAgICogQHBhcmFtIHNyY1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBhYnNvbHV0ZSBVUkxcbiAgICovXG5cbiAgcGYubWFrZVVybCA9IG1lbW9pemUoZnVuY3Rpb24oc3JjKSB7XG4gICAgYW5jaG9yLmhyZWYgPSBzcmM7XG4gICAgcmV0dXJuIGFuY2hvci5ocmVmO1xuICB9KTtcblxuICAvKipcbiAgICogR2V0cyBhIERPTSBlbGVtZW50IG9yIGRvY3VtZW50IGFuZCBhIHNlbGN0b3IgYW5kIHJldHVybnMgdGhlIGZvdW5kIG1hdGNoZXNcbiAgICogQ2FuIGJlIGV4dGVuZGVkIHdpdGggalF1ZXJ5L1NpenpsZSBmb3IgSUU3IHN1cHBvcnRcbiAgICogQHBhcmFtIGNvbnRleHRcbiAgICogQHBhcmFtIHNlbFxuICAgKiBAcmV0dXJucyB7Tm9kZUxpc3R8QXJyYXl9XG4gICAqL1xuICBwZi5xc2EgPSBmdW5jdGlvbihjb250ZXh0LCBzZWwpIHtcbiAgICByZXR1cm4gXCJxdWVyeVNlbGVjdG9yXCIgaW4gY29udGV4dCA/IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWwpIDogW107XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IG1ldGhvZCBmb3IgbWF0Y2hNZWRpYSAoIGZvciBlYXN5IG92ZXJyaWRpbmcgaW4gdGVzdHMgKVxuICAgKiB3ZXRoZXIgbmF0aXZlIG9yIHBmLm1NUSBpcyB1c2VkIHdpbGwgYmUgZGVjaWRlZCBsYXp5IG9uIGZpcnN0IGNhbGxcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBwZi5tYXRjaGVzTWVkaWEgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEgJiYgKG1hdGNoTWVkaWEoXCIobWluLXdpZHRoOiAwLjFlbSlcIikgfHwge30pLm1hdGNoZXMpIHtcbiAgICAgIHBmLm1hdGNoZXNNZWRpYSA9IGZ1bmN0aW9uKG1lZGlhKSB7XG4gICAgICAgIHJldHVybiAhbWVkaWEgfHwgbWF0Y2hNZWRpYShtZWRpYSkubWF0Y2hlcztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBmLm1hdGNoZXNNZWRpYSA9IHBmLm1NUTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGYubWF0Y2hlc01lZGlhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxpZmllZCBtYXRjaE1lZGlhIGltcGxlbWVudGF0aW9uIGZvciBJRTggYW5kIElFOVxuICAgKiBoYW5kbGVzIG9ubHkgbWluLXdpZHRoL21heC13aWR0aCB3aXRoIHB4IG9yIGVtIHZhbHVlc1xuICAgKiBAcGFyYW0gbWVkaWFcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBwZi5tTVEgPSBmdW5jdGlvbihtZWRpYSkge1xuICAgIHJldHVybiBtZWRpYSA/IGV2YWxDU1MobWVkaWEpIDogdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCBsZW5ndGggaW4gY3NzIHBpeGVsIGZyb20gdGhlIGdpdmVuIHNvdXJjZVNpemVWYWx1ZVxuICAgKiBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtdmFsdWVzLTMvI2xlbmd0aC12YWx1ZVxuICAgKiBpbnRlbmRlZCBTcGVjIG1pc21hdGNoZXM6XG4gICAqICogRG9lcyBub3QgY2hlY2sgZm9yIGludmFsaWQgdXNlIG9mIENTUyBmdW5jdGlvbnNcbiAgICogKiBEb2VzIGhhbmRsZSBhIGNvbXB1dGVkIGxlbmd0aCBvZiAwIHRoZSBzYW1lIGFzIGEgbmVnYXRpdmUgYW5kIHRoZXJlZm9yZSBpbnZhbGlkIHZhbHVlXG4gICAqIEBwYXJhbSBzb3VyY2VTaXplVmFsdWVcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHBmLmNhbGNMZW5ndGggPSBmdW5jdGlvbihzb3VyY2VTaXplVmFsdWUpIHtcbiAgICB2YXIgdmFsdWUgPSBldmFsQ1NTKHNvdXJjZVNpemVWYWx1ZSwgdHJ1ZSkgfHwgZmFsc2U7XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgdHlwZSBzdHJpbmcgYW5kIGNoZWNrcyBpZiBpdHMgc3VwcG9ydGVkXG4gICAqL1xuXG4gIHBmLnN1cHBvcnRzVHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSA/IHR5cGVzW3R5cGVdIDogdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGEgc291cmNlU2l6ZSBpbnRvIG1lZGlhQ29uZGl0aW9uIChtZWRpYSkgYW5kIHNvdXJjZVNpemVWYWx1ZSAobGVuZ3RoKVxuICAgKiBAcGFyYW0gc291cmNlU2l6ZVN0clxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHBmLnBhcnNlU2l6ZSA9IG1lbW9pemUoZnVuY3Rpb24oc291cmNlU2l6ZVN0cikge1xuICAgIHZhciBtYXRjaCA9IChzb3VyY2VTaXplU3RyIHx8IFwiXCIpLm1hdGNoKHJlZ1NpemUpO1xuICAgIHJldHVybiB7XG4gICAgICBtZWRpYTogbWF0Y2ggJiYgbWF0Y2hbMV0sXG4gICAgICBsZW5ndGg6IG1hdGNoICYmIG1hdGNoWzJdXG4gICAgfTtcbiAgfSk7XG5cbiAgcGYucGFyc2VTZXQgPSBmdW5jdGlvbihzZXQpIHtcbiAgICBpZiAoIXNldC5jYW5kcykge1xuICAgICAgc2V0LmNhbmRzID0gcGFyc2VTcmNzZXQoc2V0LnNyY3NldCwgc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNldC5jYW5kcztcbiAgfTtcblxuICAvKipcbiAgICogcmV0dXJucyAxZW0gaW4gY3NzIHB4IGZvciBodG1sL2JvZHkgZGVmYXVsdCBzaXplXG4gICAqIGZ1bmN0aW9uIHRha2VuIGZyb20gcmVzcG9uZGpzXG4gICAqIEByZXR1cm5zIHsqfG51bWJlcn1cbiAgICovXG4gIHBmLmdldEVtVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm9keTtcbiAgICBpZiAoIWVtaW5weCAmJiAoYm9keSA9IGRvY3VtZW50LmJvZHkpKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgb3JpZ2luYWxIVE1MQ1NTID0gZG9jRWxlbS5zdHlsZS5jc3NUZXh0LFxuICAgICAgICBvcmlnaW5hbEJvZHlDU1MgPSBib2R5LnN0eWxlLmNzc1RleHQ7XG5cbiAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gYmFzZVN0eWxlO1xuXG4gICAgICAvLyAxZW0gaW4gYSBtZWRpYSBxdWVyeSBpcyB0aGUgdmFsdWUgb2YgdGhlIGRlZmF1bHQgZm9udCBzaXplIG9mIHRoZSBicm93c2VyXG4gICAgICAvLyByZXNldCBkb2NFbGVtIGFuZCBib2R5IHRvIGVuc3VyZSB0aGUgY29ycmVjdCB2YWx1ZSBpcyByZXR1cm5lZFxuICAgICAgZG9jRWxlbS5zdHlsZS5jc3NUZXh0ID0gZnNDc3M7XG4gICAgICBib2R5LnN0eWxlLmNzc1RleHQgPSBmc0NzcztcblxuICAgICAgYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgZW1pbnB4ID0gZGl2Lm9mZnNldFdpZHRoO1xuICAgICAgYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuXG4gICAgICAvL2Fsc28gdXBkYXRlIGVtaW5weCBiZWZvcmUgcmV0dXJuaW5nXG4gICAgICBlbWlucHggPSBwYXJzZUZsb2F0KGVtaW5weCwgMTApO1xuXG4gICAgICAvLyByZXN0b3JlIHRoZSBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgIGRvY0VsZW0uc3R5bGUuY3NzVGV4dCA9IG9yaWdpbmFsSFRNTENTUztcbiAgICAgIGJvZHkuc3R5bGUuY3NzVGV4dCA9IG9yaWdpbmFsQm9keUNTUztcbiAgICB9XG4gICAgcmV0dXJuIGVtaW5weCB8fCAxNjtcbiAgfTtcblxuICAvKipcbiAgICogVGFrZXMgYSBzdHJpbmcgb2Ygc2l6ZXMgYW5kIHJldHVybnMgdGhlIHdpZHRoIGluIHBpeGVscyBhcyBhIG51bWJlclxuICAgKi9cbiAgcGYuY2FsY0xpc3RMZW5ndGggPSBmdW5jdGlvbihzb3VyY2VTaXplTGlzdFN0cikge1xuICAgIC8vIFNwbGl0IHVwIHNvdXJjZSBzaXplIGxpc3QsIGllICggbWF4LXdpZHRoOiAzMGVtICkgMTAwJSwgKCBtYXgtd2lkdGg6IDUwZW0gKSA1MCUsIDMzJVxuICAgIC8vXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICBvciAobWluLXdpZHRoOjMwZW0pIGNhbGMoMzAlIC0gMTVweClcbiAgICBpZiAoIShzb3VyY2VTaXplTGlzdFN0ciBpbiBzaXplTGVuZ3RoQ2FjaGUpIHx8IGNmZy51VCkge1xuICAgICAgdmFyIHdpbm5pbmdMZW5ndGggPSBwZi5jYWxjTGVuZ3RoKHBhcnNlU2l6ZXMoc291cmNlU2l6ZUxpc3RTdHIpKTtcblxuICAgICAgc2l6ZUxlbmd0aENhY2hlW3NvdXJjZVNpemVMaXN0U3RyXSA9ICF3aW5uaW5nTGVuZ3RoXG4gICAgICAgID8gdW5pdHMud2lkdGhcbiAgICAgICAgOiB3aW5uaW5nTGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBzaXplTGVuZ3RoQ2FjaGVbc291cmNlU2l6ZUxpc3RTdHJdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUYWtlcyBhIGNhbmRpZGF0ZSBvYmplY3Qgd2l0aCBhIHNyY3NldCBwcm9wZXJ0eSBpbiB0aGUgZm9ybSBvZiB1cmwvXG4gICAqIGV4LiBcImltYWdlcy9waWMtbWVkaXVtLnBuZyAxeCwgaW1hZ2VzL3BpYy1tZWRpdW0tMngucG5nIDJ4XCIgb3JcbiAgICogICAgIFwiaW1hZ2VzL3BpYy1tZWRpdW0ucG5nIDQwMHcsIGltYWdlcy9waWMtbWVkaXVtLTJ4LnBuZyA4MDB3XCIgb3JcbiAgICogICAgIFwiaW1hZ2VzL3BpYy1zbWFsbC5wbmdcIlxuICAgKiBHZXQgYW4gYXJyYXkgb2YgaW1hZ2UgY2FuZGlkYXRlcyBpbiB0aGUgZm9ybSBvZlxuICAgKiAgICAgIHt1cmw6IFwiL2Zvby9iYXIucG5nXCIsIHJlc29sdXRpb246IDF9XG4gICAqIHdoZXJlIHJlc29sdXRpb24gaXMgaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLXZhbHVlcy0zLyNyZXNvbHV0aW9uLXZhbHVlXG4gICAqIElmIHNpemVzIGlzIHNwZWNpZmllZCwgcmVzIGlzIGNhbGN1bGF0ZWRcbiAgICovXG4gIHBmLnNldFJlcyA9IGZ1bmN0aW9uKHNldCkge1xuICAgIHZhciBjYW5kaWRhdGVzO1xuICAgIGlmIChzZXQpIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBwZi5wYXJzZVNldChzZXQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FuZGlkYXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzZXRSZXNvbHV0aW9uKGNhbmRpZGF0ZXNbaV0sIHNldC5zaXplcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICB9O1xuXG4gIHBmLnNldFJlcy5yZXMgPSBzZXRSZXNvbHV0aW9uO1xuXG4gIHBmLmFwcGx5U2V0Q2FuZGlkYXRlID0gZnVuY3Rpb24oY2FuZGlkYXRlcywgaW1nKSB7XG4gICAgaWYgKCFjYW5kaWRhdGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2FuZGlkYXRlLFxuICAgICAgaSxcbiAgICAgIGosXG4gICAgICBsZW5ndGgsXG4gICAgICBiZXN0Q2FuZGlkYXRlLFxuICAgICAgY3VyU3JjLFxuICAgICAgY3VyQ2FuLFxuICAgICAgY2FuZGlkYXRlU3JjLFxuICAgICAgYWJvcnRDdXJTcmM7XG5cbiAgICB2YXIgaW1hZ2VEYXRhID0gaW1nW3BmLm5zXTtcbiAgICB2YXIgZHByID0gcGYuRFBSO1xuXG4gICAgY3VyU3JjID0gaW1hZ2VEYXRhLmN1clNyYyB8fCBpbWdbY3VyU3JjUHJvcF07XG5cbiAgICBjdXJDYW4gPSBpbWFnZURhdGEuY3VyQ2FuIHx8IHNldFNyY1RvQ3VyKGltZywgY3VyU3JjLCBjYW5kaWRhdGVzWzBdLnNldCk7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGEgY3VycmVudCBzb3VyY2UsIHdlIG1pZ2h0IGVpdGhlciBiZWNvbWUgbGF6eSBvciBnaXZlIHRoaXMgc291cmNlIHNvbWUgYWR2YW50YWdlXG4gICAgaWYgKGN1ckNhbiAmJiBjdXJDYW4uc2V0ID09PSBjYW5kaWRhdGVzWzBdLnNldCkge1xuICAgICAgLy8gaWYgYnJvd3NlciBjYW4gYWJvcnQgaW1hZ2UgcmVxdWVzdCBhbmQgdGhlIGltYWdlIGhhcyBhIGhpZ2hlciBwaXhlbCBkZW5zaXR5IHRoYW4gbmVlZGVkXG4gICAgICAvLyBhbmQgdGhpcyBpbWFnZSBpc24ndCBkb3dubG9hZGVkIHlldCwgd2Ugc2tpcCBuZXh0IHBhcnQgYW5kIHRyeSB0byBzYXZlIGJhbmR3aWR0aFxuICAgICAgYWJvcnRDdXJTcmMgPSBzdXBwb3J0QWJvcnQgJiYgIWltZy5jb21wbGV0ZSAmJiBjdXJDYW4ucmVzIC0gMC4xID4gZHByO1xuXG4gICAgICBpZiAoIWFib3J0Q3VyU3JjKSB7XG4gICAgICAgIGN1ckNhbi5jYWNoZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIGlmIGN1cnJlbnQgY2FuZGlkYXRlIGlzIFwiYmVzdFwiLCBcImJldHRlclwiIG9yIFwib2theVwiLFxuICAgICAgICAvLyBzZXQgaXQgdG8gYmVzdENhbmRpZGF0ZVxuICAgICAgICBpZiAoY3VyQ2FuLnJlcyA+PSBkcHIpIHtcbiAgICAgICAgICBiZXN0Q2FuZGlkYXRlID0gY3VyQ2FuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFiZXN0Q2FuZGlkYXRlKSB7XG4gICAgICBjYW5kaWRhdGVzLnNvcnQoYXNjZW5kaW5nU29ydCk7XG5cbiAgICAgIGxlbmd0aCA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgYmVzdENhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbbGVuZ3RoIC0gMV07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzW2ldO1xuICAgICAgICBpZiAoY2FuZGlkYXRlLnJlcyA+PSBkcHIpIHtcbiAgICAgICAgICBqID0gaSAtIDE7XG5cbiAgICAgICAgICAvLyB3ZSBoYXZlIGZvdW5kIHRoZSBwZXJmZWN0IGNhbmRpZGF0ZSxcbiAgICAgICAgICAvLyBidXQgbGV0J3MgaW1wcm92ZSB0aGlzIGEgbGl0dGxlIGJpdCB3aXRoIHNvbWUgYXNzdW1wdGlvbnMgOy0pXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2FuZGlkYXRlc1tqXSAmJlxuICAgICAgICAgICAgKGFib3J0Q3VyU3JjIHx8IGN1clNyYyAhPT0gcGYubWFrZVVybChjYW5kaWRhdGUudXJsKSkgJiZcbiAgICAgICAgICAgIGNob29zZUxvd1JlcyhcbiAgICAgICAgICAgICAgY2FuZGlkYXRlc1tqXS5yZXMsXG4gICAgICAgICAgICAgIGNhbmRpZGF0ZS5yZXMsXG4gICAgICAgICAgICAgIGRwcixcbiAgICAgICAgICAgICAgY2FuZGlkYXRlc1tqXS5jYWNoZWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGJlc3RDYW5kaWRhdGUgPSBjYW5kaWRhdGVzW2pdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZXN0Q2FuZGlkYXRlID0gY2FuZGlkYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiZXN0Q2FuZGlkYXRlKSB7XG4gICAgICBjYW5kaWRhdGVTcmMgPSBwZi5tYWtlVXJsKGJlc3RDYW5kaWRhdGUudXJsKTtcblxuICAgICAgaW1hZ2VEYXRhLmN1clNyYyA9IGNhbmRpZGF0ZVNyYztcbiAgICAgIGltYWdlRGF0YS5jdXJDYW4gPSBiZXN0Q2FuZGlkYXRlO1xuXG4gICAgICBpZiAoY2FuZGlkYXRlU3JjICE9PSBjdXJTcmMpIHtcbiAgICAgICAgcGYuc2V0U3JjKGltZywgYmVzdENhbmRpZGF0ZSk7XG4gICAgICB9XG4gICAgICBwZi5zZXRTaXplKGltZyk7XG4gICAgfVxuICB9O1xuXG4gIHBmLnNldFNyYyA9IGZ1bmN0aW9uKGltZywgYmVzdENhbmRpZGF0ZSkge1xuICAgIHZhciBvcmlnV2lkdGg7XG4gICAgaW1nLnNyYyA9IGJlc3RDYW5kaWRhdGUudXJsO1xuXG4gICAgLy8gYWx0aG91Z2ggdGhpcyBpcyBhIHNwZWNpZmljIFNhZmFyaSBpc3N1ZSwgd2UgZG9uJ3Qgd2FudCB0byB0YWtlIHRvbyBtdWNoIGRpZmZlcmVudCBjb2RlIHBhdGhzXG4gICAgaWYgKGJlc3RDYW5kaWRhdGUuc2V0LnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICBvcmlnV2lkdGggPSBpbWcuc3R5bGUud2lkdGg7XG4gICAgICBpbWcuc3R5bGUud2lkdGggPSBpbWcub2Zmc2V0V2lkdGggKyAxICsgXCJweFwiO1xuXG4gICAgICAvLyBuZXh0IGxpbmUgb25seSBzaG91bGQgdHJpZ2dlciBhIHJlcGFpbnRcbiAgICAgIC8vIGlmLi4uIGlzIG9ubHkgZG9uZSB0byB0cmljayBkZWFkIGNvZGUgcmVtb3ZhbFxuICAgICAgaWYgKGltZy5vZmZzZXRXaWR0aCArIDEpIHtcbiAgICAgICAgaW1nLnN0eWxlLndpZHRoID0gb3JpZ1dpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwZi5nZXRTZXQgPSBmdW5jdGlvbihpbWcpIHtcbiAgICB2YXIgaSwgc2V0LCBzdXBwb3J0c1R5cGU7XG4gICAgdmFyIG1hdGNoID0gZmFsc2U7XG4gICAgdmFyIHNldHMgPSBpbWdbcGYubnNdLnNldHM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2V0cy5sZW5ndGggJiYgIW1hdGNoOyBpKyspIHtcbiAgICAgIHNldCA9IHNldHNbaV07XG5cbiAgICAgIGlmIChcbiAgICAgICAgIXNldC5zcmNzZXQgfHxcbiAgICAgICAgIXBmLm1hdGNoZXNNZWRpYShzZXQubWVkaWEpIHx8XG4gICAgICAgICEoc3VwcG9ydHNUeXBlID0gcGYuc3VwcG9ydHNUeXBlKHNldC50eXBlKSlcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN1cHBvcnRzVHlwZSA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgc2V0ID0gc3VwcG9ydHNUeXBlO1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IHNldDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcblxuICBwZi5wYXJzZVNldHMgPSBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc3Jjc2V0QXR0cmlidXRlLCBpbWFnZVNldCwgaXNXRGVzY3JpcG9yLCBzcmNzZXRQYXJzZWQ7XG5cbiAgICB2YXIgaGFzUGljdHVyZSA9IHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJQSUNUVVJFXCI7XG4gICAgdmFyIGltYWdlRGF0YSA9IGVsZW1lbnRbcGYubnNdO1xuXG4gICAgaWYgKGltYWdlRGF0YS5zcmMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnNyYykge1xuICAgICAgaW1hZ2VEYXRhLnNyYyA9IGdldEltZ0F0dHIuY2FsbChlbGVtZW50LCBcInNyY1wiKTtcbiAgICAgIGlmIChpbWFnZURhdGEuc3JjKSB7XG4gICAgICAgIHNldEltZ0F0dHIuY2FsbChlbGVtZW50LCBzcmNBdHRyLCBpbWFnZURhdGEuc3JjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUltZ0F0dHIuY2FsbChlbGVtZW50LCBzcmNBdHRyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBpbWFnZURhdGEuc3Jjc2V0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIG9wdGlvbnMuc3Jjc2V0IHx8XG4gICAgICAhcGYuc3VwU3Jjc2V0IHx8XG4gICAgICBlbGVtZW50LnNyY3NldFxuICAgICkge1xuICAgICAgc3Jjc2V0QXR0cmlidXRlID0gZ2V0SW1nQXR0ci5jYWxsKGVsZW1lbnQsIFwic3Jjc2V0XCIpO1xuICAgICAgaW1hZ2VEYXRhLnNyY3NldCA9IHNyY3NldEF0dHJpYnV0ZTtcbiAgICAgIHNyY3NldFBhcnNlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaW1hZ2VEYXRhLnNldHMgPSBbXTtcblxuICAgIGlmIChoYXNQaWN0dXJlKSB7XG4gICAgICBpbWFnZURhdGEucGljID0gdHJ1ZTtcbiAgICAgIGdldEFsbFNvdXJjZUVsZW1lbnRzKHBhcmVudCwgaW1hZ2VEYXRhLnNldHMpO1xuICAgIH1cblxuICAgIGlmIChpbWFnZURhdGEuc3Jjc2V0KSB7XG4gICAgICBpbWFnZVNldCA9IHtcbiAgICAgICAgc3Jjc2V0OiBpbWFnZURhdGEuc3Jjc2V0LFxuICAgICAgICBzaXplczogZ2V0SW1nQXR0ci5jYWxsKGVsZW1lbnQsIFwic2l6ZXNcIilcbiAgICAgIH07XG5cbiAgICAgIGltYWdlRGF0YS5zZXRzLnB1c2goaW1hZ2VTZXQpO1xuXG4gICAgICBpc1dEZXNjcmlwb3IgPVxuICAgICAgICAoYWx3YXlzQ2hlY2tXRGVzY3JpcHRvciB8fCBpbWFnZURhdGEuc3JjKSAmJlxuICAgICAgICByZWdXRGVzYy50ZXN0KGltYWdlRGF0YS5zcmNzZXQgfHwgXCJcIik7XG5cbiAgICAgIC8vIGFkZCBub3JtYWwgc3JjIGFzIGNhbmRpZGF0ZSwgaWYgc291cmNlIGhhcyBubyB3IGRlc2NyaXB0b3JcbiAgICAgIGlmIChcbiAgICAgICAgIWlzV0Rlc2NyaXBvciAmJlxuICAgICAgICBpbWFnZURhdGEuc3JjICYmXG4gICAgICAgICFnZXRDYW5kaWRhdGVGb3JTcmMoaW1hZ2VEYXRhLnNyYywgaW1hZ2VTZXQpICYmXG4gICAgICAgICFpbWFnZVNldC5oYXMxeFxuICAgICAgKSB7XG4gICAgICAgIGltYWdlU2V0LnNyY3NldCArPSBcIiwgXCIgKyBpbWFnZURhdGEuc3JjO1xuICAgICAgICBpbWFnZVNldC5jYW5kcy5wdXNoKHtcbiAgICAgICAgICB1cmw6IGltYWdlRGF0YS5zcmMsXG4gICAgICAgICAgZDogMSxcbiAgICAgICAgICBzZXQ6IGltYWdlU2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW1hZ2VEYXRhLnNyYykge1xuICAgICAgaW1hZ2VEYXRhLnNldHMucHVzaCh7XG4gICAgICAgIHNyY3NldDogaW1hZ2VEYXRhLnNyYyxcbiAgICAgICAgc2l6ZXM6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGltYWdlRGF0YS5jdXJDYW4gPSBudWxsO1xuICAgIGltYWdlRGF0YS5jdXJTcmMgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBpZiBpbWcgaGFzIHBpY3R1cmUgb3IgdGhlIHNyY3NldCB3YXMgcmVtb3ZlZCBvciBoYXMgYSBzcmNzZXQgYW5kIGRvZXMgbm90IHN1cHBvcnQgc3Jjc2V0IGF0IGFsbFxuICAgIC8vIG9yIGhhcyBhIHcgZGVzY3JpcHRvciAoYW5kIGRvZXMgbm90IHN1cHBvcnQgc2l6ZXMpIHNldCBzdXBwb3J0IHRvIGZhbHNlIHRvIGV2YWx1YXRlXG4gICAgaW1hZ2VEYXRhLnN1cHBvcnRlZCA9ICEoXG4gICAgICBoYXNQaWN0dXJlIHx8XG4gICAgICAoaW1hZ2VTZXQgJiYgIXBmLnN1cFNyY3NldCkgfHxcbiAgICAgIChpc1dEZXNjcmlwb3IgJiYgIXBmLnN1cFNpemVzKVxuICAgICk7XG5cbiAgICBpZiAoc3Jjc2V0UGFyc2VkICYmIHBmLnN1cFNyY3NldCAmJiAhaW1hZ2VEYXRhLnN1cHBvcnRlZCkge1xuICAgICAgaWYgKHNyY3NldEF0dHJpYnV0ZSkge1xuICAgICAgICBzZXRJbWdBdHRyLmNhbGwoZWxlbWVudCwgc3Jjc2V0QXR0ciwgc3Jjc2V0QXR0cmlidXRlKTtcbiAgICAgICAgZWxlbWVudC5zcmNzZXQgPSBcIlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlSW1nQXR0ci5jYWxsKGVsZW1lbnQsIHNyY3NldEF0dHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGltYWdlRGF0YS5zdXBwb3J0ZWQgJiZcbiAgICAgICFpbWFnZURhdGEuc3Jjc2V0ICYmXG4gICAgICAoKCFpbWFnZURhdGEuc3JjICYmIGVsZW1lbnQuc3JjKSB8fFxuICAgICAgICBlbGVtZW50LnNyYyAhPT0gcGYubWFrZVVybChpbWFnZURhdGEuc3JjKSlcbiAgICApIHtcbiAgICAgIGlmIChpbWFnZURhdGEuc3JjID09PSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwic3JjXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zcmMgPSBpbWFnZURhdGEuc3JjO1xuICAgICAgfVxuICAgIH1cblxuICAgIGltYWdlRGF0YS5wYXJzZWQgPSB0cnVlO1xuICB9O1xuXG4gIHBmLmZpbGxJbWcgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIGltYWdlRGF0YTtcbiAgICB2YXIgZXh0cmVtZSA9IG9wdGlvbnMucmVzZWxlY3QgfHwgb3B0aW9ucy5yZWV2YWx1YXRlO1xuXG4gICAgLy8gZXhwYW5kbyBmb3IgY2FjaGluZyBkYXRhIG9uIHRoZSBpbWdcbiAgICBpZiAoIWVsZW1lbnRbcGYubnNdKSB7XG4gICAgICBlbGVtZW50W3BmLm5zXSA9IHt9O1xuICAgIH1cblxuICAgIGltYWdlRGF0YSA9IGVsZW1lbnRbcGYubnNdO1xuXG4gICAgLy8gaWYgdGhlIGVsZW1lbnQgaGFzIGFscmVhZHkgYmVlbiBldmFsdWF0ZWQsIHNraXAgaXRcbiAgICAvLyB1bmxlc3MgYG9wdGlvbnMucmVldmFsdWF0ZWAgaXMgc2V0IHRvIHRydWUgKCB0aGlzLCBmb3IgZXhhbXBsZSxcbiAgICAvLyBpcyBzZXQgdG8gdHJ1ZSB3aGVuIHJ1bm5pbmcgYHBpY3R1cmVmaWxsYCBvbiBgcmVzaXplYCApLlxuICAgIGlmICghZXh0cmVtZSAmJiBpbWFnZURhdGEuZXZhbGVkID09PSBldmFsSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWltYWdlRGF0YS5wYXJzZWQgfHwgb3B0aW9ucy5yZWV2YWx1YXRlKSB7XG4gICAgICBwZi5wYXJzZVNldHMoZWxlbWVudCwgZWxlbWVudC5wYXJlbnROb2RlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoIWltYWdlRGF0YS5zdXBwb3J0ZWQpIHtcbiAgICAgIGFwcGx5QmVzdENhbmRpZGF0ZShlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1hZ2VEYXRhLmV2YWxlZCA9IGV2YWxJZDtcbiAgICB9XG4gIH07XG5cbiAgcGYuc2V0dXBSdW4gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWFscmVhZHlSdW4gfHwgaXNWd0RpcnR5IHx8IERQUiAhPT0gd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgIHVwZGF0ZU1ldHJpY3MoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSWYgcGljdHVyZSBpcyBzdXBwb3J0ZWQsIHdlbGwsIHRoYXQncyBhd2Vzb21lLlxuICBpZiAocGYuc3VwUGljdHVyZSkge1xuICAgIHBpY3R1cmVmaWxsID0gbm9vcDtcbiAgICBwZi5maWxsSW1nID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTZXQgdXAgcGljdHVyZSBwb2x5ZmlsbCBieSBwb2xsaW5nIHRoZSBkb2N1bWVudFxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc0RvbVJlYWR5O1xuICAgICAgdmFyIHJlZ1JlYWR5ID0gd2luZG93LmF0dGFjaEV2ZW50ID8gL2QkfF5jLyA6IC9kJHxeY3xeaS87XG5cbiAgICAgIHZhciBydW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlYWR5U3RhdGUgPSBkb2N1bWVudC5yZWFkeVN0YXRlIHx8IFwiXCI7XG5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQocnVuLCByZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIiA/IDIwMCA6IDk5OSk7XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgcGYuZmlsbEltZ3MoKTtcbiAgICAgICAgICBpc0RvbVJlYWR5ID0gaXNEb21SZWFkeSB8fCByZWdSZWFkeS50ZXN0KHJlYWR5U3RhdGUpO1xuICAgICAgICAgIGlmIChpc0RvbVJlYWR5KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgdGltZXJJZCA9IHNldFRpbWVvdXQocnVuLCBkb2N1bWVudC5ib2R5ID8gOSA6IDk5KTtcblxuICAgICAgLy8gQWxzbyBhdHRhY2ggcGljdHVyZWZpbGwgb24gcmVzaXplIGFuZCByZWFkeXN0YXRlY2hhbmdlXG4gICAgICAvLyBodHRwOi8vbW9kZXJuamF2YXNjcmlwdC5ibG9nc3BvdC5jb20vMjAxMy8wOC9idWlsZGluZy1iZXR0ZXItZGVib3VuY2UuaHRtbFxuICAgICAgdmFyIGRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgICAgICB2YXIgdGltZW91dCwgdGltZXN0YW1wO1xuICAgICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IG5ldyBEYXRlKCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgICAgICBpZiAobGFzdCA8IHdhaXQpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgZnVuYygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcblxuICAgICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB2YXIgbGFzdENsaWVudFdpZHRoID0gZG9jRWxlbS5jbGllbnRIZWlnaHQ7XG4gICAgICB2YXIgb25SZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaXNWd0RpcnR5ID1cbiAgICAgICAgICBNYXRoLm1heCh3aW5kb3cuaW5uZXJXaWR0aCB8fCAwLCBkb2NFbGVtLmNsaWVudFdpZHRoKSAhPT1cbiAgICAgICAgICAgIHVuaXRzLndpZHRoIHx8IGRvY0VsZW0uY2xpZW50SGVpZ2h0ICE9PSBsYXN0Q2xpZW50V2lkdGg7XG4gICAgICAgIGxhc3RDbGllbnRXaWR0aCA9IGRvY0VsZW0uY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoaXNWd0RpcnR5KSB7XG4gICAgICAgICAgcGYuZmlsbEltZ3MoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgb24od2luZG93LCBcInJlc2l6ZVwiLCBkZWJvdW5jZShvblJlc2l6ZSwgOTkpKTtcbiAgICAgIG9uKGRvY3VtZW50LCBcInJlYWR5c3RhdGVjaGFuZ2VcIiwgcnVuKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgcGYucGljdHVyZWZpbGwgPSBwaWN0dXJlZmlsbDtcbiAgLy91c2UgdGhpcyBpbnRlcm5hbGx5IGZvciBlYXN5IG1vbmtleSBwYXRjaGluZy9wZXJmb3JtYW5jZSB0ZXN0aW5nXG4gIHBmLmZpbGxJbWdzID0gcGljdHVyZWZpbGw7XG4gIHBmLnRlYXJkb3duUnVuID0gbm9vcDtcblxuICAvKiBleHBvc2UgbWV0aG9kcyBmb3IgdGVzdGluZyAqL1xuICBwaWN0dXJlZmlsbC5fID0gcGY7XG5cbiAgd2luZG93LnBpY3R1cmVmaWxsQ0ZHID0ge1xuICAgIHBmOiBwZixcbiAgICBwdXNoOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICB2YXIgbmFtZSA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgIGlmICh0eXBlb2YgcGZbbmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwZltuYW1lXS5hcHBseShwZiwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZmdbbmFtZV0gPSBhcmdzWzBdO1xuICAgICAgICBpZiAoYWxyZWFkeVJ1bikge1xuICAgICAgICAgIHBmLmZpbGxJbWdzKHsgcmVzZWxlY3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2hpbGUgKHNldE9wdGlvbnMgJiYgc2V0T3B0aW9ucy5sZW5ndGgpIHtcbiAgICB3aW5kb3cucGljdHVyZWZpbGxDRkcucHVzaChzZXRPcHRpb25zLnNoaWZ0KCkpO1xuICB9XG5cbiAgLyogZXhwb3NlIHBpY3R1cmVmaWxsICovXG4gIHdpbmRvdy5waWN0dXJlZmlsbCA9IHBpY3R1cmVmaWxsO1xuXG4gIC8qIGV4cG9zZSBwaWN0dXJlZmlsbCAqL1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAvLyBDb21tb25KUywganVzdCBleHBvcnRcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBpY3R1cmVmaWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1EIHN1cHBvcnRcbiAgICBkZWZpbmUoXCJwaWN0dXJlZmlsbFwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwaWN0dXJlZmlsbDtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIElFOCBldmFscyB0aGlzIHN5bmMsIHNvIGl0IG11c3QgYmUgdGhlIGxhc3QgdGhpbmcgd2UgZG9cbiAgaWYgKCFwZi5zdXBQaWN0dXJlKSB7XG4gICAgdHlwZXNbXCJpbWFnZS93ZWJwXCJdID0gZGV0ZWN0VHlwZVN1cHBvcnQoXG4gICAgICBcImltYWdlL3dlYnBcIixcbiAgICAgIFwiZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmtvQUFBQlhSVUpRVmxBNFdBb0FBQUFRQUFBQUFBQUFBQUFBUVV4UVNBd0FBQUFCQnhBUi9ROUVSUDhEQUFCV1VEZ2dHQUFBQURBQkFKMEJLZ0VBQVFBREFEUWxwQUFEY0FEKysvMVFBQT09XCJcbiAgICApO1xuICB9XG59KSh3aW5kb3csIGRvY3VtZW50KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3BpY3R1cmVmaWxsL2Rpc3QvcGljdHVyZWZpbGwuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIFdlYiBGb250IExvYWRlciB2MS42LjI4IC0gKGMpIEFkb2JlIFN5c3RlbXMsIEdvb2dsZS4gTGljZW5zZTogQXBhY2hlIDIuMCAqLyAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGFhKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCwgYXJndW1lbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBiYShhLCBiLCBjKSB7XG4gICAgaWYgKCFhKSB0aHJvdyBFcnJvcigpO1xuICAgIGlmICgyIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIGQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGMsIGQpO1xuICAgICAgICByZXR1cm4gYS5hcHBseShiLCBjKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhLmFwcGx5KGIsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBwKGEsIGIsIGMpIHtcbiAgICBwID1cbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICYmXG4gICAgICAtMSAhPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoXCJuYXRpdmUgY29kZVwiKVxuICAgICAgICA/IGFhXG4gICAgICAgIDogYmE7XG4gICAgcmV0dXJuIHAuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuICB2YXIgcSA9XG4gICAgRGF0ZS5ub3cgfHxcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgICB9O1xuICBmdW5jdGlvbiBjYShhLCBiKSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLm8gPSBiIHx8IGE7XG4gICAgdGhpcy5jID0gdGhpcy5vLmRvY3VtZW50O1xuICB9XG4gIHZhciBkYSA9ICEhd2luZG93LkZvbnRGYWNlO1xuICBmdW5jdGlvbiB0KGEsIGIsIGMsIGQpIHtcbiAgICBiID0gYS5jLmNyZWF0ZUVsZW1lbnQoYik7XG4gICAgaWYgKGMpXG4gICAgICBmb3IgKHZhciBlIGluIGMpXG4gICAgICAgIGMuaGFzT3duUHJvcGVydHkoZSkgJiZcbiAgICAgICAgICAoXCJzdHlsZVwiID09IGUgPyAoYi5zdHlsZS5jc3NUZXh0ID0gY1tlXSkgOiBiLnNldEF0dHJpYnV0ZShlLCBjW2VdKSk7XG4gICAgZCAmJiBiLmFwcGVuZENoaWxkKGEuYy5jcmVhdGVUZXh0Tm9kZShkKSk7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgZnVuY3Rpb24gdShhLCBiLCBjKSB7XG4gICAgYSA9IGEuYy5nZXRFbGVtZW50c0J5VGFnTmFtZShiKVswXTtcbiAgICBhIHx8IChhID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICBhLmluc2VydEJlZm9yZShjLCBhLmxhc3RDaGlsZCk7XG4gIH1cbiAgZnVuY3Rpb24gdihhKSB7XG4gICAgYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTtcbiAgfVxuICBmdW5jdGlvbiB3KGEsIGIsIGMpIHtcbiAgICBiID0gYiB8fCBbXTtcbiAgICBjID0gYyB8fCBbXTtcbiAgICBmb3IgKHZhciBkID0gYS5jbGFzc05hbWUuc3BsaXQoL1xccysvKSwgZSA9IDA7IGUgPCBiLmxlbmd0aDsgZSArPSAxKSB7XG4gICAgICBmb3IgKHZhciBmID0gITEsIGcgPSAwOyBnIDwgZC5sZW5ndGg7IGcgKz0gMSlcbiAgICAgICAgaWYgKGJbZV0gPT09IGRbZ10pIHtcbiAgICAgICAgICBmID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGYgfHwgZC5wdXNoKGJbZV0pO1xuICAgIH1cbiAgICBiID0gW107XG4gICAgZm9yIChlID0gMDsgZSA8IGQubGVuZ3RoOyBlICs9IDEpIHtcbiAgICAgIGYgPSAhMTtcbiAgICAgIGZvciAoZyA9IDA7IGcgPCBjLmxlbmd0aDsgZyArPSAxKVxuICAgICAgICBpZiAoZFtlXSA9PT0gY1tnXSkge1xuICAgICAgICAgIGYgPSAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZiB8fCBiLnB1c2goZFtlXSk7XG4gICAgfVxuICAgIGEuY2xhc3NOYW1lID0gYlxuICAgICAgLmpvaW4oXCIgXCIpXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCBcIiBcIilcbiAgICAgIC5yZXBsYWNlKC9eXFxzK3xcXHMrJC8sIFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHkoYSwgYikge1xuICAgIGZvciAodmFyIGMgPSBhLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLCBkID0gMCwgZSA9IGMubGVuZ3RoOyBkIDwgZTsgZCsrKVxuICAgICAgaWYgKGNbZF0gPT0gYikgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBlYShhKSB7XG4gICAgcmV0dXJuIGEuby5sb2NhdGlvbi5ob3N0bmFtZSB8fCBhLmEubG9jYXRpb24uaG9zdG5hbWU7XG4gIH1cbiAgZnVuY3Rpb24geihhLCBiLCBjKSB7XG4gICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgIG0gJiYgZSAmJiBmICYmIChtKGcpLCAobSA9IG51bGwpKTtcbiAgICB9XG4gICAgYiA9IHQoYSwgXCJsaW5rXCIsIHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZjogYiwgbWVkaWE6IFwiYWxsXCIgfSk7XG4gICAgdmFyIGUgPSAhMSxcbiAgICAgIGYgPSAhMCxcbiAgICAgIGcgPSBudWxsLFxuICAgICAgbSA9IGMgfHwgbnVsbDtcbiAgICBkYVxuICAgICAgPyAoKGIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZSA9ICEwO1xuICAgICAgICAgIGQoKTtcbiAgICAgICAgfSksXG4gICAgICAgIChiLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlID0gITA7XG4gICAgICAgICAgZyA9IEVycm9yKFwiU3R5bGVzaGVldCBmYWlsZWQgdG8gbG9hZFwiKTtcbiAgICAgICAgICBkKCk7XG4gICAgICAgIH0pKVxuICAgICAgOiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGUgPSAhMDtcbiAgICAgICAgICBkKCk7XG4gICAgICAgIH0sIDApO1xuICAgIHUoYSwgXCJoZWFkXCIsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIEEoYSwgYiwgYywgZCkge1xuICAgIHZhciBlID0gYS5jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgICBpZiAoZSkge1xuICAgICAgdmFyIGYgPSB0KGEsIFwic2NyaXB0XCIsIHsgc3JjOiBiIH0pLFxuICAgICAgICBnID0gITE7XG4gICAgICBmLm9ubG9hZCA9IGYub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGcgfHxcbiAgICAgICAgICAodGhpcy5yZWFkeVN0YXRlICYmXG4gICAgICAgICAgICBcImxvYWRlZFwiICE9IHRoaXMucmVhZHlTdGF0ZSAmJlxuICAgICAgICAgICAgXCJjb21wbGV0ZVwiICE9IHRoaXMucmVhZHlTdGF0ZSkgfHxcbiAgICAgICAgICAoKGcgPSAhMCksXG4gICAgICAgICAgYyAmJiBjKG51bGwpLFxuICAgICAgICAgIChmLm9ubG9hZCA9IGYub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbCksXG4gICAgICAgICAgXCJIRUFEXCIgPT0gZi5wYXJlbnROb2RlLnRhZ05hbWUgJiYgZS5yZW1vdmVDaGlsZChmKSk7XG4gICAgICB9O1xuICAgICAgZS5hcHBlbmRDaGlsZChmKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGcgfHwgKChnID0gITApLCBjICYmIGMoRXJyb3IoXCJTY3JpcHQgbG9hZCB0aW1lb3V0XCIpKSk7XG4gICAgICB9LCBkIHx8IDVlMyk7XG4gICAgICByZXR1cm4gZjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gQigpIHtcbiAgICB0aGlzLmEgPSAwO1xuICAgIHRoaXMuYyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gQyhhKSB7XG4gICAgYS5hKys7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgYS5hLS07XG4gICAgICBEKGEpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gRShhLCBiKSB7XG4gICAgYS5jID0gYjtcbiAgICBEKGEpO1xuICB9XG4gIGZ1bmN0aW9uIEQoYSkge1xuICAgIDAgPT0gYS5hICYmIGEuYyAmJiAoYS5jKCksIChhLmMgPSBudWxsKSk7XG4gIH1cbiAgZnVuY3Rpb24gRihhKSB7XG4gICAgdGhpcy5hID0gYSB8fCBcIi1cIjtcbiAgfVxuICBGLnByb3RvdHlwZS5jID0gZnVuY3Rpb24oYSkge1xuICAgIGZvciAodmFyIGIgPSBbXSwgYyA9IDA7IGMgPCBhcmd1bWVudHMubGVuZ3RoOyBjKyspXG4gICAgICBiLnB1c2goYXJndW1lbnRzW2NdLnJlcGxhY2UoL1tcXFdfXSsvZywgXCJcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgcmV0dXJuIGIuam9pbih0aGlzLmEpO1xuICB9O1xuICBmdW5jdGlvbiBHKGEsIGIpIHtcbiAgICB0aGlzLmMgPSBhO1xuICAgIHRoaXMuZiA9IDQ7XG4gICAgdGhpcy5hID0gXCJuXCI7XG4gICAgdmFyIGMgPSAoYiB8fCBcIm40XCIpLm1hdGNoKC9eKFtuaW9dKShbMS05XSkkL2kpO1xuICAgIGMgJiYgKCh0aGlzLmEgPSBjWzFdKSwgKHRoaXMuZiA9IHBhcnNlSW50KGNbMl0sIDEwKSkpO1xuICB9XG4gIGZ1bmN0aW9uIGZhKGEpIHtcbiAgICByZXR1cm4gSChhKSArIFwiIFwiICsgKGEuZiArIFwiMDBcIikgKyBcIiAzMDBweCBcIiArIEkoYS5jKTtcbiAgfVxuICBmdW5jdGlvbiBJKGEpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGEgPSBhLnNwbGl0KC8sXFxzKi8pO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgYS5sZW5ndGg7IGMrKykge1xuICAgICAgdmFyIGQgPSBhW2NdLnJlcGxhY2UoL1snXCJdL2csIFwiXCIpO1xuICAgICAgLTEgIT0gZC5pbmRleE9mKFwiIFwiKSB8fCAvXlxcZC8udGVzdChkKSA/IGIucHVzaChcIidcIiArIGQgKyBcIidcIikgOiBiLnB1c2goZCk7XG4gICAgfVxuICAgIHJldHVybiBiLmpvaW4oXCIsXCIpO1xuICB9XG4gIGZ1bmN0aW9uIEooYSkge1xuICAgIHJldHVybiBhLmEgKyBhLmY7XG4gIH1cbiAgZnVuY3Rpb24gSChhKSB7XG4gICAgdmFyIGIgPSBcIm5vcm1hbFwiO1xuICAgIFwib1wiID09PSBhLmEgPyAoYiA9IFwib2JsaXF1ZVwiKSA6IFwiaVwiID09PSBhLmEgJiYgKGIgPSBcIml0YWxpY1wiKTtcbiAgICByZXR1cm4gYjtcbiAgfVxuICBmdW5jdGlvbiBnYShhKSB7XG4gICAgdmFyIGIgPSA0LFxuICAgICAgYyA9IFwiblwiLFxuICAgICAgZCA9IG51bGw7XG4gICAgYSAmJlxuICAgICAgKChkID0gYS5tYXRjaCgvKG5vcm1hbHxvYmxpcXVlfGl0YWxpYykvaSkpICYmXG4gICAgICAgIGRbMV0gJiZcbiAgICAgICAgKGMgPSBkWzFdLnN1YnN0cigwLCAxKS50b0xvd2VyQ2FzZSgpKSxcbiAgICAgIChkID0gYS5tYXRjaCgvKFsxLTldMDB8bm9ybWFsfGJvbGQpL2kpKSAmJlxuICAgICAgICBkWzFdICYmXG4gICAgICAgICgvYm9sZC9pLnRlc3QoZFsxXSlcbiAgICAgICAgICA/IChiID0gNylcbiAgICAgICAgICA6IC9bMS05XTAwLy50ZXN0KGRbMV0pICYmIChiID0gcGFyc2VJbnQoZFsxXS5zdWJzdHIoMCwgMSksIDEwKSkpKTtcbiAgICByZXR1cm4gYyArIGI7XG4gIH1cbiAgZnVuY3Rpb24gaGEoYSwgYikge1xuICAgIHRoaXMuYyA9IGE7XG4gICAgdGhpcy5mID0gYS5vLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB0aGlzLmggPSBiO1xuICAgIHRoaXMuYSA9IG5ldyBGKFwiLVwiKTtcbiAgICB0aGlzLmogPSAhMSAhPT0gYi5ldmVudHM7XG4gICAgdGhpcy5nID0gITEgIT09IGIuY2xhc3NlcztcbiAgfVxuICBmdW5jdGlvbiBpYShhKSB7XG4gICAgYS5nICYmIHcoYS5mLCBbYS5hLmMoXCJ3ZlwiLCBcImxvYWRpbmdcIildKTtcbiAgICBLKGEsIFwibG9hZGluZ1wiKTtcbiAgfVxuICBmdW5jdGlvbiBMKGEpIHtcbiAgICBpZiAoYS5nKSB7XG4gICAgICB2YXIgYiA9IHkoYS5mLCBhLmEuYyhcIndmXCIsIFwiYWN0aXZlXCIpKSxcbiAgICAgICAgYyA9IFtdLFxuICAgICAgICBkID0gW2EuYS5jKFwid2ZcIiwgXCJsb2FkaW5nXCIpXTtcbiAgICAgIGIgfHwgYy5wdXNoKGEuYS5jKFwid2ZcIiwgXCJpbmFjdGl2ZVwiKSk7XG4gICAgICB3KGEuZiwgYywgZCk7XG4gICAgfVxuICAgIEsoYSwgXCJpbmFjdGl2ZVwiKTtcbiAgfVxuICBmdW5jdGlvbiBLKGEsIGIsIGMpIHtcbiAgICBpZiAoYS5qICYmIGEuaFtiXSlcbiAgICAgIGlmIChjKSBhLmhbYl0oYy5jLCBKKGMpKTtcbiAgICAgIGVsc2UgYS5oW2JdKCk7XG4gIH1cbiAgZnVuY3Rpb24gamEoKSB7XG4gICAgdGhpcy5jID0ge307XG4gIH1cbiAgZnVuY3Rpb24ga2EoYSwgYiwgYykge1xuICAgIHZhciBkID0gW10sXG4gICAgICBlO1xuICAgIGZvciAoZSBpbiBiKVxuICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkoZSkpIHtcbiAgICAgICAgdmFyIGYgPSBhLmNbZV07XG4gICAgICAgIGYgJiYgZC5wdXNoKGYoYltlXSwgYykpO1xuICAgICAgfVxuICAgIHJldHVybiBkO1xuICB9XG4gIGZ1bmN0aW9uIE0oYSwgYikge1xuICAgIHRoaXMuYyA9IGE7XG4gICAgdGhpcy5mID0gYjtcbiAgICB0aGlzLmEgPSB0KHRoaXMuYywgXCJzcGFuXCIsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9LCB0aGlzLmYpO1xuICB9XG4gIGZ1bmN0aW9uIE4oYSkge1xuICAgIHUoYS5jLCBcImJvZHlcIiwgYS5hKTtcbiAgfVxuICBmdW5jdGlvbiBPKGEpIHtcbiAgICByZXR1cm4gKFxuICAgICAgXCJkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3RvcDotOTk5OXB4O2xlZnQ6LTk5OTlweDtmb250LXNpemU6MzAwcHg7d2lkdGg6YXV0bztoZWlnaHQ6YXV0bztsaW5lLWhlaWdodDpub3JtYWw7bWFyZ2luOjA7cGFkZGluZzowO2ZvbnQtdmFyaWFudDpub3JtYWw7d2hpdGUtc3BhY2U6bm93cmFwO2ZvbnQtZmFtaWx5OlwiICtcbiAgICAgIEkoYS5jKSArXG4gICAgICBcIjtcIiArXG4gICAgICAoXCJmb250LXN0eWxlOlwiICsgSChhKSArIFwiO2ZvbnQtd2VpZ2h0OlwiICsgKGEuZiArIFwiMDBcIikgKyBcIjtcIilcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIFAoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuZyA9IGE7XG4gICAgdGhpcy5qID0gYjtcbiAgICB0aGlzLmEgPSBkO1xuICAgIHRoaXMuYyA9IGM7XG4gICAgdGhpcy5mID0gZSB8fCAzZTM7XG4gICAgdGhpcy5oID0gZiB8fCB2b2lkIDA7XG4gIH1cbiAgUC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IHRoaXMuYy5vLmRvY3VtZW50LFxuICAgICAgYiA9IHRoaXMsXG4gICAgICBjID0gcSgpLFxuICAgICAgZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGQsIGUpIHtcbiAgICAgICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgICBxKCkgLSBjID49IGIuZlxuICAgICAgICAgICAgPyBlKClcbiAgICAgICAgICAgIDogYS5mb250cy5sb2FkKGZhKGIuYSksIGIuaCkudGhlbihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAxIDw9IGEubGVuZ3RoID8gZCgpIDogc2V0VGltZW91dChmLCAyNSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZigpO1xuICAgICAgfSksXG4gICAgICBlID0gbnVsbCxcbiAgICAgIGYgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihhLCBkKSB7XG4gICAgICAgIGUgPSBzZXRUaW1lb3V0KGQsIGIuZik7XG4gICAgICB9KTtcbiAgICBQcm9taXNlLnJhY2UoW2YsIGRdKS50aGVuKFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIGUgJiYgKGNsZWFyVGltZW91dChlKSwgKGUgPSBudWxsKSk7XG4gICAgICAgIGIuZyhiLmEpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBiLmooYi5hKTtcbiAgICAgIH1cbiAgICApO1xuICB9O1xuICBmdW5jdGlvbiBRKGEsIGIsIGMsIGQsIGUsIGYsIGcpIHtcbiAgICB0aGlzLnYgPSBhO1xuICAgIHRoaXMuQiA9IGI7XG4gICAgdGhpcy5jID0gYztcbiAgICB0aGlzLmEgPSBkO1xuICAgIHRoaXMucyA9IGcgfHwgXCJCRVNic3d5XCI7XG4gICAgdGhpcy5mID0ge307XG4gICAgdGhpcy53ID0gZSB8fCAzZTM7XG4gICAgdGhpcy51ID0gZiB8fCBudWxsO1xuICAgIHRoaXMubSA9IHRoaXMuaiA9IHRoaXMuaCA9IHRoaXMuZyA9IG51bGw7XG4gICAgdGhpcy5nID0gbmV3IE0odGhpcy5jLCB0aGlzLnMpO1xuICAgIHRoaXMuaCA9IG5ldyBNKHRoaXMuYywgdGhpcy5zKTtcbiAgICB0aGlzLmogPSBuZXcgTSh0aGlzLmMsIHRoaXMucyk7XG4gICAgdGhpcy5tID0gbmV3IE0odGhpcy5jLCB0aGlzLnMpO1xuICAgIGEgPSBuZXcgRyh0aGlzLmEuYyArIFwiLHNlcmlmXCIsIEoodGhpcy5hKSk7XG4gICAgYSA9IE8oYSk7XG4gICAgdGhpcy5nLmEuc3R5bGUuY3NzVGV4dCA9IGE7XG4gICAgYSA9IG5ldyBHKHRoaXMuYS5jICsgXCIsc2Fucy1zZXJpZlwiLCBKKHRoaXMuYSkpO1xuICAgIGEgPSBPKGEpO1xuICAgIHRoaXMuaC5hLnN0eWxlLmNzc1RleHQgPSBhO1xuICAgIGEgPSBuZXcgRyhcInNlcmlmXCIsIEoodGhpcy5hKSk7XG4gICAgYSA9IE8oYSk7XG4gICAgdGhpcy5qLmEuc3R5bGUuY3NzVGV4dCA9IGE7XG4gICAgYSA9IG5ldyBHKFwic2Fucy1zZXJpZlwiLCBKKHRoaXMuYSkpO1xuICAgIGEgPSBPKGEpO1xuICAgIHRoaXMubS5hLnN0eWxlLmNzc1RleHQgPSBhO1xuICAgIE4odGhpcy5nKTtcbiAgICBOKHRoaXMuaCk7XG4gICAgTih0aGlzLmopO1xuICAgIE4odGhpcy5tKTtcbiAgfVxuICB2YXIgUiA9IHsgRDogXCJzZXJpZlwiLCBDOiBcInNhbnMtc2VyaWZcIiB9LFxuICAgIFMgPSBudWxsO1xuICBmdW5jdGlvbiBUKCkge1xuICAgIGlmIChudWxsID09PSBTKSB7XG4gICAgICB2YXIgYSA9IC9BcHBsZVdlYktpdFxcLyhbMC05XSspKD86XFwuKFswLTldKykpLy5leGVjKFxuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgICAgKTtcbiAgICAgIFMgPVxuICAgICAgICAhIWEgJiZcbiAgICAgICAgKDUzNiA+IHBhcnNlSW50KGFbMV0sIDEwKSB8fFxuICAgICAgICAgICg1MzYgPT09IHBhcnNlSW50KGFbMV0sIDEwKSAmJiAxMSA+PSBwYXJzZUludChhWzJdLCAxMCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIFM7XG4gIH1cbiAgUS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmYuc2VyaWYgPSB0aGlzLmouYS5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmZbXCJzYW5zLXNlcmlmXCJdID0gdGhpcy5tLmEub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5BID0gcSgpO1xuICAgIFUodGhpcyk7XG4gIH07XG4gIGZ1bmN0aW9uIGxhKGEsIGIsIGMpIHtcbiAgICBmb3IgKHZhciBkIGluIFIpXG4gICAgICBpZiAoUi5oYXNPd25Qcm9wZXJ0eShkKSAmJiBiID09PSBhLmZbUltkXV0gJiYgYyA9PT0gYS5mW1JbZF1dKSByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIFUoYSkge1xuICAgIHZhciBiID0gYS5nLmEub2Zmc2V0V2lkdGgsXG4gICAgICBjID0gYS5oLmEub2Zmc2V0V2lkdGgsXG4gICAgICBkO1xuICAgIChkID0gYiA9PT0gYS5mLnNlcmlmICYmIGMgPT09IGEuZltcInNhbnMtc2VyaWZcIl0pIHx8XG4gICAgICAoZCA9IFQoKSAmJiBsYShhLCBiLCBjKSk7XG4gICAgZFxuICAgICAgPyBxKCkgLSBhLkEgPj0gYS53XG4gICAgICAgID8gVCgpICYmIGxhKGEsIGIsIGMpICYmIChudWxsID09PSBhLnUgfHwgYS51Lmhhc093blByb3BlcnR5KGEuYS5jKSlcbiAgICAgICAgICA/IFYoYSwgYS52KVxuICAgICAgICAgIDogVihhLCBhLkIpXG4gICAgICAgIDogbWEoYSlcbiAgICAgIDogVihhLCBhLnYpO1xuICB9XG4gIGZ1bmN0aW9uIG1hKGEpIHtcbiAgICBzZXRUaW1lb3V0KFxuICAgICAgcChmdW5jdGlvbigpIHtcbiAgICAgICAgVSh0aGlzKTtcbiAgICAgIH0sIGEpLFxuICAgICAgNTBcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIFYoYSwgYikge1xuICAgIHNldFRpbWVvdXQoXG4gICAgICBwKGZ1bmN0aW9uKCkge1xuICAgICAgICB2KHRoaXMuZy5hKTtcbiAgICAgICAgdih0aGlzLmguYSk7XG4gICAgICAgIHYodGhpcy5qLmEpO1xuICAgICAgICB2KHRoaXMubS5hKTtcbiAgICAgICAgYih0aGlzLmEpO1xuICAgICAgfSwgYSksXG4gICAgICAwXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBXKGEsIGIsIGMpIHtcbiAgICB0aGlzLmMgPSBhO1xuICAgIHRoaXMuYSA9IGI7XG4gICAgdGhpcy5mID0gMDtcbiAgICB0aGlzLm0gPSB0aGlzLmogPSAhMTtcbiAgICB0aGlzLnMgPSBjO1xuICB9XG4gIHZhciBYID0gbnVsbDtcbiAgVy5wcm90b3R5cGUuZyA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgYiA9IHRoaXMuYTtcbiAgICBiLmcgJiZcbiAgICAgIHcoXG4gICAgICAgIGIuZixcbiAgICAgICAgW2IuYS5jKFwid2ZcIiwgYS5jLCBKKGEpLnRvU3RyaW5nKCksIFwiYWN0aXZlXCIpXSxcbiAgICAgICAgW1xuICAgICAgICAgIGIuYS5jKFwid2ZcIiwgYS5jLCBKKGEpLnRvU3RyaW5nKCksIFwibG9hZGluZ1wiKSxcbiAgICAgICAgICBiLmEuYyhcIndmXCIsIGEuYywgSihhKS50b1N0cmluZygpLCBcImluYWN0aXZlXCIpXG4gICAgICAgIF1cbiAgICAgICk7XG4gICAgSyhiLCBcImZvbnRhY3RpdmVcIiwgYSk7XG4gICAgdGhpcy5tID0gITA7XG4gICAgbmEodGhpcyk7XG4gIH07XG4gIFcucHJvdG90eXBlLmggPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIGIgPSB0aGlzLmE7XG4gICAgaWYgKGIuZykge1xuICAgICAgdmFyIGMgPSB5KGIuZiwgYi5hLmMoXCJ3ZlwiLCBhLmMsIEooYSkudG9TdHJpbmcoKSwgXCJhY3RpdmVcIikpLFxuICAgICAgICBkID0gW10sXG4gICAgICAgIGUgPSBbYi5hLmMoXCJ3ZlwiLCBhLmMsIEooYSkudG9TdHJpbmcoKSwgXCJsb2FkaW5nXCIpXTtcbiAgICAgIGMgfHwgZC5wdXNoKGIuYS5jKFwid2ZcIiwgYS5jLCBKKGEpLnRvU3RyaW5nKCksIFwiaW5hY3RpdmVcIikpO1xuICAgICAgdyhiLmYsIGQsIGUpO1xuICAgIH1cbiAgICBLKGIsIFwiZm9udGluYWN0aXZlXCIsIGEpO1xuICAgIG5hKHRoaXMpO1xuICB9O1xuICBmdW5jdGlvbiBuYShhKSB7XG4gICAgMCA9PSAtLWEuZiAmJlxuICAgICAgYS5qICYmXG4gICAgICAoYS5tXG4gICAgICAgID8gKChhID0gYS5hKSxcbiAgICAgICAgICBhLmcgJiZcbiAgICAgICAgICAgIHcoXG4gICAgICAgICAgICAgIGEuZixcbiAgICAgICAgICAgICAgW2EuYS5jKFwid2ZcIiwgXCJhY3RpdmVcIildLFxuICAgICAgICAgICAgICBbYS5hLmMoXCJ3ZlwiLCBcImxvYWRpbmdcIiksIGEuYS5jKFwid2ZcIiwgXCJpbmFjdGl2ZVwiKV1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgSyhhLCBcImFjdGl2ZVwiKSlcbiAgICAgICAgOiBMKGEuYSkpO1xuICB9XG4gIGZ1bmN0aW9uIG9hKGEpIHtcbiAgICB0aGlzLmogPSBhO1xuICAgIHRoaXMuYSA9IG5ldyBqYSgpO1xuICAgIHRoaXMuaCA9IDA7XG4gICAgdGhpcy5mID0gdGhpcy5nID0gITA7XG4gIH1cbiAgb2EucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihhKSB7XG4gICAgdGhpcy5jID0gbmV3IGNhKHRoaXMuaiwgYS5jb250ZXh0IHx8IHRoaXMuaik7XG4gICAgdGhpcy5nID0gITEgIT09IGEuZXZlbnRzO1xuICAgIHRoaXMuZiA9ICExICE9PSBhLmNsYXNzZXM7XG4gICAgcGEodGhpcywgbmV3IGhhKHRoaXMuYywgYSksIGEpO1xuICB9O1xuICBmdW5jdGlvbiBxYShhLCBiLCBjLCBkLCBlKSB7XG4gICAgdmFyIGYgPSAwID09IC0tYS5oO1xuICAgIChhLmYgfHwgYS5nKSAmJlxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSBlIHx8IG51bGwsXG4gICAgICAgICAgbSA9IGQgfHwgbnVsbCB8fCB7fTtcbiAgICAgICAgaWYgKDAgPT09IGMubGVuZ3RoICYmIGYpIEwoYi5hKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYi5mICs9IGMubGVuZ3RoO1xuICAgICAgICAgIGYgJiYgKGIuaiA9IGYpO1xuICAgICAgICAgIHZhciBoLFxuICAgICAgICAgICAgbCA9IFtdO1xuICAgICAgICAgIGZvciAoaCA9IDA7IGggPCBjLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgICAgICB2YXIgayA9IGNbaF0sXG4gICAgICAgICAgICAgIG4gPSBtW2suY10sXG4gICAgICAgICAgICAgIHIgPSBiLmEsXG4gICAgICAgICAgICAgIHggPSBrO1xuICAgICAgICAgICAgci5nICYmIHcoci5mLCBbci5hLmMoXCJ3ZlwiLCB4LmMsIEooeCkudG9TdHJpbmcoKSwgXCJsb2FkaW5nXCIpXSk7XG4gICAgICAgICAgICBLKHIsIFwiZm9udGxvYWRpbmdcIiwgeCk7XG4gICAgICAgICAgICByID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBYKVxuICAgICAgICAgICAgICBpZiAod2luZG93LkZvbnRGYWNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSAvR2Vja28uKkZpcmVmb3hcXC8oXFxkKykvLmV4ZWMoXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50XG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgeGEgPVxuICAgICAgICAgICAgICAgICAgICAvT1MgWC4qVmVyc2lvblxcLzEwXFwuLipTYWZhcmkvLmV4ZWMoXG4gICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgICAgICAgICAgICAgICAgKSAmJiAvQXBwbGUvLmV4ZWMod2luZG93Lm5hdmlnYXRvci52ZW5kb3IpO1xuICAgICAgICAgICAgICAgIFggPSB4ID8gNDIgPCBwYXJzZUludCh4WzFdLCAxMCkgOiB4YSA/ICExIDogITA7XG4gICAgICAgICAgICAgIH0gZWxzZSBYID0gITE7XG4gICAgICAgICAgICBYXG4gICAgICAgICAgICAgID8gKHIgPSBuZXcgUChwKGIuZywgYiksIHAoYi5oLCBiKSwgYi5jLCBrLCBiLnMsIG4pKVxuICAgICAgICAgICAgICA6IChyID0gbmV3IFEocChiLmcsIGIpLCBwKGIuaCwgYiksIGIuYywgaywgYi5zLCBhLCBuKSk7XG4gICAgICAgICAgICBsLnB1c2gocik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaCA9IDA7IGggPCBsLmxlbmd0aDsgaCsrKSBsW2hdLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICB9XG4gIGZ1bmN0aW9uIHBhKGEsIGIsIGMpIHtcbiAgICB2YXIgZCA9IFtdLFxuICAgICAgZSA9IGMudGltZW91dDtcbiAgICBpYShiKTtcbiAgICB2YXIgZCA9IGthKGEuYSwgYywgYS5jKSxcbiAgICAgIGYgPSBuZXcgVyhhLmMsIGIsIGUpO1xuICAgIGEuaCA9IGQubGVuZ3RoO1xuICAgIGIgPSAwO1xuICAgIGZvciAoYyA9IGQubGVuZ3RoOyBiIDwgYzsgYisrKVxuICAgICAgZFtiXS5sb2FkKGZ1bmN0aW9uKGIsIGQsIGMpIHtcbiAgICAgICAgcWEoYSwgZiwgYiwgZCwgYyk7XG4gICAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByYShhLCBiKSB7XG4gICAgdGhpcy5jID0gYTtcbiAgICB0aGlzLmEgPSBiO1xuICB9XG4gIHJhLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oYSkge1xuICAgIGZ1bmN0aW9uIGIoKSB7XG4gICAgICBpZiAoZltcIl9fbXRpX2ZudExzdFwiICsgZF0pIHtcbiAgICAgICAgdmFyIGMgPSBmW1wiX19tdGlfZm50THN0XCIgKyBkXSgpLFxuICAgICAgICAgIGUgPSBbXSxcbiAgICAgICAgICBoO1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIHZhciBrID0gY1tsXS5mb250ZmFtaWx5O1xuICAgICAgICAgICAgdm9pZCAwICE9IGNbbF0uZm9udFN0eWxlICYmIHZvaWQgMCAhPSBjW2xdLmZvbnRXZWlnaHRcbiAgICAgICAgICAgICAgPyAoKGggPSBjW2xdLmZvbnRTdHlsZSArIGNbbF0uZm9udFdlaWdodCksIGUucHVzaChuZXcgRyhrLCBoKSkpXG4gICAgICAgICAgICAgIDogZS5wdXNoKG5ldyBHKGspKTtcbiAgICAgICAgICB9XG4gICAgICAgIGEoZSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBiKCk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgdmFyIGMgPSB0aGlzLFxuICAgICAgZCA9IGMuYS5wcm9qZWN0SWQsXG4gICAgICBlID0gYy5hLnZlcnNpb247XG4gICAgaWYgKGQpIHtcbiAgICAgIHZhciBmID0gYy5jLm87XG4gICAgICBBKFxuICAgICAgICB0aGlzLmMsXG4gICAgICAgIChjLmEuYXBpIHx8IFwiaHR0cHM6Ly9mYXN0LmZvbnRzLm5ldC9qc2FwaVwiKSArXG4gICAgICAgICAgXCIvXCIgK1xuICAgICAgICAgIGQgK1xuICAgICAgICAgIFwiLmpzXCIgK1xuICAgICAgICAgIChlID8gXCI/dj1cIiArIGUgOiBcIlwiKSxcbiAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGVcbiAgICAgICAgICAgID8gYShbXSlcbiAgICAgICAgICAgIDogKChmW1wiX19Nb25vdHlwZUNvbmZpZ3VyYXRpb25fX1wiICsgZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy5hO1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgYigpKTtcbiAgICAgICAgfVxuICAgICAgKS5pZCA9XG4gICAgICAgIFwiX19Nb25vdHlwZUFQSVNjcmlwdF9fXCIgKyBkO1xuICAgIH0gZWxzZSBhKFtdKTtcbiAgfTtcbiAgZnVuY3Rpb24gc2EoYSwgYikge1xuICAgIHRoaXMuYyA9IGE7XG4gICAgdGhpcy5hID0gYjtcbiAgfVxuICBzYS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgYixcbiAgICAgIGMsXG4gICAgICBkID0gdGhpcy5hLnVybHMgfHwgW10sXG4gICAgICBlID0gdGhpcy5hLmZhbWlsaWVzIHx8IFtdLFxuICAgICAgZiA9IHRoaXMuYS50ZXN0U3RyaW5ncyB8fCB7fSxcbiAgICAgIGcgPSBuZXcgQigpO1xuICAgIGIgPSAwO1xuICAgIGZvciAoYyA9IGQubGVuZ3RoOyBiIDwgYzsgYisrKSB6KHRoaXMuYywgZFtiXSwgQyhnKSk7XG4gICAgdmFyIG0gPSBbXTtcbiAgICBiID0gMDtcbiAgICBmb3IgKGMgPSBlLmxlbmd0aDsgYiA8IGM7IGIrKylcbiAgICAgIGlmICgoKGQgPSBlW2JdLnNwbGl0KFwiOlwiKSksIGRbMV0pKVxuICAgICAgICBmb3IgKHZhciBoID0gZFsxXS5zcGxpdChcIixcIiksIGwgPSAwOyBsIDwgaC5sZW5ndGg7IGwgKz0gMSlcbiAgICAgICAgICBtLnB1c2gobmV3IEcoZFswXSwgaFtsXSkpO1xuICAgICAgZWxzZSBtLnB1c2gobmV3IEcoZFswXSkpO1xuICAgIEUoZywgZnVuY3Rpb24oKSB7XG4gICAgICBhKG0sIGYpO1xuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiB0YShhLCBiKSB7XG4gICAgYSA/ICh0aGlzLmMgPSBhKSA6ICh0aGlzLmMgPSB1YSk7XG4gICAgdGhpcy5hID0gW107XG4gICAgdGhpcy5mID0gW107XG4gICAgdGhpcy5nID0gYiB8fCBcIlwiO1xuICB9XG4gIHZhciB1YSA9IFwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3NcIjtcbiAgZnVuY3Rpb24gdmEoYSwgYikge1xuICAgIGZvciAodmFyIGMgPSBiLmxlbmd0aCwgZCA9IDA7IGQgPCBjOyBkKyspIHtcbiAgICAgIHZhciBlID0gYltkXS5zcGxpdChcIjpcIik7XG4gICAgICAzID09IGUubGVuZ3RoICYmIGEuZi5wdXNoKGUucG9wKCkpO1xuICAgICAgdmFyIGYgPSBcIlwiO1xuICAgICAgMiA9PSBlLmxlbmd0aCAmJiBcIlwiICE9IGVbMV0gJiYgKGYgPSBcIjpcIik7XG4gICAgICBhLmEucHVzaChlLmpvaW4oZikpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3YShhKSB7XG4gICAgaWYgKDAgPT0gYS5hLmxlbmd0aCkgdGhyb3cgRXJyb3IoXCJObyBmb250cyB0byBsb2FkIVwiKTtcbiAgICBpZiAoLTEgIT0gYS5jLmluZGV4T2YoXCJraXQ9XCIpKSByZXR1cm4gYS5jO1xuICAgIGZvciAodmFyIGIgPSBhLmEubGVuZ3RoLCBjID0gW10sIGQgPSAwOyBkIDwgYjsgZCsrKVxuICAgICAgYy5wdXNoKGEuYVtkXS5yZXBsYWNlKC8gL2csIFwiK1wiKSk7XG4gICAgYiA9IGEuYyArIFwiP2ZhbWlseT1cIiArIGMuam9pbihcIiU3Q1wiKTtcbiAgICAwIDwgYS5mLmxlbmd0aCAmJiAoYiArPSBcIiZzdWJzZXQ9XCIgKyBhLmYuam9pbihcIixcIikpO1xuICAgIDAgPCBhLmcubGVuZ3RoICYmIChiICs9IFwiJnRleHQ9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYS5nKSk7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgZnVuY3Rpb24geWEoYSkge1xuICAgIHRoaXMuZiA9IGE7XG4gICAgdGhpcy5hID0gW107XG4gICAgdGhpcy5jID0ge307XG4gIH1cbiAgdmFyIHphID0ge1xuICAgICAgbGF0aW46IFwiQkVTYnN3eVwiLFxuICAgICAgXCJsYXRpbi1leHRcIjogXCJcXHUwMGU3XFx1MDBmNlxcdTAwZmNcXHUwMTFmXFx1MDE1ZlwiLFxuICAgICAgY3lyaWxsaWM6IFwiXFx1MDQzOVxcdTA0NGZcXHUwNDE2XCIsXG4gICAgICBncmVlazogXCJcXHUwM2IxXFx1MDNiMlxcdTAzYTNcIixcbiAgICAgIGtobWVyOiBcIlxcdTE3ODBcXHUxNzgxXFx1MTc4MlwiLFxuICAgICAgSGFudW1hbjogXCJcXHUxNzgwXFx1MTc4MVxcdTE3ODJcIlxuICAgIH0sXG4gICAgQWEgPSB7XG4gICAgICB0aGluOiBcIjFcIixcbiAgICAgIGV4dHJhbGlnaHQ6IFwiMlwiLFxuICAgICAgXCJleHRyYS1saWdodFwiOiBcIjJcIixcbiAgICAgIHVsdHJhbGlnaHQ6IFwiMlwiLFxuICAgICAgXCJ1bHRyYS1saWdodFwiOiBcIjJcIixcbiAgICAgIGxpZ2h0OiBcIjNcIixcbiAgICAgIHJlZ3VsYXI6IFwiNFwiLFxuICAgICAgYm9vazogXCI0XCIsXG4gICAgICBtZWRpdW06IFwiNVwiLFxuICAgICAgXCJzZW1pLWJvbGRcIjogXCI2XCIsXG4gICAgICBzZW1pYm9sZDogXCI2XCIsXG4gICAgICBcImRlbWktYm9sZFwiOiBcIjZcIixcbiAgICAgIGRlbWlib2xkOiBcIjZcIixcbiAgICAgIGJvbGQ6IFwiN1wiLFxuICAgICAgXCJleHRyYS1ib2xkXCI6IFwiOFwiLFxuICAgICAgZXh0cmFib2xkOiBcIjhcIixcbiAgICAgIFwidWx0cmEtYm9sZFwiOiBcIjhcIixcbiAgICAgIHVsdHJhYm9sZDogXCI4XCIsXG4gICAgICBibGFjazogXCI5XCIsXG4gICAgICBoZWF2eTogXCI5XCIsXG4gICAgICBsOiBcIjNcIixcbiAgICAgIHI6IFwiNFwiLFxuICAgICAgYjogXCI3XCJcbiAgICB9LFxuICAgIEJhID0geyBpOiBcImlcIiwgaXRhbGljOiBcImlcIiwgbjogXCJuXCIsIG5vcm1hbDogXCJuXCIgfSxcbiAgICBDYSA9IC9eKHRoaW58KD86KD86ZXh0cmF8dWx0cmEpLT8pP2xpZ2h0fHJlZ3VsYXJ8Ym9va3xtZWRpdW18KD86KD86c2VtaXxkZW1pfGV4dHJhfHVsdHJhKS0/KT9ib2xkfGJsYWNrfGhlYXZ5fGx8cnxifFsxLTldMDApPyhufGl8bm9ybWFsfGl0YWxpYyk/JC87XG4gIGZ1bmN0aW9uIERhKGEpIHtcbiAgICBmb3IgKHZhciBiID0gYS5mLmxlbmd0aCwgYyA9IDA7IGMgPCBiOyBjKyspIHtcbiAgICAgIHZhciBkID0gYS5mW2NdLnNwbGl0KFwiOlwiKSxcbiAgICAgICAgZSA9IGRbMF0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKSxcbiAgICAgICAgZiA9IFtcIm40XCJdO1xuICAgICAgaWYgKDIgPD0gZC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGc7XG4gICAgICAgIHZhciBtID0gZFsxXTtcbiAgICAgICAgZyA9IFtdO1xuICAgICAgICBpZiAobSlcbiAgICAgICAgICBmb3IgKHZhciBtID0gbS5zcGxpdChcIixcIiksIGggPSBtLmxlbmd0aCwgbCA9IDA7IGwgPCBoOyBsKyspIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgayA9IG1bbF07XG4gICAgICAgICAgICBpZiAoay5tYXRjaCgvXltcXHctXSskLykpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBDYS5leGVjKGsudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgIGlmIChudWxsID09IG4pIGsgPSBcIlwiO1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrID0gblsyXTtcbiAgICAgICAgICAgICAgICBrID0gbnVsbCA9PSBrIHx8IFwiXCIgPT0gayA/IFwiblwiIDogQmFba107XG4gICAgICAgICAgICAgICAgbiA9IG5bMV07XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gbiB8fCBcIlwiID09IG4pIG4gPSBcIjRcIjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICB2YXIgciA9IEFhW25dLFxuICAgICAgICAgICAgICAgICAgICBuID0gciA/IHIgOiBpc05hTihuKSA/IFwiNFwiIDogbi5zdWJzdHIoMCwgMSk7XG4gICAgICAgICAgICAgICAgayA9IFtrLCBuXS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgayA9IFwiXCI7XG4gICAgICAgICAgICBrICYmIGcucHVzaChrKTtcbiAgICAgICAgICB9XG4gICAgICAgIDAgPCBnLmxlbmd0aCAmJiAoZiA9IGcpO1xuICAgICAgICAzID09IGQubGVuZ3RoICYmXG4gICAgICAgICAgKChkID0gZFsyXSksXG4gICAgICAgICAgKGcgPSBbXSksXG4gICAgICAgICAgKGQgPSBkID8gZC5zcGxpdChcIixcIikgOiBnKSxcbiAgICAgICAgICAwIDwgZC5sZW5ndGggJiYgKGQgPSB6YVtkWzBdXSkgJiYgKGEuY1tlXSA9IGQpKTtcbiAgICAgIH1cbiAgICAgIGEuY1tlXSB8fCAoKGQgPSB6YVtlXSkgJiYgKGEuY1tlXSA9IGQpKTtcbiAgICAgIGZvciAoZCA9IDA7IGQgPCBmLmxlbmd0aDsgZCArPSAxKSBhLmEucHVzaChuZXcgRyhlLCBmW2RdKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIEVhKGEsIGIpIHtcbiAgICB0aGlzLmMgPSBhO1xuICAgIHRoaXMuYSA9IGI7XG4gIH1cbiAgdmFyIEZhID0geyBBcmltbzogITAsIENvdXNpbmU6ICEwLCBUaW5vczogITAgfTtcbiAgRWEucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIGIgPSBuZXcgQigpLFxuICAgICAgYyA9IHRoaXMuYyxcbiAgICAgIGQgPSBuZXcgdGEodGhpcy5hLmFwaSwgdGhpcy5hLnRleHQpLFxuICAgICAgZSA9IHRoaXMuYS5mYW1pbGllcztcbiAgICB2YShkLCBlKTtcbiAgICB2YXIgZiA9IG5ldyB5YShlKTtcbiAgICBEYShmKTtcbiAgICB6KGMsIHdhKGQpLCBDKGIpKTtcbiAgICBFKGIsIGZ1bmN0aW9uKCkge1xuICAgICAgYShmLmEsIGYuYywgRmEpO1xuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBHYShhLCBiKSB7XG4gICAgdGhpcy5jID0gYTtcbiAgICB0aGlzLmEgPSBiO1xuICB9XG4gIEdhLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBiID0gdGhpcy5hLmlkLFxuICAgICAgYyA9IHRoaXMuYy5vO1xuICAgIGJcbiAgICAgID8gQShcbiAgICAgICAgICB0aGlzLmMsXG4gICAgICAgICAgKHRoaXMuYS5hcGkgfHwgXCJodHRwczovL3VzZS50eXBla2l0Lm5ldFwiKSArIFwiL1wiICsgYiArIFwiLmpzXCIsXG4gICAgICAgICAgZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgaWYgKGIpIGEoW10pO1xuICAgICAgICAgICAgZWxzZSBpZiAoYy5UeXBla2l0ICYmIGMuVHlwZWtpdC5jb25maWcgJiYgYy5UeXBla2l0LmNvbmZpZy5mbikge1xuICAgICAgICAgICAgICBiID0gYy5UeXBla2l0LmNvbmZpZy5mbjtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZSA9IFtdLCBmID0gMDsgZiA8IGIubGVuZ3RoOyBmICs9IDIpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZyA9IGJbZl0sIG0gPSBiW2YgKyAxXSwgaCA9IDA7IGggPCBtLmxlbmd0aDsgaCsrKVxuICAgICAgICAgICAgICAgICAgZS5wdXNoKG5ldyBHKGcsIG1baF0pKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjLlR5cGVraXQubG9hZCh7IGV2ZW50czogITEsIGNsYXNzZXM6ICExLCBhc3luYzogITAgfSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGwpIHt9XG4gICAgICAgICAgICAgIGEoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAyZTNcbiAgICAgICAgKVxuICAgICAgOiBhKFtdKTtcbiAgfTtcbiAgZnVuY3Rpb24gSGEoYSwgYikge1xuICAgIHRoaXMuYyA9IGE7XG4gICAgdGhpcy5mID0gYjtcbiAgICB0aGlzLmEgPSBbXTtcbiAgfVxuICBIYS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgYiA9IHRoaXMuZi5pZCxcbiAgICAgIGMgPSB0aGlzLmMubyxcbiAgICAgIGQgPSB0aGlzO1xuICAgIGJcbiAgICAgID8gKGMuX193ZWJmb250Zm9udGRlY2ttb2R1bGVfXyB8fCAoYy5fX3dlYmZvbnRmb250ZGVja21vZHVsZV9fID0ge30pLFxuICAgICAgICAoYy5fX3dlYmZvbnRmb250ZGVja21vZHVsZV9fW2JdID0gZnVuY3Rpb24oYiwgYykge1xuICAgICAgICAgIGZvciAodmFyIGcgPSAwLCBtID0gYy5mb250cy5sZW5ndGg7IGcgPCBtOyArK2cpIHtcbiAgICAgICAgICAgIHZhciBoID0gYy5mb250c1tnXTtcbiAgICAgICAgICAgIGQuYS5wdXNoKFxuICAgICAgICAgICAgICBuZXcgRyhcbiAgICAgICAgICAgICAgICBoLm5hbWUsXG4gICAgICAgICAgICAgICAgZ2EoXCJmb250LXdlaWdodDpcIiArIGgud2VpZ2h0ICsgXCI7Zm9udC1zdHlsZTpcIiArIGguc3R5bGUpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGEoZC5hKTtcbiAgICAgICAgfSksXG4gICAgICAgIEEoXG4gICAgICAgICAgdGhpcy5jLFxuICAgICAgICAgICh0aGlzLmYuYXBpIHx8IFwiaHR0cHM6Ly9mLmZvbnRkZWNrLmNvbS9zL2Nzcy9qcy9cIikgK1xuICAgICAgICAgICAgZWEodGhpcy5jKSArXG4gICAgICAgICAgICBcIi9cIiArXG4gICAgICAgICAgICBiICtcbiAgICAgICAgICAgIFwiLmpzXCIsXG4gICAgICAgICAgZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgYiAmJiBhKFtdKTtcbiAgICAgICAgICB9XG4gICAgICAgICkpXG4gICAgICA6IGEoW10pO1xuICB9O1xuICB2YXIgWSA9IG5ldyBvYSh3aW5kb3cpO1xuICBZLmEuYy5jdXN0b20gPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIG5ldyBzYShiLCBhKTtcbiAgfTtcbiAgWS5hLmMuZm9udGRlY2sgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIG5ldyBIYShiLCBhKTtcbiAgfTtcbiAgWS5hLmMubW9ub3R5cGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIG5ldyByYShiLCBhKTtcbiAgfTtcbiAgWS5hLmMudHlwZWtpdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gbmV3IEdhKGIsIGEpO1xuICB9O1xuICBZLmEuYy5nb29nbGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIG5ldyBFYShiLCBhKTtcbiAgfTtcbiAgdmFyIFogPSB7IGxvYWQ6IHAoWS5sb2FkLCBZKSB9O1xuICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZFxuICAgID8gZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gWjtcbiAgICAgIH0pXG4gICAgOiBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzXG4gICAgICA/IChtb2R1bGUuZXhwb3J0cyA9IFopXG4gICAgICA6ICgod2luZG93LldlYkZvbnQgPSBaKSxcbiAgICAgICAgd2luZG93LldlYkZvbnRDb25maWcgJiYgWS5sb2FkKHdpbmRvdy5XZWJGb250Q29uZmlnKSk7XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvd2ViZm9udGxvYWRlci93ZWJmb250bG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgcmVzcG9uc2l2ZS1uYXYuanMgMS4wLjM5XG4gKiBodHRwczovL2dpdGh1Yi5jb20vdmlsamFtaXMvcmVzcG9uc2l2ZS1uYXYuanNcbiAqIGh0dHA6Ly9yZXNwb25zaXZlLW5hdi5jb21cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQHZpbGphbWlzXG4gKiBBdmFpbGFibGUgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cblxuLyogZ2xvYmFsIEV2ZW50ICovXG4oZnVuY3Rpb24oZG9jdW1lbnQsIHdpbmRvdywgaW5kZXgpIHtcbiAgLy8gSW5kZXggaXMgdXNlZCB0byBrZWVwIG11bHRpcGxlIG5hdnMgb24gdGhlIHNhbWUgcGFnZSBuYW1lc3BhY2VkXG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIHJlc3BvbnNpdmVOYXYgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgIHZhciBjb21wdXRlZCA9ICEhd2luZG93LmdldENvbXB1dGVkU3R5bGU7XG5cbiAgICAvKipcbiAgICAgKiBnZXRDb21wdXRlZFN0eWxlIHBvbHlmaWxsIGZvciBvbGQgYnJvd3NlcnNcbiAgICAgKi9cbiAgICBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5nZXRQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgIHZhciByZSA9IC8oXFwtKFthLXpdKXsxfSkvZztcbiAgICAgICAgICBpZiAocHJvcCA9PT0gXCJmbG9hdFwiKSB7XG4gICAgICAgICAgICBwcm9wID0gXCJzdHlsZUZsb2F0XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZS50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgICBwcm9wID0gcHJvcC5yZXBsYWNlKHJlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1syXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbC5jdXJyZW50U3R5bGVbcHJvcF0gPyBlbC5jdXJyZW50U3R5bGVbcHJvcF0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuICAgIC8qIGV4cG9ydGVkIGFkZEV2ZW50LCByZW1vdmVFdmVudCwgZ2V0Q2hpbGRyZW4sIHNldEF0dHJpYnV0ZXMsIGFkZENsYXNzLCByZW1vdmVDbGFzcywgZm9yRWFjaCAqL1xuXG4gICAgLyoqXG4gICAgICogQWRkIEV2ZW50XG4gICAgICogZm4gYXJnIGNhbiBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgdGhhbmtzIHRvIGhhbmRsZUV2ZW50XG4gICAgICogcmVhZCBtb3JlIGF0OiBodHRwOi8vd3d3LnRoZWNzc25pbmphLmNvbS9qYXZhc2NyaXB0L2hhbmRsZWV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtlbGVtZW50fSAgZWxlbWVudFxuICAgICAqIEBwYXJhbSAge2V2ZW50fSAgICBldmVudFxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmblxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBidWJibGluZ1xuICAgICAqL1xuICAgIHZhciBhZGRFdmVudCA9IGZ1bmN0aW9uKGVsLCBldnQsIGZuLCBidWJibGUpIHtcbiAgICAgICAgaWYgKFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIGVsKSB7XG4gICAgICAgICAgLy8gQkJPUzYgZG9lc24ndCBzdXBwb3J0IGhhbmRsZUV2ZW50LCBjYXRjaCBhbmQgcG9seWZpbGxcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGZuLCBidWJibGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwib2JqZWN0XCIgJiYgZm4uaGFuZGxlRXZlbnQpIHtcbiAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICBldnQsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgLy8gQmluZCBmbiBhcyB0aGlzIGFuZCBzZXQgZmlyc3QgYXJnIGFzIGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgICAgZm4uaGFuZGxlRXZlbnQuY2FsbChmbiwgZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBidWJibGVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFwiYXR0YWNoRXZlbnRcIiBpbiBlbCkge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjYWxsYmFjayBpcyBhbiBvYmplY3QgYW5kIGNvbnRhaW5zIGhhbmRsZUV2ZW50XG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJvYmplY3RcIiAmJiBmbi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZ0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gQmluZCBmbiBhcyB0aGlzXG4gICAgICAgICAgICAgIGZuLmhhbmRsZUV2ZW50LmNhbGwoZm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KFwib25cIiArIGV2dCwgZm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIEV2ZW50XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7ZWxlbWVudH0gIGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSAge2V2ZW50fSAgICBldmVudFxuICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuXG4gICAgICAgKiBAcGFyYW0gIHtib29sZWFufSAgYnViYmxpbmdcbiAgICAgICAqL1xuICAgICAgcmVtb3ZlRXZlbnQgPSBmdW5jdGlvbihlbCwgZXZ0LCBmbiwgYnViYmxlKSB7XG4gICAgICAgIGlmIChcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiBpbiBlbCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgZm4sIGJ1YmJsZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJvYmplY3RcIiAmJiBmbi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAgIGV2dCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICBmbi5oYW5kbGVFdmVudC5jYWxsKGZuLCBlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJ1YmJsZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXCJkZXRhY2hFdmVudFwiIGluIGVsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJvYmplY3RcIiAmJiBmbi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoXCJvblwiICsgZXZ0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZm4uaGFuZGxlRXZlbnQuY2FsbChmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoXCJvblwiICsgZXZ0LCBmbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBHZXQgdGhlIGNoaWxkcmVuIG9mIGFueSBlbGVtZW50XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7ZWxlbWVudH1cbiAgICAgICAqIEByZXR1cm4ge2FycmF5fSBSZXR1cm5zIG1hdGNoaW5nIGVsZW1lbnRzIGluIGFuIGFycmF5XG4gICAgICAgKi9cbiAgICAgIGdldENoaWxkcmVuID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5jaGlsZHJlbi5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIE5hdiBjb250YWluZXIgaGFzIG5vIGNvbnRhaW5pbmcgZWxlbWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgYWxsIGNoaWxkcmVuIGluIGFycmF5XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYW5kIHN0b3JlIGluIGFycmF5IGlmIGNoaWxkICE9IFRleHROb2RlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmNoaWxkcmVuW2ldLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGUuY2hpbGRyZW5baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIG11bHRpcGxlIGF0dHJpYnV0ZXMgYXQgb25jZVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudFxuICAgICAgICogQHBhcmFtIHthdHRyc30gICBhdHRyc1xuICAgICAgICovXG4gICAgICBzZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oZWwsIGF0dHJzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGEgY2xhc3MgdG8gYW55IGVsZW1lbnRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgY2xhc3NcbiAgICAgICAqL1xuICAgICAgYWRkQ2xhc3MgPSBmdW5jdGlvbihlbCwgY2xzKSB7XG4gICAgICAgIGlmIChlbC5jbGFzc05hbWUuaW5kZXhPZihjbHMpICE9PSAwKSB7XG4gICAgICAgICAgZWwuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xzO1xuICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKC8oXlxccyopfChcXHMqJCkvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhIGNsYXNzIGZyb20gYW55IGVsZW1lbnRcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gIHtlbGVtZW50fSBlbGVtZW50XG4gICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBjbGFzc1xuICAgICAgICovXG4gICAgICByZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGVsLCBjbHMpIHtcbiAgICAgICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoXFxcXHN8XilcIiArIGNscyArIFwiKFxcXFxzfCQpXCIpO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWVcbiAgICAgICAgICAucmVwbGFjZShyZWcsIFwiIFwiKVxuICAgICAgICAgIC5yZXBsYWNlKC8oXlxccyopfChcXHMqJCkvZywgXCJcIik7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBmb3JFYWNoIG1ldGhvZCB0aGF0IHBhc3NlcyBiYWNrIHRoZSBzdHVmZiB3ZSBuZWVkXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7YXJyYXl9ICAgIGFycmF5XG4gICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAqIEBwYXJhbSAge3Njb3BlfSAgICBzY29wZVxuICAgICAgICovXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChzY29wZSwgaSwgYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgdmFyIG5hdixcbiAgICAgIG9wdHMsXG4gICAgICBuYXZUb2dnbGUsXG4gICAgICBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiksXG4gICAgICBodG1sRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBoYXNBbmltRmluaXNoZWQsXG4gICAgICBpc01vYmlsZSxcbiAgICAgIG5hdk9wZW47XG5cbiAgICB2YXIgUmVzcG9uc2l2ZU5hdiA9IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWZhdWx0IG9wdGlvbnNcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgYW5pbWF0ZTogdHJ1ZSwgLy8gQm9vbGVhbjogVXNlIENTUzMgdHJhbnNpdGlvbnMsIHRydWUgb3IgZmFsc2VcbiAgICAgICAgdHJhbnNpdGlvbjogMjg0LCAvLyBJbnRlZ2VyOiBTcGVlZCBvZiB0aGUgdHJhbnNpdGlvbiwgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgIGxhYmVsOiBcIk1lbnVcIiwgLy8gU3RyaW5nOiBMYWJlbCBmb3IgdGhlIG5hdmlnYXRpb24gdG9nZ2xlXG4gICAgICAgIGluc2VydDogXCJiZWZvcmVcIiwgLy8gU3RyaW5nOiBJbnNlcnQgdGhlIHRvZ2dsZSBiZWZvcmUgb3IgYWZ0ZXIgdGhlIG5hdmlnYXRpb25cbiAgICAgICAgY3VzdG9tVG9nZ2xlOiBcIlwiLCAvLyBTZWxlY3RvcjogU3BlY2lmeSB0aGUgSUQgb2YgYSBjdXN0b20gdG9nZ2xlXG4gICAgICAgIGNsb3NlT25OYXZDbGljazogZmFsc2UsIC8vIEJvb2xlYW46IENsb3NlIHRoZSBuYXZpZ2F0aW9uIHdoZW4gb25lIG9mIHRoZSBsaW5rcyBhcmUgY2xpY2tlZFxuICAgICAgICBvcGVuUG9zOiBcInJlbGF0aXZlXCIsIC8vIFN0cmluZzogUG9zaXRpb24gb2YgdGhlIG9wZW5lZCBuYXYsIHJlbGF0aXZlIG9yIHN0YXRpY1xuICAgICAgICBuYXZDbGFzczogXCJuYXYtY29sbGFwc2VcIiwgLy8gU3RyaW5nOiBEZWZhdWx0IENTUyBjbGFzcy4gSWYgY2hhbmdlZCwgeW91IG5lZWQgdG8gZWRpdCB0aGUgQ1NTIHRvbyFcbiAgICAgICAgbmF2QWN0aXZlQ2xhc3M6IFwianMtbmF2LWFjdGl2ZVwiLCAvLyBTdHJpbmc6IENsYXNzIHRoYXQgaXMgYWRkZWQgdG8gPGh0bWw+IGVsZW1lbnQgd2hlbiBuYXYgaXMgYWN0aXZlXG4gICAgICAgIGpzQ2xhc3M6IFwianNcIiwgLy8gU3RyaW5nOiAnSlMgZW5hYmxlZCcgY2xhc3Mgd2hpY2ggaXMgYWRkZWQgdG8gPGh0bWw+IGVsZW1lbnRcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oKSB7fSwgLy8gRnVuY3Rpb246IEluaXQgY2FsbGJhY2tcbiAgICAgICAgb3BlbjogZnVuY3Rpb24oKSB7fSwgLy8gRnVuY3Rpb246IE9wZW4gY2FsbGJhY2tcbiAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge30gLy8gRnVuY3Rpb246IENsb3NlIGNhbGxiYWNrXG4gICAgICB9O1xuXG4gICAgICAvLyBVc2VyIGRlZmluZWQgb3B0aW9uc1xuICAgICAgZm9yIChpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkcyBcImpzXCIgY2xhc3MgZm9yIDxodG1sPlxuICAgICAgYWRkQ2xhc3MoaHRtbEVsLCB0aGlzLm9wdGlvbnMuanNDbGFzcyk7XG5cbiAgICAgIC8vIFdyYXBwZXJcbiAgICAgIHRoaXMud3JhcHBlckVsID0gZWwucmVwbGFjZShcIiNcIiwgXCJcIik7XG5cbiAgICAgIC8vIFRyeSBzZWxlY3RpbmcgSUQgZmlyc3RcbiAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLndyYXBwZXJFbCkpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy53cmFwcGVyRWwpO1xuXG4gICAgICAgIC8vIElmIGVsZW1lbnQgd2l0aCBhbiBJRCBkb2Vzbid0IGV4aXN0LCB1c2UgcXVlcnlTZWxlY3RvclxuICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMud3JhcHBlckVsKSkge1xuICAgICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMud3JhcHBlckVsKTtcblxuICAgICAgICAvLyBJZiBlbGVtZW50IGRvZXNuJ3QgZXhpc3RzLCBzdG9wIGhlcmUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJUaGUgbmF2IGVsZW1lbnQgeW91IGFyZSB0cnlpbmcgdG8gc2VsZWN0IGRvZXNuJ3QgZXhpc3RcIlxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBJbm5lciB3cmFwcGVyXG4gICAgICB0aGlzLndyYXBwZXIuaW5uZXIgPSBnZXRDaGlsZHJlbih0aGlzLndyYXBwZXIpO1xuXG4gICAgICAvLyBGb3IgbWluaWZpY2F0aW9uXG4gICAgICBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgbmF2ID0gdGhpcy53cmFwcGVyO1xuXG4gICAgICAvLyBJbml0XG4gICAgICB0aGlzLl9pbml0KHRoaXMpO1xuICAgIH07XG5cbiAgICBSZXNwb25zaXZlTmF2LnByb3RvdHlwZSA9IHtcbiAgICAgIC8qKlxuICAgICAgICogVW5hdHRhY2hlcyBldmVudHMgYW5kIHJlbW92ZXMgYW55IGNsYXNzZXMgdGhhdCB3ZXJlIGFkZGVkXG4gICAgICAgKi9cbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVTdHlsZXMoKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobmF2LCBcImNsb3NlZFwiKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobmF2LCBcIm9wZW5lZFwiKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobmF2LCBvcHRzLm5hdkNsYXNzKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MobmF2LCBvcHRzLm5hdkNsYXNzICsgXCItXCIgKyB0aGlzLmluZGV4KTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoaHRtbEVsLCBvcHRzLm5hdkFjdGl2ZUNsYXNzKTtcbiAgICAgICAgbmF2LnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgICAgICBuYXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIik7XG5cbiAgICAgICAgcmVtb3ZlRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUV2ZW50KHdpbmRvdywgXCJmb2N1c1wiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUV2ZW50KGRvY3VtZW50LmJvZHksIFwidG91Y2htb3ZlXCIsIHRoaXMsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlRXZlbnQobmF2VG9nZ2xlLCBcInRvdWNoc3RhcnRcIiwgdGhpcywgZmFsc2UpO1xuICAgICAgICByZW1vdmVFdmVudChuYXZUb2dnbGUsIFwidG91Y2hlbmRcIiwgdGhpcywgZmFsc2UpO1xuICAgICAgICByZW1vdmVFdmVudChuYXZUb2dnbGUsIFwibW91c2V1cFwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUV2ZW50KG5hdlRvZ2dsZSwgXCJrZXl1cFwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUV2ZW50KG5hdlRvZ2dsZSwgXCJjbGlja1wiLCB0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFvcHRzLmN1c3RvbVRvZ2dsZSkge1xuICAgICAgICAgIG5hdlRvZ2dsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5hdlRvZ2dsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmF2VG9nZ2xlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgdGhlIG5hdmlnYXRpb24gb3Blbi9jbG9zZVxuICAgICAgICovXG4gICAgICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoaGFzQW5pbUZpbmlzaGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKCFuYXZPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVucyB0aGUgbmF2aWdhdGlvblxuICAgICAgICovXG4gICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFuYXZPcGVuKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MobmF2LCBcImNsb3NlZFwiKTtcbiAgICAgICAgICBhZGRDbGFzcyhuYXYsIFwib3BlbmVkXCIpO1xuICAgICAgICAgIGFkZENsYXNzKGh0bWxFbCwgb3B0cy5uYXZBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgYWRkQ2xhc3MobmF2VG9nZ2xlLCBcImFjdGl2ZVwiKTtcbiAgICAgICAgICBuYXYuc3R5bGUucG9zaXRpb24gPSBvcHRzLm9wZW5Qb3M7XG4gICAgICAgICAgc2V0QXR0cmlidXRlcyhuYXYsIHsgXCJhcmlhLWhpZGRlblwiOiBcImZhbHNlXCIgfSk7XG4gICAgICAgICAgbmF2T3BlbiA9IHRydWU7XG4gICAgICAgICAgb3B0cy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2VzIHRoZSBuYXZpZ2F0aW9uXG4gICAgICAgKi9cbiAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG5hdk9wZW4pIHtcbiAgICAgICAgICBhZGRDbGFzcyhuYXYsIFwiY2xvc2VkXCIpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKG5hdiwgXCJvcGVuZWRcIik7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoaHRtbEVsLCBvcHRzLm5hdkFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyhuYXZUb2dnbGUsIFwiYWN0aXZlXCIpO1xuICAgICAgICAgIHNldEF0dHJpYnV0ZXMobmF2LCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSk7XG5cbiAgICAgICAgICAvLyBJZiBhbmltYXRpb25zIGFyZSBlbmFibGVkLCB3YWl0IHVudGlsIHRoZXkgZmluaXNoXG4gICAgICAgICAgaWYgKG9wdHMuYW5pbWF0ZSkge1xuICAgICAgICAgICAgaGFzQW5pbUZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBuYXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICAgIGhhc0FuaW1GaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9LCBvcHRzLnRyYW5zaXRpb24gKyAxMCk7XG5cbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbnMgYXJlbid0IGVuYWJsZWQsIHdlIGNhbiBkbyB0aGVzZSBpbW1lZGlhdGVseVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmF2T3BlbiA9IGZhbHNlO1xuICAgICAgICAgIG9wdHMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXNpemUgaXMgY2FsbGVkIG9uIHdpbmRvdyByZXNpemUgYW5kIG9yaWVudGF0aW9uIGNoYW5nZS5cbiAgICAgICAqIEl0IGluaXRpYWxpemVzIHRoZSBDU1Mgc3R5bGVzIGFuZCBoZWlnaHQgY2FsY3VsYXRpb25zLlxuICAgICAgICovXG4gICAgICByZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBSZXNpemUgd2F0Y2hlcyBuYXZpZ2F0aW9uIHRvZ2dsZSdzIGRpc3BsYXkgc3RhdGVcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHdpbmRvd1xuICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUobmF2VG9nZ2xlLCBudWxsKVxuICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpICE9PSBcIm5vbmVcIlxuICAgICAgICApIHtcbiAgICAgICAgICBpc01vYmlsZSA9IHRydWU7XG4gICAgICAgICAgc2V0QXR0cmlidXRlcyhuYXZUb2dnbGUsIHsgXCJhcmlhLWhpZGRlblwiOiBcImZhbHNlXCIgfSk7XG5cbiAgICAgICAgICAvLyBJZiB0aGUgbmF2aWdhdGlvbiBpcyBoaWRkZW5cbiAgICAgICAgICBpZiAobmF2LmNsYXNzTmFtZS5tYXRjaCgvKF58XFxzKWNsb3NlZChcXHN8JCkvKSkge1xuICAgICAgICAgICAgc2V0QXR0cmlidXRlcyhuYXYsIHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9KTtcbiAgICAgICAgICAgIG5hdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVTdHlsZXMoKTtcbiAgICAgICAgICB0aGlzLl9jYWxjSGVpZ2h0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNNb2JpbGUgPSBmYWxzZTtcbiAgICAgICAgICBzZXRBdHRyaWJ1dGVzKG5hdlRvZ2dsZSwgeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0pO1xuICAgICAgICAgIHNldEF0dHJpYnV0ZXMobmF2LCB7IFwiYXJpYS1oaWRkZW5cIjogXCJmYWxzZVwiIH0pO1xuICAgICAgICAgIG5hdi5zdHlsZS5wb3NpdGlvbiA9IG9wdHMub3BlblBvcztcbiAgICAgICAgICB0aGlzLl9yZW1vdmVTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUYWtlcyBjYXJlIG9mIGFsbCBldmVuIGhhbmRsaW5nXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7ZXZlbnR9IGV2ZW50XG4gICAgICAgKiBAcmV0dXJuIHt0eXBlfSByZXR1cm5zIHRoZSB0eXBlIG9mIGV2ZW50IHRoYXQgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAqL1xuICAgICAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGV2dCA9IGUgfHwgd2luZG93LmV2ZW50O1xuXG4gICAgICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidG91Y2hzdGFydFwiOlxuICAgICAgICAgICAgdGhpcy5fb25Ub3VjaFN0YXJ0KGV2dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG91Y2htb3ZlXCI6XG4gICAgICAgICAgICB0aGlzLl9vblRvdWNoTW92ZShldnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRvdWNoZW5kXCI6XG4gICAgICAgICAgY2FzZSBcIm1vdXNldXBcIjpcbiAgICAgICAgICAgIHRoaXMuX29uVG91Y2hFbmQoZXZ0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjbGlja1wiOlxuICAgICAgICAgICAgdGhpcy5fcHJldmVudERlZmF1bHQoZXZ0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgICAgICAgICAgdGhpcy5fb25LZXlVcChldnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImZvY3VzXCI6XG4gICAgICAgICAgY2FzZSBcInJlc2l6ZVwiOlxuICAgICAgICAgICAgdGhpcy5yZXNpemUoZXZ0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEluaXRpYWxpemVzIHRoZSB3aWRnZXRcbiAgICAgICAqL1xuICAgICAgX2luaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXgrKztcblxuICAgICAgICBhZGRDbGFzcyhuYXYsIG9wdHMubmF2Q2xhc3MpO1xuICAgICAgICBhZGRDbGFzcyhuYXYsIG9wdHMubmF2Q2xhc3MgKyBcIi1cIiArIHRoaXMuaW5kZXgpO1xuICAgICAgICBhZGRDbGFzcyhuYXYsIFwiY2xvc2VkXCIpO1xuICAgICAgICBoYXNBbmltRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBuYXZPcGVuID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fY2xvc2VPbk5hdkNsaWNrKCk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVRvZ2dsZSgpO1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9ucygpO1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbiBJRTggdGhlIHJlc2l6ZSBldmVudCB0cmlnZ2VycyB0b28gZWFybHkgZm9yIHNvbWUgcmVhc29uXG4gICAgICAgICAqIHNvIGl0J3MgY2FsbGVkIGhlcmUgYWdhaW4gb24gaW5pdCB0byBtYWtlIHN1cmUgYWxsIHRoZVxuICAgICAgICAgKiBjYWxjdWxhdGVkIHN0eWxlcyBhcmUgY29ycmVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBzZWxmLnJlc2l6ZSgpO1xuICAgICAgICB9LCAyMCk7XG5cbiAgICAgICAgYWRkRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIGFkZEV2ZW50KHdpbmRvdywgXCJmb2N1c1wiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIGFkZEV2ZW50KGRvY3VtZW50LmJvZHksIFwidG91Y2htb3ZlXCIsIHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYWRkRXZlbnQobmF2VG9nZ2xlLCBcInRvdWNoc3RhcnRcIiwgdGhpcywgZmFsc2UpO1xuICAgICAgICBhZGRFdmVudChuYXZUb2dnbGUsIFwidG91Y2hlbmRcIiwgdGhpcywgZmFsc2UpO1xuICAgICAgICBhZGRFdmVudChuYXZUb2dnbGUsIFwibW91c2V1cFwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIGFkZEV2ZW50KG5hdlRvZ2dsZSwgXCJrZXl1cFwiLCB0aGlzLCBmYWxzZSk7XG4gICAgICAgIGFkZEV2ZW50KG5hdlRvZ2dsZSwgXCJjbGlja1wiLCB0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXQgY2FsbGJhY2sgaGVyZVxuICAgICAgICAgKi9cbiAgICAgICAgb3B0cy5pbml0KCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgU3R5bGVzIHRvIHRoZSA8aGVhZD5cbiAgICAgICAqL1xuICAgICAgX2NyZWF0ZVN0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc3R5bGVFbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIHN0eWxlcyBmcm9tIHRoZSA8aGVhZD5cbiAgICAgICAqL1xuICAgICAgX3JlbW92ZVN0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBOYXZpZ2F0aW9uIFRvZ2dsZVxuICAgICAgICovXG4gICAgICBfY3JlYXRlVG9nZ2xlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyB0b2dnbGUsIGxldCdzIGNyZWF0ZSBvbmVcbiAgICAgICAgaWYgKCFvcHRzLmN1c3RvbVRvZ2dsZSkge1xuICAgICAgICAgIHZhciB0b2dnbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICB0b2dnbGUuaW5uZXJIVE1MID0gb3B0cy5sYWJlbDtcbiAgICAgICAgICBzZXRBdHRyaWJ1dGVzKHRvZ2dsZSwge1xuICAgICAgICAgICAgaHJlZjogXCIjXCIsXG4gICAgICAgICAgICBjbGFzczogXCJuYXYtdG9nZ2xlXCJcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIERldGVybWluZSB3aGVyZSB0byBpbnNlcnQgdGhlIHRvZ2dsZVxuICAgICAgICAgIGlmIChvcHRzLmluc2VydCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICAgICAgICBuYXYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodG9nZ2xlLCBuYXYubmV4dFNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYXYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodG9nZ2xlLCBuYXYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5hdlRvZ2dsZSA9IHRvZ2dsZTtcblxuICAgICAgICAgIC8vIFRoZXJlIGlzIGEgdG9nZ2xlIGFscmVhZHksIGxldCdzIHVzZSB0aGF0IG9uZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0b2dnbGVFbCA9IG9wdHMuY3VzdG9tVG9nZ2xlLnJlcGxhY2UoXCIjXCIsIFwiXCIpO1xuXG4gICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRvZ2dsZUVsKSkge1xuICAgICAgICAgICAgbmF2VG9nZ2xlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodG9nZ2xlRWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0b2dnbGVFbCkpIHtcbiAgICAgICAgICAgIG5hdlRvZ2dsZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodG9nZ2xlRWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiVGhlIGN1c3RvbSBuYXYgdG9nZ2xlIHlvdSBhcmUgdHJ5aW5nIHRvIHNlbGVjdCBkb2Vzbid0IGV4aXN0XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENsb3NlcyB0aGUgbmF2aWdhdGlvbiB3aGVuIGEgbGluayBpbnNpZGUgaXMgY2xpY2tlZC5cbiAgICAgICAqL1xuICAgICAgX2Nsb3NlT25OYXZDbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChvcHRzLmNsb3NlT25OYXZDbGljaykge1xuICAgICAgICAgIHZhciBsaW5rcyA9IG5hdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIiksXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICBmb3JFYWNoKGxpbmtzLCBmdW5jdGlvbihpLCBlbCkge1xuICAgICAgICAgICAgYWRkRXZlbnQoXG4gICAgICAgICAgICAgIGxpbmtzW2ldLFxuICAgICAgICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc01vYmlsZSkge1xuICAgICAgICAgICAgICAgICAgc2VsZi50b2dnbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtICB7ZXZlbnR9IGV2ZW50XG4gICAgICAgKi9cbiAgICAgIF9wcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgIGlmIChlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgLy8gVGhpcyBpcyBzdHJpY3RseSBmb3Igb2xkIElFXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIE9uIHRvdWNoIHN0YXJ0IHdlIGdldCB0aGUgbG9jYXRpb24gb2YgdGhlIHRvdWNoLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge2V2ZW50fSBldmVudFxuICAgICAgICovXG4gICAgICBfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuICAgICAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRYID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgIHRoaXMuc3RhcnRZID0gZS50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIHRoaXMudG91Y2hIYXNNb3ZlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgbW91c2V1cCBldmVudCBjb21wbGV0ZWx5IGhlcmUgdG8gYXZvaWRcbiAgICAgICAgICogZG91YmxlIHRyaWdnZXJpbmcgdGhlIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlRXZlbnQobmF2VG9nZ2xlLCBcIm1vdXNldXBcIiwgdGhpcywgZmFsc2UpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBpZiB0aGUgdXNlciBpcyBzY3JvbGxpbmcgaW5zdGVhZCBvZiB0YXBwaW5nLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge2V2ZW50fSBldmVudFxuICAgICAgICovXG4gICAgICBfb25Ub3VjaE1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIE1hdGguYWJzKGUudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy5zdGFydFgpID4gMTAgfHxcbiAgICAgICAgICBNYXRoLmFicyhlLnRvdWNoZXNbMF0uY2xpZW50WSAtIHRoaXMuc3RhcnRZKSA+IDEwXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMudG91Y2hIYXNNb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogT24gdG91Y2ggZW5kIHRvZ2dsZSB0aGUgbmF2aWdhdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gIHtldmVudH0gZXZlbnRcbiAgICAgICAqL1xuICAgICAgX29uVG91Y2hFbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5fcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIGlmICghaXNNb2JpbGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBpc24ndCBzY3JvbGxpbmdcbiAgICAgICAgaWYgKCF0aGlzLnRvdWNoSGFzTW92ZWQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZXZlbnQgdHlwZSBpcyB0b3VjaFxuICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwidG91Y2hlbmRcIikge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy8gRXZlbnQgdHlwZSB3YXMgY2xpY2ssIG5vdCB0b3VjaFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgICAgIC8vIElmIGl0IGlzbid0IGEgcmlnaHQgY2xpY2ssIGRvIHRvZ2dsaW5nXG4gICAgICAgICAgICBpZiAoIShldnQud2hpY2ggPT09IDMgfHwgZXZ0LmJ1dHRvbiA9PT0gMikpIHtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRm9yIGtleWJvYXJkIGFjY2Vzc2liaWxpdHksIHRvZ2dsZSB0aGUgbmF2aWdhdGlvbiBvbiBFbnRlclxuICAgICAgICoga2V5cHJlc3MgdG9vLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSAge2V2ZW50fSBldmVudFxuICAgICAgICovXG4gICAgICBfb25LZXlVcDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZXZ0ID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgdGhlIG5lZWRlZCBDU1MgdHJhbnNpdGlvbnMgaWYgYW5pbWF0aW9ucyBhcmUgZW5hYmxlZFxuICAgICAgICovXG4gICAgICBfdHJhbnNpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAob3B0cy5hbmltYXRlKSB7XG4gICAgICAgICAgdmFyIG9ialN0eWxlID0gbmF2LnN0eWxlLFxuICAgICAgICAgICAgdHJhbnNpdGlvbiA9IFwibWF4LWhlaWdodCBcIiArIG9wdHMudHJhbnNpdGlvbiArIFwibXNcIjtcblxuICAgICAgICAgIG9ialN0eWxlLldlYmtpdFRyYW5zaXRpb24gPSBvYmpTdHlsZS5Nb3pUcmFuc2l0aW9uID0gb2JqU3R5bGUuT1RyYW5zaXRpb24gPSBvYmpTdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxjdWxhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIG5hdmlnYXRpb24gYW5kIHRoZW4gY3JlYXRlc1xuICAgICAgICogc3R5bGVzIHdoaWNoIGFyZSBsYXRlciBhZGRlZCB0byB0aGUgcGFnZSA8aGVhZD5cbiAgICAgICAqL1xuICAgICAgX2NhbGNIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2F2ZWRIZWlnaHQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hdi5pbm5lci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNhdmVkSGVpZ2h0ICs9IG5hdi5pbm5lcltpXS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5uZXJTdHlsZXMgPVxuICAgICAgICAgIFwiLlwiICtcbiAgICAgICAgICBvcHRzLmpzQ2xhc3MgK1xuICAgICAgICAgIFwiIC5cIiArXG4gICAgICAgICAgb3B0cy5uYXZDbGFzcyArXG4gICAgICAgICAgXCItXCIgK1xuICAgICAgICAgIHRoaXMuaW5kZXggK1xuICAgICAgICAgIFwiLm9wZW5lZHttYXgtaGVpZ2h0OlwiICtcbiAgICAgICAgICBzYXZlZEhlaWdodCArXG4gICAgICAgICAgXCJweCAhaW1wb3J0YW50fSAuXCIgK1xuICAgICAgICAgIG9wdHMuanNDbGFzcyArXG4gICAgICAgICAgXCIgLlwiICtcbiAgICAgICAgICBvcHRzLm5hdkNsYXNzICtcbiAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgdGhpcy5pbmRleCArXG4gICAgICAgICAgXCIub3BlbmVkLmRyb3Bkb3duLWFjdGl2ZSB7bWF4LWhlaWdodDo5OTk5cHggIWltcG9ydGFudH1cIjtcblxuICAgICAgICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gaW5uZXJTdHlsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGlubmVyU3R5bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5uZXJTdHlsZXMgPSBcIlwiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gbmV3IFJlc3BvbnNpdmUgTmF2XG4gICAgICovXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zaXZlTmF2KGVsLCBvcHRpb25zKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVzcG9uc2l2ZU5hdjtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cucmVzcG9uc2l2ZU5hdiA9IHJlc3BvbnNpdmVOYXY7XG4gIH1cbn0pKGRvY3VtZW50LCB3aW5kb3csIDApO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmVzcG9uc2l2ZS1uYXYvY2xpZW50L2Rpc3QvcmVzcG9uc2l2ZS1uYXYuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbih3aW5kb3csIGZhY3RvcnkpIHtcbiAgdmFyIGdsb2JhbEluc3RhbGwgPSBmdW5jdGlvbigpIHtcbiAgICBmYWN0b3J5KHdpbmRvdy5sYXp5U2l6ZXMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibGF6eXVudmVpbHJlYWRcIiwgZ2xvYmFsSW5zdGFsbCwgdHJ1ZSk7XG4gIH07XG5cbiAgZmFjdG9yeSA9IGZhY3RvcnkuYmluZChudWxsLCB3aW5kb3csIHdpbmRvdy5kb2N1bWVudCk7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIGZhY3RvcnkocmVxdWlyZShcImxhenlzaXplc1wiKSk7XG4gIH0gZWxzZSBpZiAod2luZG93LmxhenlTaXplcykge1xuICAgIGdsb2JhbEluc3RhbGwoKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxhenl1bnZlaWxyZWFkXCIsIGdsb2JhbEluc3RhbGwsIHRydWUpO1xuICB9XG59KSh3aW5kb3csIGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIGxhenlTaXplcykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBpZiAoIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcblxuICB2YXIgaW1hZ2VSYXRpbywgZXh0ZW5kJCwgJDtcblxuICB2YXIgcmVnUGljdHVyZSA9IC9ecGljdHVyZSQvaTtcbiAgdmFyIGFzcGVjdFJhdGlvQXR0ciA9IFwiZGF0YS1hc3BlY3RyYXRpb1wiO1xuICB2YXIgYXNwZWN0UmF0aW9TZWwgPSBcImltZ1tcIiArIGFzcGVjdFJhdGlvQXR0ciArIFwiXVwiO1xuXG4gIHZhciBtYXRjaGVzTWVkaWEgPSBmdW5jdGlvbihtZWRpYSkge1xuICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgbWF0Y2hlc01lZGlhID0gZnVuY3Rpb24obWVkaWEpIHtcbiAgICAgICAgcmV0dXJuICFtZWRpYSB8fCAobWF0Y2hNZWRpYShtZWRpYSkgfHwge30pLm1hdGNoZXM7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAod2luZG93Lk1vZGVybml6ciAmJiBNb2Rlcm5penIubXEpIHtcbiAgICAgIHJldHVybiAhbWVkaWEgfHwgTW9kZXJuaXpyLm1xKG1lZGlhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICFtZWRpYTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXNNZWRpYShtZWRpYSk7XG4gIH07XG5cbiAgdmFyIGFkZENsYXNzID0gbGF6eVNpemVzLmFDO1xuICB2YXIgcmVtb3ZlQ2xhc3MgPSBsYXp5U2l6ZXMuckM7XG4gIHZhciBsYXp5U2l6ZXNDb25maWcgPSBsYXp5U2l6ZXMuY2ZnO1xuXG4gIGZ1bmN0aW9uIEFzcGVjdFJhdGlvKCkge1xuICAgIHRoaXMucmF0aW9FbGVtcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJsYXp5YXNwZWN0cmF0aW9cIik7XG4gICAgdGhpcy5fc2V0dXBFdmVudHMoKTtcbiAgICB0aGlzLnByb2Nlc3NJbWFnZXMoKTtcbiAgfVxuXG4gIEFzcGVjdFJhdGlvLnByb3RvdHlwZSA9IHtcbiAgICBfc2V0dXBFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1vZHVsZSA9IHRoaXM7XG5cbiAgICAgIHZhciBhZGRSZW1vdmVBc3BlY3RSYXRpbyA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgaWYgKGVsZW0ubmF0dXJhbFdpZHRoIDwgMzYpIHtcbiAgICAgICAgICBtb2R1bGUuYWRkQXNwZWN0UmF0aW8oZWxlbSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kdWxlLnJlbW92ZUFzcGVjdFJhdGlvKGVsZW0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIG9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBtb2R1bGUucHJvY2Vzc0ltYWdlcygpO1xuICAgICAgfTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJsb2FkXCIsXG4gICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoZS50YXJnZXQuZ2V0QXR0cmlidXRlICYmIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShhc3BlY3RSYXRpb0F0dHIpKSB7XG4gICAgICAgICAgICBhZGRSZW1vdmVBc3BlY3RSYXRpbyhlLnRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cnVlXG4gICAgICApO1xuXG4gICAgICBhZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInJlc2l6ZVwiLFxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHRpbWVyO1xuICAgICAgICAgIHZhciByZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvckVhY2guY2FsbChtb2R1bGUucmF0aW9FbGVtcywgYWRkUmVtb3ZlQXNwZWN0UmF0aW8pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KHJlc2l6ZSwgOTkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKClcbiAgICAgICk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIG9ubG9hZCk7XG5cbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9ubG9hZCk7XG4gICAgfSxcbiAgICBwcm9jZXNzSW1hZ2VzOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgZWxlbWVudHMsIGk7XG5cbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChcImxlbmd0aFwiIGluIGNvbnRleHQgJiYgIWNvbnRleHQubm9kZU5hbWUpIHtcbiAgICAgICAgZWxlbWVudHMgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudHMgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoYXNwZWN0UmF0aW9TZWwpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLm5hdHVyYWxXaWR0aCA+IDM2KSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBc3BlY3RSYXRpbyhlbGVtZW50c1tpXSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRBc3BlY3RSYXRpbyhlbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRTZWxlY3RlZFJhdGlvOiBmdW5jdGlvbihpbWcpIHtcbiAgICAgIHZhciBpLCBsZW4sIHNvdXJjZXMsIGN1c3RvbU1lZGlhLCByYXRpbztcbiAgICAgIHZhciBwYXJlbnQgPSBpbWcucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnQgJiYgcmVnUGljdHVyZS50ZXN0KHBhcmVudC5ub2RlTmFtZSB8fCBcIlwiKSkge1xuICAgICAgICBzb3VyY2VzID0gcGFyZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic291cmNlXCIpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjdXN0b21NZWRpYSA9XG4gICAgICAgICAgICBzb3VyY2VzW2ldLmdldEF0dHJpYnV0ZShcImRhdGEtbWVkaWFcIikgfHxcbiAgICAgICAgICAgIHNvdXJjZXNbaV0uZ2V0QXR0cmlidXRlKFwibWVkaWFcIik7XG5cbiAgICAgICAgICBpZiAobGF6eVNpemVzQ29uZmlnLmN1c3RvbU1lZGlhW2N1c3RvbU1lZGlhXSkge1xuICAgICAgICAgICAgY3VzdG9tTWVkaWEgPSBsYXp5U2l6ZXNDb25maWcuY3VzdG9tTWVkaWFbY3VzdG9tTWVkaWFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzTWVkaWEoY3VzdG9tTWVkaWEpKSB7XG4gICAgICAgICAgICByYXRpbyA9IHNvdXJjZXNbaV0uZ2V0QXR0cmlidXRlKGFzcGVjdFJhdGlvQXR0cik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhdGlvIHx8IGltZy5nZXRBdHRyaWJ1dGUoYXNwZWN0UmF0aW9BdHRyKSB8fCBcIlwiO1xuICAgIH0sXG4gICAgcGFyc2VSYXRpbzogKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlZ1JhdGlvID0gL15cXHMqKFsrXFxkXFwuXSspKFxccypbXFwveF1cXHMqKFsrXFxkXFwuXSspKT9cXHMqJC87XG4gICAgICB2YXIgcmF0aW9DYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJhdGlvKSB7XG4gICAgICAgIGlmICghcmF0aW9DYWNoZVtyYXRpb10gJiYgcmF0aW8ubWF0Y2gocmVnUmF0aW8pKSB7XG4gICAgICAgICAgaWYgKFJlZ0V4cC4kMykge1xuICAgICAgICAgICAgcmF0aW9DYWNoZVtyYXRpb10gPSBSZWdFeHAuJDEgLyBSZWdFeHAuJDM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhdGlvQ2FjaGVbcmF0aW9dID0gUmVnRXhwLiQxICogMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmF0aW9DYWNoZVtyYXRpb107XG4gICAgICB9O1xuICAgIH0pKCksXG4gICAgYWRkQXNwZWN0UmF0aW86IGZ1bmN0aW9uKGltZywgbm90TmV3KSB7XG4gICAgICB2YXIgcmF0aW87XG4gICAgICB2YXIgd2lkdGggPSBpbWcub2Zmc2V0V2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gaW1nLm9mZnNldEhlaWdodDtcblxuICAgICAgaWYgKCFub3ROZXcpIHtcbiAgICAgICAgYWRkQ2xhc3MoaW1nLCBcImxhenlhc3BlY3RyYXRpb1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpZHRoIDwgMzYgJiYgaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgaWYgKHdpZHRoIHx8IChoZWlnaHQgJiYgd2luZG93LmNvbnNvbGUpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBcIkRlZmluZSB3aWR0aCBvciBoZWlnaHQgb2YgaW1hZ2UsIHNvIHdlIGNhbiBjYWxjdWxhdGUgdGhlIG90aGVyIGRpbWVuc2lvblwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJhdGlvID0gdGhpcy5nZXRTZWxlY3RlZFJhdGlvKGltZyk7XG4gICAgICByYXRpbyA9IHRoaXMucGFyc2VSYXRpbyhyYXRpbyk7XG5cbiAgICAgIGlmIChyYXRpbykge1xuICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICBpbWcuc3R5bGUuaGVpZ2h0ID0gd2lkdGggLyByYXRpbyArIFwicHhcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbWcuc3R5bGUud2lkdGggPSBoZWlnaHQgKiByYXRpbyArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlQXNwZWN0UmF0aW86IGZ1bmN0aW9uKGltZykge1xuICAgICAgcmVtb3ZlQ2xhc3MoaW1nLCBcImxhenlhc3BlY3RyYXRpb1wiKTtcbiAgICAgIGltZy5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgICAgaW1nLnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICAgIGltZy5yZW1vdmVBdHRyaWJ1dGUoYXNwZWN0UmF0aW9BdHRyKTtcbiAgICB9XG4gIH07XG5cbiAgZXh0ZW5kJCA9IGZ1bmN0aW9uKCkge1xuICAgICQgPSB3aW5kb3cualF1ZXJ5IHx8IHdpbmRvdy5aZXB0byB8fCB3aW5kb3cuc2hvZXN0cmluZyB8fCB3aW5kb3cuJDtcbiAgICBpZiAoJCAmJiAkLmZuICYmICEkLmZuLmltYWdlUmF0aW8gJiYgJC5mbi5maWx0ZXIgJiYgJC5mbi5hZGQgJiYgJC5mbi5maW5kKSB7XG4gICAgICAkLmZuLmltYWdlUmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaW1hZ2VSYXRpby5wcm9jZXNzSW1hZ2VzKFxuICAgICAgICAgIHRoaXMuZmluZChhc3BlY3RSYXRpb1NlbCkuYWRkKHRoaXMuZmlsdGVyKGFzcGVjdFJhdGlvU2VsKSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGV4dGVuZCQoKTtcbiAgc2V0VGltZW91dChleHRlbmQkKTtcblxuICBpbWFnZVJhdGlvID0gbmV3IEFzcGVjdFJhdGlvKCk7XG5cbiAgd2luZG93LmltYWdlUmF0aW8gPSBpbWFnZVJhdGlvO1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGltYWdlUmF0aW87XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShpbWFnZVJhdGlvKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9sYXp5c2l6ZXMvcGx1Z2lucy9hc3BlY3RyYXRpby9scy5hc3BlY3RyYXRpby5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uKHdpbmRvdywgZmFjdG9yeSkge1xuICB2YXIgZ2xvYmFsSW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuICAgIGZhY3Rvcnkod2luZG93LmxhenlTaXplcyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsYXp5dW52ZWlscmVhZFwiLCBnbG9iYWxJbnN0YWxsLCB0cnVlKTtcbiAgfTtcblxuICBmYWN0b3J5ID0gZmFjdG9yeS5iaW5kKG51bGwsIHdpbmRvdywgd2luZG93LmRvY3VtZW50KTtcblxuICBpZiAodHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgZmFjdG9yeShyZXF1aXJlKFwibGF6eXNpemVzXCIpKTtcbiAgfSBlbHNlIGlmICh3aW5kb3cubGF6eVNpemVzKSB7XG4gICAgZ2xvYmFsSW5zdGFsbCgpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibGF6eXVudmVpbHJlYWRcIiwgZ2xvYmFsSW5zdGFsbCwgdHJ1ZSk7XG4gIH1cbn0pKHdpbmRvdywgZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgbGF6eVNpemVzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBpZiAoIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlZ1doaXRlID0gL1xccysvZztcbiAgdmFyIHJlZ1NwbGl0U2V0ID0gL1xccypcXHxcXHMrfFxccytcXHxcXHMqL2c7XG4gIHZhciByZWdTb3VyY2UgPSAvXiguKz8pKD86XFxzK1xcW1xccyooLis/KVxccypcXF0pPyQvO1xuICB2YXIgcmVnQmdVcmxFc2NhcGUgPSAvXFwofFxcKXwnLztcbiAgdmFyIGFsbG93ZWRCYWNrZ3JvdW5kU2l6ZSA9IHsgY29udGFpbjogMSwgY292ZXI6IDEgfTtcbiAgdmFyIHByb3h5V2lkdGggPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgdmFyIHdpZHRoID0gbGF6eVNpemVzLmdXKGVsZW0sIGVsZW0ucGFyZW50Tm9kZSk7XG5cbiAgICBpZiAoIWVsZW0uX2xhenlzaXplc1dpZHRoIHx8IHdpZHRoID4gZWxlbS5fbGF6eXNpemVzV2lkdGgpIHtcbiAgICAgIGVsZW0uX2xhenlzaXplc1dpZHRoID0gd2lkdGg7XG4gICAgfVxuICAgIHJldHVybiBlbGVtLl9sYXp5c2l6ZXNXaWR0aDtcbiAgfTtcbiAgdmFyIGdldEJnU2l6ZSA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICB2YXIgYmdTaXplO1xuXG4gICAgYmdTaXplID0gKFxuICAgICAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKSB8fCB7IGdldFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uKCkge30gfVxuICAgICkuZ2V0UHJvcGVydHlWYWx1ZShcImJhY2tncm91bmQtc2l6ZVwiKTtcblxuICAgIGlmIChcbiAgICAgICFhbGxvd2VkQmFja2dyb3VuZFNpemVbYmdTaXplXSAmJlxuICAgICAgYWxsb3dlZEJhY2tncm91bmRTaXplW2VsZW0uc3R5bGUuYmFja2dyb3VuZFNpemVdXG4gICAgKSB7XG4gICAgICBiZ1NpemUgPSBlbGVtLnN0eWxlLmJhY2tncm91bmRTaXplO1xuICAgIH1cblxuICAgIHJldHVybiBiZ1NpemU7XG4gIH07XG4gIHZhciBjcmVhdGVQaWN0dXJlID0gZnVuY3Rpb24oc2V0cywgZWxlbSwgaW1nKSB7XG4gICAgdmFyIHBpY3R1cmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicGljdHVyZVwiKTtcbiAgICB2YXIgc2l6ZXMgPSBlbGVtLmdldEF0dHJpYnV0ZShsYXp5U2l6ZXNDb25maWcuc2l6ZXNBdHRyKTtcbiAgICB2YXIgcmF0aW8gPSBlbGVtLmdldEF0dHJpYnV0ZShcImRhdGEtcmF0aW9cIik7XG4gICAgdmFyIG9wdGltdW14ID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLW9wdGltdW14XCIpO1xuXG4gICAgaWYgKGVsZW0uX2xhenliZ3NldCAmJiBlbGVtLl9sYXp5YmdzZXQucGFyZW50Tm9kZSA9PSBlbGVtKSB7XG4gICAgICBlbGVtLnJlbW92ZUNoaWxkKGVsZW0uX2xhenliZ3NldCk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGltZywgXCJfbGF6eWJnc2V0XCIsIHtcbiAgICAgIHZhbHVlOiBlbGVtLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbSwgXCJfbGF6eWJnc2V0XCIsIHtcbiAgICAgIHZhbHVlOiBwaWN0dXJlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHNldHMgPSBzZXRzLnJlcGxhY2UocmVnV2hpdGUsIFwiIFwiKS5zcGxpdChyZWdTcGxpdFNldCk7XG5cbiAgICBwaWN0dXJlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBpbWcuY2xhc3NOYW1lID0gbGF6eVNpemVzQ29uZmlnLmxhenlDbGFzcztcblxuICAgIGlmIChzZXRzLmxlbmd0aCA9PSAxICYmICFzaXplcykge1xuICAgICAgc2l6ZXMgPSBcImF1dG9cIjtcbiAgICB9XG5cbiAgICBzZXRzLmZvckVhY2goZnVuY3Rpb24oc2V0KSB7XG4gICAgICB2YXIgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNvdXJjZVwiKTtcblxuICAgICAgaWYgKHNpemVzICYmIHNpemVzICE9IFwiYXV0b1wiKSB7XG4gICAgICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGUoXCJzaXplc1wiLCBzaXplcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXQubWF0Y2gocmVnU291cmNlKSkge1xuICAgICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKGxhenlTaXplc0NvbmZpZy5zcmNzZXRBdHRyLCBSZWdFeHAuJDEpO1xuICAgICAgICBpZiAoUmVnRXhwLiQyKSB7XG4gICAgICAgICAgc291cmNlLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIFwibWVkaWFcIixcbiAgICAgICAgICAgIGxhenlTaXplc0NvbmZpZy5jdXN0b21NZWRpYVtSZWdFeHAuJDJdIHx8IFJlZ0V4cC4kMlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBpY3R1cmUuYXBwZW5kQ2hpbGQoc291cmNlKTtcbiAgICB9KTtcblxuICAgIGlmIChzaXplcykge1xuICAgICAgaW1nLnNldEF0dHJpYnV0ZShsYXp5U2l6ZXNDb25maWcuc2l6ZXNBdHRyLCBzaXplcyk7XG4gICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShsYXp5U2l6ZXNDb25maWcuc2l6ZXNBdHRyKTtcbiAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwic2l6ZXNcIik7XG4gICAgfVxuICAgIGlmIChvcHRpbXVteCkge1xuICAgICAgaW1nLnNldEF0dHJpYnV0ZShcImRhdGEtb3B0aW11bXhcIiwgb3B0aW11bXgpO1xuICAgIH1cbiAgICBpZiAocmF0aW8pIHtcbiAgICAgIGltZy5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJhdGlvXCIsIHJhdGlvKTtcbiAgICB9XG5cbiAgICBwaWN0dXJlLmFwcGVuZENoaWxkKGltZyk7XG5cbiAgICBlbGVtLmFwcGVuZENoaWxkKHBpY3R1cmUpO1xuICB9O1xuXG4gIHZhciBwcm94eUxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFlLnRhcmdldC5fbGF6eWJnc2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGltYWdlID0gZS50YXJnZXQ7XG4gICAgdmFyIGVsZW0gPSBpbWFnZS5fbGF6eWJnc2V0O1xuICAgIHZhciBiZyA9IGltYWdlLmN1cnJlbnRTcmMgfHwgaW1hZ2Uuc3JjO1xuXG4gICAgaWYgKGJnKSB7XG4gICAgICBlbGVtLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9XG4gICAgICAgIFwidXJsKFwiICsgKHJlZ0JnVXJsRXNjYXBlLnRlc3QoYmcpID8gSlNPTi5zdHJpbmdpZnkoYmcpIDogYmcpICsgXCIpXCI7XG4gICAgfVxuXG4gICAgaWYgKGltYWdlLl9sYXp5YmdzZXRMb2FkaW5nKSB7XG4gICAgICBsYXp5U2l6ZXMuZmlyZShlbGVtLCBcIl9sYXp5bG9hZGVkXCIsIHt9LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICBkZWxldGUgaW1hZ2UuX2xhenliZ3NldExvYWRpbmc7XG4gICAgfVxuICB9O1xuXG4gIGFkZEV2ZW50TGlzdGVuZXIoXCJsYXp5YmVmb3JldW52ZWlsXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgc2V0LCBpbWFnZSwgZWxlbTtcblxuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgIShzZXQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJnc2V0XCIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW0gPSBlLnRhcmdldDtcbiAgICBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cbiAgICBpbWFnZS5hbHQgPSBcIlwiO1xuXG4gICAgaW1hZ2UuX2xhenliZ3NldExvYWRpbmcgPSB0cnVlO1xuICAgIGUuZGV0YWlsLmZpcmVzTG9hZCA9IHRydWU7XG5cbiAgICBjcmVhdGVQaWN0dXJlKHNldCwgZWxlbSwgaW1hZ2UpO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGxhenlTaXplcy5sb2FkZXIudW52ZWlsKGltYWdlKTtcblxuICAgICAgbGF6eVNpemVzLnJBRihmdW5jdGlvbigpIHtcbiAgICAgICAgbGF6eVNpemVzLmZpcmUoaW1hZ2UsIFwiX2xhenlsb2FkZWRcIiwge30sIHRydWUsIHRydWUpO1xuICAgICAgICBpZiAoaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICBwcm94eUxvYWQoeyB0YXJnZXQ6IGltYWdlIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcHJveHlMb2FkLCB0cnVlKTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBcImxhenliZWZvcmVzaXplc1wiLFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLmRldGFpbC5pbnN0YW5jZSAhPSBsYXp5U2l6ZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGUudGFyZ2V0Ll9sYXp5YmdzZXQgJiYgZS5kZXRhaWwuZGF0YUF0dHIpIHtcbiAgICAgICAgdmFyIGVsZW0gPSBlLnRhcmdldC5fbGF6eWJnc2V0O1xuICAgICAgICB2YXIgYmdTaXplID0gZ2V0QmdTaXplKGVsZW0pO1xuXG4gICAgICAgIGlmIChhbGxvd2VkQmFja2dyb3VuZFNpemVbYmdTaXplXSkge1xuICAgICAgICAgIGUudGFyZ2V0Ll9sYXp5c2l6ZXNQYXJlbnRGaXQgPSBiZ1NpemU7XG5cbiAgICAgICAgICBsYXp5U2l6ZXMuckFGKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZS50YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1wYXJlbnQtZml0XCIsIGJnU2l6ZSk7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuX2xhenlzaXplc1BhcmVudEZpdCkge1xuICAgICAgICAgICAgICBkZWxldGUgZS50YXJnZXQuX2xhenlzaXplc1BhcmVudEZpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdHJ1ZVxuICApO1xuXG4gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibGF6eWJlZm9yZXNpemVzXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoXG4gICAgICBlLmRlZmF1bHRQcmV2ZW50ZWQgfHxcbiAgICAgICFlLnRhcmdldC5fbGF6eWJnc2V0IHx8XG4gICAgICBlLmRldGFpbC5pbnN0YW5jZSAhPSBsYXp5U2l6ZXNcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5kZXRhaWwud2lkdGggPSBwcm94eVdpZHRoKGUudGFyZ2V0Ll9sYXp5YmdzZXQpO1xuICB9KTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbGF6eXNpemVzL3BsdWdpbnMvYmdzZXQvbHMuYmdzZXQuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5UaGlzIHBsdWdpbiBleHRlbmRzIGxhenlTaXplcyB0byBsYXp5TG9hZDpcbmJhY2tncm91bmQgaW1hZ2VzLCB2aWRlb3MvcG9zdGVycyBhbmQgc2NyaXB0c1xuXG5CYWNrZ3JvdW5kLUltYWdlOlxuRm9yIGJhY2tncm91bmQgaW1hZ2VzLCB1c2UgZGF0YS1iZyBhdHRyaWJ1dGU6XG48ZGl2IGNsYXNzPVwibGF6eWxvYWRcIiBkYXRhLWJnPVwiYmctaW1nLmpwZ1wiPjwvZGl2PlxuXG4gVmlkZW86XG4gRm9yIHZpZGVvL2F1ZGlvIHVzZSBkYXRhLXBvc3RlciBhbmQgcHJlbG9hZD1cIm5vbmVcIjpcbiA8dmlkZW8gY2xhc3M9XCJsYXp5bG9hZFwiIGRhdGEtcG9zdGVyPVwicG9zdGVyLmpwZ1wiIHByZWxvYWQ9XCJub25lXCI+XG4gPCEtLSBzb3VyY2VzIC0tPlxuIDwvdmlkZW8+XG5cbiBTY3JpcHRzOlxuIEZvciBzY3JpcHRzIHVzZSBkYXRhLXNjcmlwdDpcbiA8ZGl2IGNsYXNzPVwibGF6eWxvYWRcIiBkYXRhLXNjcmlwdD1cIm1vZHVsZS1uYW1lLmpzXCI+PC9kaXY+XG5cblxuIFNjcmlwdCBtb2R1bGVzIHVzaW5nIHJlcXVpcmU6XG4gRm9yIG1vZHVsZXMgdXNpbmcgcmVxdWlyZSB1c2UgZGF0YS1yZXF1aXJlOlxuIDxkaXYgY2xhc3M9XCJsYXp5bG9hZFwiIGRhdGEtcmVxdWlyZT1cIm1vZHVsZS1uYW1lXCI+PC9kaXY+XG4qL1xuXG4oZnVuY3Rpb24od2luZG93LCBmYWN0b3J5KSB7XG4gIHZhciBnbG9iYWxJbnN0YWxsID0gZnVuY3Rpb24oKSB7XG4gICAgZmFjdG9yeSh3aW5kb3cubGF6eVNpemVzKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxhenl1bnZlaWxyZWFkXCIsIGdsb2JhbEluc3RhbGwsIHRydWUpO1xuICB9O1xuXG4gIGZhY3RvcnkgPSBmYWN0b3J5LmJpbmQobnVsbCwgd2luZG93LCB3aW5kb3cuZG9jdW1lbnQpO1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBmYWN0b3J5KHJlcXVpcmUoXCJsYXp5c2l6ZXNcIikpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5sYXp5U2l6ZXMpIHtcbiAgICBnbG9iYWxJbnN0YWxsKCk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsYXp5dW52ZWlscmVhZFwiLCBnbG9iYWxJbnN0YWxsLCB0cnVlKTtcbiAgfVxufSkod2luZG93LCBmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBsYXp5U2l6ZXMpIHtcbiAgLypqc2hpbnQgZXFudWxsOnRydWUgKi9cbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBiZ0xvYWQsIHJlZ0JnVXJsRXNjYXBlO1xuICB2YXIgdW5pcXVlVXJscyA9IHt9O1xuXG4gIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgcmVnQmdVcmxFc2NhcGUgPSAvXFwofFxcKXxcXHN8Jy87XG5cbiAgICBiZ0xvYWQgPSBmdW5jdGlvbih1cmwsIGNiKSB7XG4gICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaW1nLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgaW1nID0gbnVsbDtcbiAgICAgICAgY2IoKTtcbiAgICAgIH07XG4gICAgICBpbWcub25lcnJvciA9IGltZy5vbmxvYWQ7XG5cbiAgICAgIGltZy5zcmMgPSB1cmw7XG5cbiAgICAgIGlmIChpbWcgJiYgaW1nLmNvbXBsZXRlICYmIGltZy5vbmxvYWQpIHtcbiAgICAgICAgaW1nLm9ubG9hZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBhZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJsYXp5YmVmb3JldW52ZWlsXCIsXG4gICAgICBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmRldGFpbC5pbnN0YW5jZSAhPSBsYXp5U2l6ZXMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG1wLCBsb2FkLCBiZywgcG9zdGVyO1xuICAgICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIGlmIChlLnRhcmdldC5wcmVsb2FkID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5wcmVsb2FkID0gXCJhdXRvXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG1wID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1saW5rXCIpO1xuICAgICAgICAgIGlmICh0bXApIHtcbiAgICAgICAgICAgIGFkZFN0eWxlU2NyaXB0KHRtcCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaGFuZGxlIGRhdGEtc2NyaXB0XG4gICAgICAgICAgdG1wID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zY3JpcHRcIik7XG4gICAgICAgICAgaWYgKHRtcCkge1xuICAgICAgICAgICAgYWRkU3R5bGVTY3JpcHQodG1wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBoYW5kbGUgZGF0YS1yZXF1aXJlXG4gICAgICAgICAgdG1wID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZXF1aXJlXCIpO1xuICAgICAgICAgIGlmICh0bXApIHtcbiAgICAgICAgICAgIGlmIChsYXp5U2l6ZXMuY2ZnLnJlcXVpcmVKcykge1xuICAgICAgICAgICAgICBsYXp5U2l6ZXMuY2ZnLnJlcXVpcmVKcyhbdG1wXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRTdHlsZVNjcmlwdCh0bXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGhhbmRsZSBkYXRhLWJnXG4gICAgICAgICAgYmcgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJnXCIpO1xuICAgICAgICAgIGlmIChiZykge1xuICAgICAgICAgICAgZS5kZXRhaWwuZmlyZXNMb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZS50YXJnZXQuc3R5bGUuYmFja2dyb3VuZEltYWdlID1cbiAgICAgICAgICAgICAgICBcInVybChcIiArXG4gICAgICAgICAgICAgICAgKHJlZ0JnVXJsRXNjYXBlLnRlc3QoYmcpID8gSlNPTi5zdHJpbmdpZnkoYmcpIDogYmcpICtcbiAgICAgICAgICAgICAgICBcIilcIjtcbiAgICAgICAgICAgICAgZS5kZXRhaWwuZmlyZXNMb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxhenlTaXplcy5maXJlKGUudGFyZ2V0LCBcIl9sYXp5bG9hZGVkXCIsIHt9LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGJnTG9hZChiZywgbG9hZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaGFuZGxlIGRhdGEtcG9zdGVyXG4gICAgICAgICAgcG9zdGVyID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wb3N0ZXJcIik7XG4gICAgICAgICAgaWYgKHBvc3Rlcikge1xuICAgICAgICAgICAgZS5kZXRhaWwuZmlyZXNMb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZS50YXJnZXQucG9zdGVyID0gcG9zdGVyO1xuICAgICAgICAgICAgICBlLmRldGFpbC5maXJlc0xvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbGF6eVNpemVzLmZpcmUoZS50YXJnZXQsIFwiX2xhenlsb2FkZWRcIiwge30sIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYmdMb2FkKHBvc3RlciwgbG9hZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkU3R5bGVTY3JpcHQoc3JjLCBzdHlsZSkge1xuICAgIGlmICh1bmlxdWVVcmxzW3NyY10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHN0eWxlID8gXCJsaW5rXCIgOiBcInNjcmlwdFwiKTtcbiAgICB2YXIgaW5zZXJ0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpWzBdO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBlbGVtLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuICAgICAgZWxlbS5ocmVmID0gc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtLnNyYyA9IHNyYztcbiAgICB9XG4gICAgdW5pcXVlVXJsc1tzcmNdID0gdHJ1ZTtcbiAgICB1bmlxdWVVcmxzW2VsZW0uc3JjIHx8IGVsZW0uaHJlZl0gPSB0cnVlO1xuICAgIGluc2VydEVsZW0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbSwgaW5zZXJ0RWxlbSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbGF6eXNpemVzL3BsdWdpbnMvdW52ZWlsaG9va3MvbHMudW52ZWlsaG9va3MuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogaXNNb2JpbGUuanMgdjAuNC4xXG4gKlxuICogQSBzaW1wbGUgbGlicmFyeSB0byBkZXRlY3QgQXBwbGUgcGhvbmVzIGFuZCB0YWJsZXRzLFxuICogQW5kcm9pZCBwaG9uZXMgYW5kIHRhYmxldHMsIG90aGVyIG1vYmlsZSBkZXZpY2VzIChsaWtlIGJsYWNrYmVycnksIG1pbmktb3BlcmEgYW5kIHdpbmRvd3MgcGhvbmUpLFxuICogYW5kIGFueSBraW5kIG9mIHNldmVuIGluY2ggZGV2aWNlLCB2aWEgdXNlciBhZ2VudCBzbmlmZmluZy5cbiAqXG4gKiBAYXV0aG9yOiBLYWkgTWFsbGVhIChrbWFsbGVhQGdtYWlsLmNvbSlcbiAqXG4gKiBAbGljZW5zZTogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvcHVibGljZG9tYWluL3plcm8vMS4wL1xuICovXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gIHZhciBhcHBsZV9waG9uZSA9IC9pUGhvbmUvaSxcbiAgICBhcHBsZV9pcG9kID0gL2lQb2QvaSxcbiAgICBhcHBsZV90YWJsZXQgPSAvaVBhZC9pLFxuICAgIGFuZHJvaWRfcGhvbmUgPSAvKD89LipcXGJBbmRyb2lkXFxiKSg/PS4qXFxiTW9iaWxlXFxiKS9pLCAvLyBNYXRjaCAnQW5kcm9pZCcgQU5EICdNb2JpbGUnXG4gICAgYW5kcm9pZF90YWJsZXQgPSAvQW5kcm9pZC9pLFxuICAgIGFtYXpvbl9waG9uZSA9IC8oPz0uKlxcYkFuZHJvaWRcXGIpKD89LipcXGJTRDQ5MzBVUlxcYikvaSxcbiAgICBhbWF6b25fdGFibGV0ID0gLyg/PS4qXFxiQW5kcm9pZFxcYikoPz0uKlxcYig/OktGT1R8S0ZUVHxLRkpXSXxLRkpXQXxLRlNPV0l8S0ZUSFdJfEtGVEhXQXxLRkFQV0l8S0ZBUFdBfEtGQVJXSXxLRkFTV0l8S0ZTQVdJfEtGU0FXQSlcXGIpL2ksXG4gICAgd2luZG93c19waG9uZSA9IC9XaW5kb3dzIFBob25lL2ksXG4gICAgd2luZG93c190YWJsZXQgPSAvKD89LipcXGJXaW5kb3dzXFxiKSg/PS4qXFxiQVJNXFxiKS9pLCAvLyBNYXRjaCAnV2luZG93cycgQU5EICdBUk0nXG4gICAgb3RoZXJfYmxhY2tiZXJyeSA9IC9CbGFja0JlcnJ5L2ksXG4gICAgb3RoZXJfYmxhY2tiZXJyeV8xMCA9IC9CQjEwL2ksXG4gICAgb3RoZXJfb3BlcmEgPSAvT3BlcmEgTWluaS9pLFxuICAgIG90aGVyX2Nocm9tZSA9IC8oQ3JpT1N8Q2hyb21lKSg/PS4qXFxiTW9iaWxlXFxiKS9pLFxuICAgIG90aGVyX2ZpcmVmb3ggPSAvKD89LipcXGJGaXJlZm94XFxiKSg/PS4qXFxiTW9iaWxlXFxiKS9pLCAvLyBNYXRjaCAnRmlyZWZveCcgQU5EICdNb2JpbGUnXG4gICAgc2V2ZW5faW5jaCA9IG5ldyBSZWdFeHAoXG4gICAgICBcIig/OlwiICsgLy8gTm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgXCJOZXh1cyA3XCIgKyAvLyBOZXh1cyA3XG4gICAgICBcInxcIiArIC8vIE9SXG4gICAgICBcIkJOVFYyNTBcIiArIC8vIEImTiBOb29rIFRhYmxldCA3IGluY2hcbiAgICAgIFwifFwiICsgLy8gT1JcbiAgICAgIFwiS2luZGxlIEZpcmVcIiArIC8vIEtpbmRsZSBGaXJlXG4gICAgICBcInxcIiArIC8vIE9SXG4gICAgICBcIlNpbGtcIiArIC8vIEtpbmRsZSBGaXJlLCBTaWxrIEFjY2VsZXJhdGVkXG4gICAgICBcInxcIiArIC8vIE9SXG4gICAgICBcIkdULVAxMDAwXCIgKyAvLyBHYWxheHkgVGFiIDcgaW5jaFxuICAgICAgICBcIilcIiwgLy8gRW5kIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgXCJpXCJcbiAgICApOyAvLyBDYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nXG5cbiAgdmFyIG1hdGNoID0gZnVuY3Rpb24ocmVnZXgsIHVzZXJBZ2VudCkge1xuICAgIHJldHVybiByZWdleC50ZXN0KHVzZXJBZ2VudCk7XG4gIH07XG5cbiAgdmFyIElzTW9iaWxlQ2xhc3MgPSBmdW5jdGlvbih1c2VyQWdlbnQpIHtcbiAgICB2YXIgdWEgPSB1c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICAgIC8vIEZhY2Vib29rIG1vYmlsZSBhcHAncyBpbnRlZ3JhdGVkIGJyb3dzZXIgYWRkcyBhIGJ1bmNoIG9mIHN0cmluZ3MgdGhhdFxuICAgIC8vIG1hdGNoIGV2ZXJ5dGhpbmcuIFN0cmlwIGl0IG91dCBpZiBpdCBleGlzdHMuXG4gICAgdmFyIHRtcCA9IHVhLnNwbGl0KFwiW0ZCQU5cIik7XG4gICAgaWYgKHR5cGVvZiB0bXBbMV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHVhID0gdG1wWzBdO1xuICAgIH1cblxuICAgIC8vIFR3aXR0ZXIgbW9iaWxlIGFwcCdzIGludGVncmF0ZWQgYnJvd3NlciBvbiBpUGFkIGFkZHMgYSBcIlR3aXR0ZXIgZm9yXG4gICAgLy8gaVBob25lXCIgc3RyaW5nLiBTYW1lIHByb2JhYmxlIGhhcHBlbnMgb24gb3RoZXIgdGFibGV0IHBsYXRmb3Jtcy5cbiAgICAvLyBUaGlzIHdpbGwgY29uZnVzZSBkZXRlY3Rpb24gc28gc3RyaXAgaXQgb3V0IGlmIGl0IGV4aXN0cy5cbiAgICB0bXAgPSB1YS5zcGxpdChcIlR3aXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiB0bXBbMV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHVhID0gdG1wWzBdO1xuICAgIH1cblxuICAgIHRoaXMuYXBwbGUgPSB7XG4gICAgICBwaG9uZTogbWF0Y2goYXBwbGVfcGhvbmUsIHVhKSxcbiAgICAgIGlwb2Q6IG1hdGNoKGFwcGxlX2lwb2QsIHVhKSxcbiAgICAgIHRhYmxldDogIW1hdGNoKGFwcGxlX3Bob25lLCB1YSkgJiYgbWF0Y2goYXBwbGVfdGFibGV0LCB1YSksXG4gICAgICBkZXZpY2U6XG4gICAgICAgIG1hdGNoKGFwcGxlX3Bob25lLCB1YSkgfHxcbiAgICAgICAgbWF0Y2goYXBwbGVfaXBvZCwgdWEpIHx8XG4gICAgICAgIG1hdGNoKGFwcGxlX3RhYmxldCwgdWEpXG4gICAgfTtcbiAgICB0aGlzLmFtYXpvbiA9IHtcbiAgICAgIHBob25lOiBtYXRjaChhbWF6b25fcGhvbmUsIHVhKSxcbiAgICAgIHRhYmxldDogIW1hdGNoKGFtYXpvbl9waG9uZSwgdWEpICYmIG1hdGNoKGFtYXpvbl90YWJsZXQsIHVhKSxcbiAgICAgIGRldmljZTogbWF0Y2goYW1hem9uX3Bob25lLCB1YSkgfHwgbWF0Y2goYW1hem9uX3RhYmxldCwgdWEpXG4gICAgfTtcbiAgICB0aGlzLmFuZHJvaWQgPSB7XG4gICAgICBwaG9uZTogbWF0Y2goYW1hem9uX3Bob25lLCB1YSkgfHwgbWF0Y2goYW5kcm9pZF9waG9uZSwgdWEpLFxuICAgICAgdGFibGV0OlxuICAgICAgICAhbWF0Y2goYW1hem9uX3Bob25lLCB1YSkgJiZcbiAgICAgICAgIW1hdGNoKGFuZHJvaWRfcGhvbmUsIHVhKSAmJlxuICAgICAgICAobWF0Y2goYW1hem9uX3RhYmxldCwgdWEpIHx8IG1hdGNoKGFuZHJvaWRfdGFibGV0LCB1YSkpLFxuICAgICAgZGV2aWNlOlxuICAgICAgICBtYXRjaChhbWF6b25fcGhvbmUsIHVhKSB8fFxuICAgICAgICBtYXRjaChhbWF6b25fdGFibGV0LCB1YSkgfHxcbiAgICAgICAgbWF0Y2goYW5kcm9pZF9waG9uZSwgdWEpIHx8XG4gICAgICAgIG1hdGNoKGFuZHJvaWRfdGFibGV0LCB1YSlcbiAgICB9O1xuICAgIHRoaXMud2luZG93cyA9IHtcbiAgICAgIHBob25lOiBtYXRjaCh3aW5kb3dzX3Bob25lLCB1YSksXG4gICAgICB0YWJsZXQ6IG1hdGNoKHdpbmRvd3NfdGFibGV0LCB1YSksXG4gICAgICBkZXZpY2U6IG1hdGNoKHdpbmRvd3NfcGhvbmUsIHVhKSB8fCBtYXRjaCh3aW5kb3dzX3RhYmxldCwgdWEpXG4gICAgfTtcbiAgICB0aGlzLm90aGVyID0ge1xuICAgICAgYmxhY2tiZXJyeTogbWF0Y2gob3RoZXJfYmxhY2tiZXJyeSwgdWEpLFxuICAgICAgYmxhY2tiZXJyeTEwOiBtYXRjaChvdGhlcl9ibGFja2JlcnJ5XzEwLCB1YSksXG4gICAgICBvcGVyYTogbWF0Y2gob3RoZXJfb3BlcmEsIHVhKSxcbiAgICAgIGZpcmVmb3g6IG1hdGNoKG90aGVyX2ZpcmVmb3gsIHVhKSxcbiAgICAgIGNocm9tZTogbWF0Y2gob3RoZXJfY2hyb21lLCB1YSksXG4gICAgICBkZXZpY2U6XG4gICAgICAgIG1hdGNoKG90aGVyX2JsYWNrYmVycnksIHVhKSB8fFxuICAgICAgICBtYXRjaChvdGhlcl9ibGFja2JlcnJ5XzEwLCB1YSkgfHxcbiAgICAgICAgbWF0Y2gob3RoZXJfb3BlcmEsIHVhKSB8fFxuICAgICAgICBtYXRjaChvdGhlcl9maXJlZm94LCB1YSkgfHxcbiAgICAgICAgbWF0Y2gob3RoZXJfY2hyb21lLCB1YSlcbiAgICB9O1xuICAgIHRoaXMuc2V2ZW5faW5jaCA9IG1hdGNoKHNldmVuX2luY2gsIHVhKTtcbiAgICB0aGlzLmFueSA9XG4gICAgICB0aGlzLmFwcGxlLmRldmljZSB8fFxuICAgICAgdGhpcy5hbmRyb2lkLmRldmljZSB8fFxuICAgICAgdGhpcy53aW5kb3dzLmRldmljZSB8fFxuICAgICAgdGhpcy5vdGhlci5kZXZpY2UgfHxcbiAgICAgIHRoaXMuc2V2ZW5faW5jaDtcblxuICAgIC8vIGV4Y2x1ZGVzICdvdGhlcicgZGV2aWNlcyBhbmQgaXBvZHMsIHRhcmdldGluZyB0b3VjaHNjcmVlbiBwaG9uZXNcbiAgICB0aGlzLnBob25lID0gdGhpcy5hcHBsZS5waG9uZSB8fCB0aGlzLmFuZHJvaWQucGhvbmUgfHwgdGhpcy53aW5kb3dzLnBob25lO1xuXG4gICAgLy8gZXhjbHVkZXMgNyBpbmNoIGRldmljZXMsIGNsYXNzaWZ5aW5nIGFzIHBob25lIG9yIHRhYmxldCBpcyBsZWZ0IHRvIHRoZSB1c2VyXG4gICAgdGhpcy50YWJsZXQgPVxuICAgICAgdGhpcy5hcHBsZS50YWJsZXQgfHwgdGhpcy5hbmRyb2lkLnRhYmxldCB8fCB0aGlzLndpbmRvd3MudGFibGV0O1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW5zdGFudGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgSU0gPSBuZXcgSXNNb2JpbGVDbGFzcygpO1xuICAgIElNLkNsYXNzID0gSXNNb2JpbGVDbGFzcztcbiAgICByZXR1cm4gSU07XG4gIH07XG5cbiAgaWYgKFxuICAgIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICBtb2R1bGUuZXhwb3J0cyAmJlxuICAgIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCJcbiAgKSB7XG4gICAgLy9ub2RlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJc01vYmlsZUNsYXNzO1xuICB9IGVsc2UgaWYgKFxuICAgIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICBtb2R1bGUuZXhwb3J0cyAmJlxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgKSB7XG4gICAgLy9icm93c2VyaWZ5XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbnN0YW50aWF0ZSgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy9BTURcbiAgICBkZWZpbmUoXCJpc01vYmlsZVwiLCBbXSwgKGdsb2JhbC5pc01vYmlsZSA9IGluc3RhbnRpYXRlKCkpKTtcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuaXNNb2JpbGUgPSBpbnN0YW50aWF0ZSgpO1xuICB9XG59KSh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2lzbW9iaWxlanMvaXNNb2JpbGUuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogQm93c2VyIC0gYSBicm93c2VyIGRldGVjdG9yXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGVkL2Jvd3NlclxuICogTUlUIExpY2Vuc2UgfCAoYykgRHVzdGluIERpYXogMjAxNVxuICovXG5cbiFmdW5jdGlvbiAocm9vdCwgbmFtZSwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShuYW1lLCBkZWZpbml0aW9uKVxuICBlbHNlIHJvb3RbbmFtZV0gPSBkZWZpbml0aW9uKClcbn0odGhpcywgJ2Jvd3NlcicsIGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAgKiBTZWUgdXNlcmFnZW50cy5qcyBmb3IgZXhhbXBsZXMgb2YgbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgICovXG5cbiAgdmFyIHQgPSB0cnVlXG5cbiAgZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG5cbiAgICBmdW5jdGlvbiBnZXRGaXJzdE1hdGNoKHJlZ2V4KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB1YS5tYXRjaChyZWdleCk7XG4gICAgICByZXR1cm4gKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2hbMV0pIHx8ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNlY29uZE1hdGNoKHJlZ2V4KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB1YS5tYXRjaChyZWdleCk7XG4gICAgICByZXR1cm4gKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2hbMl0pIHx8ICcnO1xuICAgIH1cblxuICAgIHZhciBpb3NkZXZpY2UgPSBnZXRGaXJzdE1hdGNoKC8oaXBvZHxpcGhvbmV8aXBhZCkvaSkudG9Mb3dlckNhc2UoKVxuICAgICAgLCBsaWtlQW5kcm9pZCA9IC9saWtlIGFuZHJvaWQvaS50ZXN0KHVhKVxuICAgICAgLCBhbmRyb2lkID0gIWxpa2VBbmRyb2lkICYmIC9hbmRyb2lkL2kudGVzdCh1YSlcbiAgICAgICwgbmV4dXNNb2JpbGUgPSAvbmV4dXNcXHMqWzAtNl1cXHMqL2kudGVzdCh1YSlcbiAgICAgICwgbmV4dXNUYWJsZXQgPSAhbmV4dXNNb2JpbGUgJiYgL25leHVzXFxzKlswLTldKy9pLnRlc3QodWEpXG4gICAgICAsIGNocm9tZW9zID0gL0NyT1MvLnRlc3QodWEpXG4gICAgICAsIHNpbGsgPSAvc2lsay9pLnRlc3QodWEpXG4gICAgICAsIHNhaWxmaXNoID0gL3NhaWxmaXNoL2kudGVzdCh1YSlcbiAgICAgICwgdGl6ZW4gPSAvdGl6ZW4vaS50ZXN0KHVhKVxuICAgICAgLCB3ZWJvcyA9IC8od2VifGhwdylvcy9pLnRlc3QodWEpXG4gICAgICAsIHdpbmRvd3NwaG9uZSA9IC93aW5kb3dzIHBob25lL2kudGVzdCh1YSlcbiAgICAgICwgc2Ftc3VuZ0Jyb3dzZXIgPSAvU2Ftc3VuZ0Jyb3dzZXIvaS50ZXN0KHVhKVxuICAgICAgLCB3aW5kb3dzID0gIXdpbmRvd3NwaG9uZSAmJiAvd2luZG93cy9pLnRlc3QodWEpXG4gICAgICAsIG1hYyA9ICFpb3NkZXZpY2UgJiYgIXNpbGsgJiYgL21hY2ludG9zaC9pLnRlc3QodWEpXG4gICAgICAsIGxpbnV4ID0gIWFuZHJvaWQgJiYgIXNhaWxmaXNoICYmICF0aXplbiAmJiAhd2Vib3MgJiYgL2xpbnV4L2kudGVzdCh1YSlcbiAgICAgICwgZWRnZVZlcnNpb24gPSBnZXRTZWNvbmRNYXRjaCgvZWRnKFtlYV18aW9zKVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgICwgdmVyc2lvbklkZW50aWZpZXIgPSBnZXRGaXJzdE1hdGNoKC92ZXJzaW9uXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgLCB0YWJsZXQgPSAvdGFibGV0L2kudGVzdCh1YSkgJiYgIS90YWJsZXQgcGMvaS50ZXN0KHVhKVxuICAgICAgLCBtb2JpbGUgPSAhdGFibGV0ICYmIC9bXi1dbW9iaS9pLnRlc3QodWEpXG4gICAgICAsIHhib3ggPSAveGJveC9pLnRlc3QodWEpXG4gICAgICAsIHJlc3VsdFxuXG4gICAgaWYgKC9vcGVyYS9pLnRlc3QodWEpKSB7XG4gICAgICAvLyAgYW4gb2xkIE9wZXJhXG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdPcGVyYSdcbiAgICAgICwgb3BlcmE6IHRcbiAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86b3BlcmF8b3ByfG9waW9zKVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL29wclxcL3xvcGlvcy9pLnRlc3QodWEpKSB7XG4gICAgICAvLyBhIG5ldyBPcGVyYVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnT3BlcmEnXG4gICAgICAgICwgb3BlcmE6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpvcHJ8b3Bpb3MpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9TYW1zdW5nQnJvd3Nlci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkJ1xuICAgICAgICAsIHNhbXN1bmdCcm93c2VyOiB0XG4gICAgICAgICwgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86U2Ftc3VuZ0Jyb3dzZXIpW1xcc1xcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9jb2FzdC9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdPcGVyYSBDb2FzdCdcbiAgICAgICAgLCBjb2FzdDogdFxuICAgICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/OmNvYXN0KVtcXHNcXC9dKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgveWFicm93c2VyL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1lhbmRleCBCcm93c2VyJ1xuICAgICAgLCB5YW5kZXhicm93c2VyOiB0XG4gICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goLyg/OnlhYnJvd3NlcilbXFxzXFwvXShcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3VjYnJvd3Nlci9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgbmFtZTogJ1VDIEJyb3dzZXInXG4gICAgICAgICwgdWNicm93c2VyOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86dWNicm93c2VyKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9teGlvcy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdNYXh0aG9uJ1xuICAgICAgICAsIG1heHRob246IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpteGlvcylbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvZXBpcGhhbnkvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnRXBpcGhhbnknXG4gICAgICAgICwgZXBpcGhhbnk6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzplcGlwaGFueSlbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvcHVmZmluL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1B1ZmZpbidcbiAgICAgICAgLCBwdWZmaW46IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpwdWZmaW4pW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL3NsZWlwbmlyL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1NsZWlwbmlyJ1xuICAgICAgICAsIHNsZWlwbmlyOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86c2xlaXBuaXIpW1xcc1xcL10oXFxkKyg/OlxcLlxcZCspKykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2stbWVsZW9uL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0stTWVsZW9uJ1xuICAgICAgICAsIGtNZWxlb246IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzprLW1lbGVvbilbXFxzXFwvXShcXGQrKD86XFwuXFxkKykrKS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3dzcGhvbmUpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1dpbmRvd3MgUGhvbmUnXG4gICAgICAsIG9zbmFtZTogJ1dpbmRvd3MgUGhvbmUnXG4gICAgICAsIHdpbmRvd3NwaG9uZTogdFxuICAgICAgfVxuICAgICAgaWYgKGVkZ2VWZXJzaW9uKSB7XG4gICAgICAgIHJlc3VsdC5tc2VkZ2UgPSB0XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gZWRnZVZlcnNpb25cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQubXNpZSA9IHRcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC9pZW1vYmlsZVxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL21zaWV8dHJpZGVudC9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdJbnRlcm5ldCBFeHBsb3JlcidcbiAgICAgICwgbXNpZTogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzptc2llIHxydjopKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hyb21lb3MpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0Nocm9tZSdcbiAgICAgICwgb3NuYW1lOiAnQ2hyb21lIE9TJ1xuICAgICAgLCBjaHJvbWVvczogdFxuICAgICAgLCBjaHJvbWVCb29rOiB0XG4gICAgICAsIGNocm9tZTogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWV8Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgvZWRnKFtlYV18aW9zKS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdNaWNyb3NvZnQgRWRnZSdcbiAgICAgICwgbXNlZGdlOiB0XG4gICAgICAsIHZlcnNpb246IGVkZ2VWZXJzaW9uXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC92aXZhbGRpL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1ZpdmFsZGknXG4gICAgICAgICwgdml2YWxkaTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3ZpdmFsZGlcXC8oXFxkKyhcXC5cXGQrKT8pL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNhaWxmaXNoKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTYWlsZmlzaCdcbiAgICAgICwgb3NuYW1lOiAnU2FpbGZpc2ggT1MnXG4gICAgICAsIHNhaWxmaXNoOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL3NhaWxmaXNoXFxzP2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9zZWFtb25rZXlcXC8vaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2VhTW9ua2V5J1xuICAgICAgLCBzZWFtb25rZXk6IHRcbiAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2VhbW9ua2V5XFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgvZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnRmlyZWZveCdcbiAgICAgICwgZmlyZWZveDogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbIFxcL10oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgICBpZiAoL1xcKChtb2JpbGV8dGFibGV0KTtbXlxcKV0qcnY6W1xcZFxcLl0rXFwpL2kudGVzdCh1YSkpIHtcbiAgICAgICAgcmVzdWx0LmZpcmVmb3hvcyA9IHRcbiAgICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdGaXJlZm94IE9TJ1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzaWxrKSB7XG4gICAgICByZXN1bHQgPSAge1xuICAgICAgICBuYW1lOiAnQW1hem9uIFNpbGsnXG4gICAgICAsIHNpbGs6IHRcbiAgICAgICwgdmVyc2lvbiA6IGdldEZpcnN0TWF0Y2goL3NpbGtcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9waGFudG9tL2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ1BoYW50b21KUydcbiAgICAgICwgcGhhbnRvbTogdFxuICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9waGFudG9tanNcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9zbGltZXJqcy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdTbGltZXJKUydcbiAgICAgICAgLCBzbGltZXI6IHRcbiAgICAgICAgLCB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zbGltZXJqc1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoL2JsYWNrYmVycnl8XFxiYmJcXGQrL2kudGVzdCh1YSkgfHwgL3JpbVxcc3RhYmxldC9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdCbGFja0JlcnJ5J1xuICAgICAgLCBvc25hbWU6ICdCbGFja0JlcnJ5IE9TJ1xuICAgICAgLCBibGFja2JlcnJ5OiB0XG4gICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goL2JsYWNrYmVycnlbXFxkXStcXC8oXFxkKyhcXC5cXGQrKT8pL2kpXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHdlYm9zKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdXZWJPUydcbiAgICAgICwgb3NuYW1lOiAnV2ViT1MnXG4gICAgICAsIHdlYm9zOiB0XG4gICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyIHx8IGdldEZpcnN0TWF0Y2goL3coPzplYik/b3Nicm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfTtcbiAgICAgIC90b3VjaHBhZFxcLy9pLnRlc3QodWEpICYmIChyZXN1bHQudG91Y2hwYWQgPSB0KVxuICAgIH1cbiAgICBlbHNlIGlmICgvYmFkYS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdCYWRhJ1xuICAgICAgLCBvc25hbWU6ICdCYWRhJ1xuICAgICAgLCBiYWRhOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL2RvbGZpblxcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRpemVuKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdUaXplbidcbiAgICAgICwgb3NuYW1lOiAnVGl6ZW4nXG4gICAgICAsIHRpemVuOiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnRpemVuXFxzPyk/YnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSkgfHwgdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKC9xdXB6aWxsYS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdRdXBaaWxsYSdcbiAgICAgICAgLCBxdXB6aWxsYTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnF1cHppbGxhKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKSspL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9jaHJvbWl1bS9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWl1bSdcbiAgICAgICAgLCBjaHJvbWl1bTogdFxuICAgICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmNocm9taXVtKVtcXHNcXC9dKFxcZCsoPzpcXC5cXGQrKT8pL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9jaHJvbWV8Y3Jpb3N8Y3Jtby9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdDaHJvbWUnXG4gICAgICAgICwgY2hyb21lOiB0XG4gICAgICAgICwgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21lfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuXFxkKyk/KS9pKVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhbmRyb2lkKSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6ICdBbmRyb2lkJ1xuICAgICAgICAsIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKC9zYWZhcml8YXBwbGV3ZWJraXQvaS50ZXN0KHVhKSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiAnU2FmYXJpJ1xuICAgICAgLCBzYWZhcmk6IHRcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJzaW9uSWRlbnRpZmllcikge1xuICAgICAgICByZXN1bHQudmVyc2lvbiA9IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlvc2RldmljZSkge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lIDogaW9zZGV2aWNlID09ICdpcGhvbmUnID8gJ2lQaG9uZScgOiBpb3NkZXZpY2UgPT0gJ2lwYWQnID8gJ2lQYWQnIDogJ2lQb2QnXG4gICAgICB9XG4gICAgICAvLyBXVEY6IHZlcnNpb24gaXMgbm90IHBhcnQgb2YgdXNlciBhZ2VudCBpbiB3ZWIgYXBwc1xuICAgICAgaWYgKHZlcnNpb25JZGVudGlmaWVyKSB7XG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdmVyc2lvbklkZW50aWZpZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZigvZ29vZ2xlYm90L2kudGVzdCh1YSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogJ0dvb2dsZWJvdCdcbiAgICAgICwgZ29vZ2xlYm90OiB0XG4gICAgICAsIHZlcnNpb246IGdldEZpcnN0TWF0Y2goL2dvb2dsZWJvdFxcLyhcXGQrKFxcLlxcZCspKS9pKSB8fCB2ZXJzaW9uSWRlbnRpZmllclxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogZ2V0Rmlyc3RNYXRjaCgvXiguKilcXC8oLiopIC8pLFxuICAgICAgICB2ZXJzaW9uOiBnZXRTZWNvbmRNYXRjaCgvXiguKilcXC8oLiopIC8pXG4gICAgIH07XG4gICB9XG5cbiAgICAvLyBzZXQgd2Via2l0IG9yIGdlY2tvIGZsYWcgZm9yIGJyb3dzZXJzIGJhc2VkIG9uIHRoZXNlIGVuZ2luZXNcbiAgICBpZiAoIXJlc3VsdC5tc2VkZ2UgJiYgLyhhcHBsZSk/d2Via2l0L2kudGVzdCh1YSkpIHtcbiAgICAgIGlmICgvKGFwcGxlKT93ZWJraXRcXC81MzdcXC4zNi9pLnRlc3QodWEpKSB7XG4gICAgICAgIHJlc3VsdC5uYW1lID0gcmVzdWx0Lm5hbWUgfHwgXCJCbGlua1wiXG4gICAgICAgIHJlc3VsdC5ibGluayA9IHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5uYW1lID0gcmVzdWx0Lm5hbWUgfHwgXCJXZWJraXRcIlxuICAgICAgICByZXN1bHQud2Via2l0ID0gdFxuICAgICAgfVxuICAgICAgaWYgKCFyZXN1bHQudmVyc2lvbiAmJiB2ZXJzaW9uSWRlbnRpZmllcikge1xuICAgICAgICByZXN1bHQudmVyc2lvbiA9IHZlcnNpb25JZGVudGlmaWVyXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghcmVzdWx0Lm9wZXJhICYmIC9nZWNrb1xcLy9pLnRlc3QodWEpKSB7XG4gICAgICByZXN1bHQubmFtZSA9IHJlc3VsdC5uYW1lIHx8IFwiR2Vja29cIlxuICAgICAgcmVzdWx0LmdlY2tvID0gdFxuICAgICAgcmVzdWx0LnZlcnNpb24gPSByZXN1bHQudmVyc2lvbiB8fCBnZXRGaXJzdE1hdGNoKC9nZWNrb1xcLyhcXGQrKFxcLlxcZCspPykvaSlcbiAgICB9XG5cbiAgICAvLyBzZXQgT1MgZmxhZ3MgZm9yIHBsYXRmb3JtcyB0aGF0IGhhdmUgbXVsdGlwbGUgYnJvd3NlcnNcbiAgICBpZiAoIXJlc3VsdC53aW5kb3dzcGhvbmUgJiYgKGFuZHJvaWQgfHwgcmVzdWx0LnNpbGspKSB7XG4gICAgICByZXN1bHQuYW5kcm9pZCA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnQW5kcm9pZCdcbiAgICB9IGVsc2UgaWYgKCFyZXN1bHQud2luZG93c3Bob25lICYmIGlvc2RldmljZSkge1xuICAgICAgcmVzdWx0W2lvc2RldmljZV0gPSB0XG4gICAgICByZXN1bHQuaW9zID0gdFxuICAgICAgcmVzdWx0Lm9zbmFtZSA9ICdpT1MnXG4gICAgfSBlbHNlIGlmIChtYWMpIHtcbiAgICAgIHJlc3VsdC5tYWMgPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ21hY09TJ1xuICAgIH0gZWxzZSBpZiAoeGJveCkge1xuICAgICAgcmVzdWx0Lnhib3ggPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ1hib3gnXG4gICAgfSBlbHNlIGlmICh3aW5kb3dzKSB7XG4gICAgICByZXN1bHQud2luZG93cyA9IHRcbiAgICAgIHJlc3VsdC5vc25hbWUgPSAnV2luZG93cydcbiAgICB9IGVsc2UgaWYgKGxpbnV4KSB7XG4gICAgICByZXN1bHQubGludXggPSB0XG4gICAgICByZXN1bHQub3NuYW1lID0gJ0xpbnV4J1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpbmRvd3NWZXJzaW9uIChzKSB7XG4gICAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSAnTlQnOiByZXR1cm4gJ05UJ1xuICAgICAgICBjYXNlICdYUCc6IHJldHVybiAnWFAnXG4gICAgICAgIGNhc2UgJ05UIDUuMCc6IHJldHVybiAnMjAwMCdcbiAgICAgICAgY2FzZSAnTlQgNS4xJzogcmV0dXJuICdYUCdcbiAgICAgICAgY2FzZSAnTlQgNS4yJzogcmV0dXJuICcyMDAzJ1xuICAgICAgICBjYXNlICdOVCA2LjAnOiByZXR1cm4gJ1Zpc3RhJ1xuICAgICAgICBjYXNlICdOVCA2LjEnOiByZXR1cm4gJzcnXG4gICAgICAgIGNhc2UgJ05UIDYuMic6IHJldHVybiAnOCdcbiAgICAgICAgY2FzZSAnTlQgNi4zJzogcmV0dXJuICc4LjEnXG4gICAgICAgIGNhc2UgJ05UIDEwLjAnOiByZXR1cm4gJzEwJ1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT1MgdmVyc2lvbiBleHRyYWN0aW9uXG4gICAgdmFyIG9zVmVyc2lvbiA9ICcnO1xuICAgIGlmIChyZXN1bHQud2luZG93cykge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0V2luZG93c1ZlcnNpb24oZ2V0Rmlyc3RNYXRjaCgvV2luZG93cyAoKE5UfFhQKSggXFxkXFxkPy5cXGQpPykvaSkpXG4gICAgfSBlbHNlIGlmIChyZXN1bHQud2luZG93c3Bob25lKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC93aW5kb3dzIHBob25lICg/Om9zKT9cXHM/KFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5tYWMpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL01hYyBPUyBYIChcXGQrKFtfXFwuXFxzXVxcZCspKikvaSk7XG4gICAgICBvc1ZlcnNpb24gPSBvc1ZlcnNpb24ucmVwbGFjZSgvW19cXHNdL2csICcuJyk7XG4gICAgfSBlbHNlIGlmIChpb3NkZXZpY2UpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL29zIChcXGQrKFtfXFxzXVxcZCspKikgbGlrZSBtYWMgb3MgeC9pKTtcbiAgICAgIG9zVmVyc2lvbiA9IG9zVmVyc2lvbi5yZXBsYWNlKC9bX1xcc10vZywgJy4nKTtcbiAgICB9IGVsc2UgaWYgKGFuZHJvaWQpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL2FuZHJvaWRbIFxcLy1dKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdC53ZWJvcykge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvKD86d2VifGhwdylvc1xcLyhcXGQrKFxcLlxcZCspKikvaSk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQuYmxhY2tiZXJyeSkge1xuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvcmltXFxzdGFibGV0XFxzb3NcXHMoXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LmJhZGEpIHtcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL2JhZGFcXC8oXFxkKyhcXC5cXGQrKSopL2kpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LnRpemVuKSB7XG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC90aXplbltcXC9cXHNdKFxcZCsoXFwuXFxkKykqKS9pKTtcbiAgICB9XG4gICAgaWYgKG9zVmVyc2lvbikge1xuICAgICAgcmVzdWx0Lm9zdmVyc2lvbiA9IG9zVmVyc2lvbjtcbiAgICB9XG5cbiAgICAvLyBkZXZpY2UgdHlwZSBleHRyYWN0aW9uXG4gICAgdmFyIG9zTWFqb3JWZXJzaW9uID0gIXJlc3VsdC53aW5kb3dzICYmIG9zVmVyc2lvbi5zcGxpdCgnLicpWzBdO1xuICAgIGlmIChcbiAgICAgICAgIHRhYmxldFxuICAgICAgfHwgbmV4dXNUYWJsZXRcbiAgICAgIHx8IGlvc2RldmljZSA9PSAnaXBhZCdcbiAgICAgIHx8IChhbmRyb2lkICYmIChvc01ham9yVmVyc2lvbiA9PSAzIHx8IChvc01ham9yVmVyc2lvbiA+PSA0ICYmICFtb2JpbGUpKSlcbiAgICAgIHx8IHJlc3VsdC5zaWxrXG4gICAgKSB7XG4gICAgICByZXN1bHQudGFibGV0ID0gdFxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICBtb2JpbGVcbiAgICAgIHx8IGlvc2RldmljZSA9PSAnaXBob25lJ1xuICAgICAgfHwgaW9zZGV2aWNlID09ICdpcG9kJ1xuICAgICAgfHwgYW5kcm9pZFxuICAgICAgfHwgbmV4dXNNb2JpbGVcbiAgICAgIHx8IHJlc3VsdC5ibGFja2JlcnJ5XG4gICAgICB8fCByZXN1bHQud2Vib3NcbiAgICAgIHx8IHJlc3VsdC5iYWRhXG4gICAgKSB7XG4gICAgICByZXN1bHQubW9iaWxlID0gdFxuICAgIH1cblxuICAgIC8vIEdyYWRlZCBCcm93c2VyIFN1cHBvcnRcbiAgICAvLyBodHRwOi8vZGV2ZWxvcGVyLnlhaG9vLmNvbS95dWkvYXJ0aWNsZXMvZ2JzXG4gICAgaWYgKHJlc3VsdC5tc2VkZ2UgfHxcbiAgICAgICAgKHJlc3VsdC5tc2llICYmIHJlc3VsdC52ZXJzaW9uID49IDEwKSB8fFxuICAgICAgICAocmVzdWx0LnlhbmRleGJyb3dzZXIgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTUpIHx8XG5cdFx0ICAgIChyZXN1bHQudml2YWxkaSAmJiByZXN1bHQudmVyc2lvbiA+PSAxLjApIHx8XG4gICAgICAgIChyZXN1bHQuY2hyb21lICYmIHJlc3VsdC52ZXJzaW9uID49IDIwKSB8fFxuICAgICAgICAocmVzdWx0LnNhbXN1bmdCcm93c2VyICYmIHJlc3VsdC52ZXJzaW9uID49IDQpIHx8XG4gICAgICAgIChyZXN1bHQuZmlyZWZveCAmJiByZXN1bHQudmVyc2lvbiA+PSAyMC4wKSB8fFxuICAgICAgICAocmVzdWx0LnNhZmFyaSAmJiByZXN1bHQudmVyc2lvbiA+PSA2KSB8fFxuICAgICAgICAocmVzdWx0Lm9wZXJhICYmIHJlc3VsdC52ZXJzaW9uID49IDEwLjApIHx8XG4gICAgICAgIChyZXN1bHQuaW9zICYmIHJlc3VsdC5vc3ZlcnNpb24gJiYgcmVzdWx0Lm9zdmVyc2lvbi5zcGxpdChcIi5cIilbMF0gPj0gNikgfHxcbiAgICAgICAgKHJlc3VsdC5ibGFja2JlcnJ5ICYmIHJlc3VsdC52ZXJzaW9uID49IDEwLjEpXG4gICAgICAgIHx8IChyZXN1bHQuY2hyb21pdW0gJiYgcmVzdWx0LnZlcnNpb24gPj0gMjApXG4gICAgICAgICkge1xuICAgICAgcmVzdWx0LmEgPSB0O1xuICAgIH1cbiAgICBlbHNlIGlmICgocmVzdWx0Lm1zaWUgJiYgcmVzdWx0LnZlcnNpb24gPCAxMCkgfHxcbiAgICAgICAgKHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LnZlcnNpb24gPCAyMCkgfHxcbiAgICAgICAgKHJlc3VsdC5maXJlZm94ICYmIHJlc3VsdC52ZXJzaW9uIDwgMjAuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5zYWZhcmkgJiYgcmVzdWx0LnZlcnNpb24gPCA2KSB8fFxuICAgICAgICAocmVzdWx0Lm9wZXJhICYmIHJlc3VsdC52ZXJzaW9uIDwgMTAuMCkgfHxcbiAgICAgICAgKHJlc3VsdC5pb3MgJiYgcmVzdWx0Lm9zdmVyc2lvbiAmJiByZXN1bHQub3N2ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSA8IDYpXG4gICAgICAgIHx8IChyZXN1bHQuY2hyb21pdW0gJiYgcmVzdWx0LnZlcnNpb24gPCAyMClcbiAgICAgICAgKSB7XG4gICAgICByZXN1bHQuYyA9IHRcbiAgICB9IGVsc2UgcmVzdWx0LnggPSB0XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICB2YXIgYm93c2VyID0gZGV0ZWN0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJyA6ICcnKVxuXG4gIGJvd3Nlci50ZXN0ID0gZnVuY3Rpb24gKGJyb3dzZXJMaXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicm93c2VyTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGJyb3dzZXJJdGVtID0gYnJvd3Nlckxpc3RbaV07XG4gICAgICBpZiAodHlwZW9mIGJyb3dzZXJJdGVtPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChicm93c2VySXRlbSBpbiBib3dzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHZlcnNpb24gcHJlY2lzaW9ucyBjb3VudFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGdldFZlcnNpb25QcmVjaXNpb24oXCIxLjEwLjNcIikgLy8gM1xuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZlcnNpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmVyc2lvblByZWNpc2lvbih2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIHZlcnNpb24uc3BsaXQoXCIuXCIpLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcnJheTo6bWFwIHBvbHlmaWxsXG4gICAqXG4gICAqIEBwYXJhbSAge0FycmF5fSBhcnJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gbWFwKGFyciwgaXRlcmF0b3IpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sIGk7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5tYXApIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYXJyLCBpdGVyYXRvcik7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdG9yKGFycltpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBicm93c2VyIHZlcnNpb24gd2VpZ2h0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4xMC4yLjEnLCAgJzEuOC4yLjEuOTAnXSkgICAgLy8gMVxuICAgKiAgIGNvbXBhcmVWZXJzaW9ucyhbJzEuMDEwLjIuMScsICcxLjA5LjIuMS45MCddKTsgIC8vIDFcbiAgICogICBjb21wYXJlVmVyc2lvbnMoWycxLjEwLjIuMScsICAnMS4xMC4yLjEnXSk7ICAgICAvLyAwXG4gICAqICAgY29tcGFyZVZlcnNpb25zKFsnMS4xMC4yLjEnLCAgJzEuMDgwMC4yJ10pOyAgICAgLy8gLTFcbiAgICpcbiAgICogQHBhcmFtICB7QXJyYXk8U3RyaW5nPn0gdmVyc2lvbnMgdmVyc2lvbnMgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBhcmlzb24gcmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModmVyc2lvbnMpIHtcbiAgICAvLyAxKSBnZXQgY29tbW9uIHByZWNpc2lvbiBmb3IgYm90aCB2ZXJzaW9ucywgZm9yIGV4YW1wbGUgZm9yIFwiMTAuMFwiIGFuZCBcIjlcIiBpdCBzaG91bGQgYmUgMlxuICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLm1heChnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb25zWzBdKSwgZ2V0VmVyc2lvblByZWNpc2lvbih2ZXJzaW9uc1sxXSkpO1xuICAgIHZhciBjaHVua3MgPSBtYXAodmVyc2lvbnMsIGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICB2YXIgZGVsdGEgPSBwcmVjaXNpb24gLSBnZXRWZXJzaW9uUHJlY2lzaW9uKHZlcnNpb24pO1xuXG4gICAgICAvLyAyKSBcIjlcIiAtPiBcIjkuMFwiIChmb3IgcHJlY2lzaW9uID0gMilcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uICsgbmV3IEFycmF5KGRlbHRhICsgMSkuam9pbihcIi4wXCIpO1xuXG4gICAgICAvLyAzKSBcIjkuMFwiIC0+IFtcIjAwMDAwMDAwMFwiXCIsIFwiMDAwMDAwMDA5XCJdXG4gICAgICByZXR1cm4gbWFwKHZlcnNpb24uc3BsaXQoXCIuXCIpLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheSgyMCAtIGNodW5rLmxlbmd0aCkuam9pbihcIjBcIikgKyBjaHVuaztcbiAgICAgIH0pLnJldmVyc2UoKTtcbiAgICB9KTtcblxuICAgIC8vIGl0ZXJhdGUgaW4gcmV2ZXJzZSBvcmRlciBieSByZXZlcnNlZCBjaHVua3MgYXJyYXlcbiAgICB3aGlsZSAoLS1wcmVjaXNpb24gPj0gMCkge1xuICAgICAgLy8gNCkgY29tcGFyZTogXCIwMDAwMDAwMDlcIiA+IFwiMDAwMDAwMDEwXCIgPSBmYWxzZSAoYnV0IFwiOVwiID4gXCIxMFwiID0gdHJ1ZSlcbiAgICAgIGlmIChjaHVua3NbMF1bcHJlY2lzaW9uXSA+IGNodW5rc1sxXVtwcmVjaXNpb25dKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2h1bmtzWzBdW3ByZWNpc2lvbl0gPT09IGNodW5rc1sxXVtwcmVjaXNpb25dKSB7XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT09IDApIHtcbiAgICAgICAgICAvLyBhbGwgdmVyc2lvbiBjaHVua3MgYXJlIHNhbWVcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYnJvd3NlciBpcyB1bnN1cHBvcnRlZFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGJvd3Nlci5pc1Vuc3VwcG9ydGVkQnJvd3Nlcih7XG4gICAqICAgICBtc2llOiBcIjEwXCIsXG4gICAqICAgICBmaXJlZm94OiBcIjIzXCIsXG4gICAqICAgICBjaHJvbWU6IFwiMjlcIixcbiAgICogICAgIHNhZmFyaTogXCI1LjFcIixcbiAgICogICAgIG9wZXJhOiBcIjE2XCIsXG4gICAqICAgICBwaGFudG9tOiBcIjUzNFwiXG4gICAqICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG1pblZlcnNpb25zIG1hcCBvZiBtaW5pbWFsIHZlcnNpb24gdG8gYnJvd3NlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbc3RyaWN0TW9kZSA9IGZhbHNlXSBmbGFnIHRvIHJldHVybiBmYWxzZSBpZiBicm93c2VyIHdhc24ndCBmb3VuZCBpbiBtYXBcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgW3VhXSB1c2VyIGFnZW50IHN0cmluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNVbnN1cHBvcnRlZEJyb3dzZXIobWluVmVyc2lvbnMsIHN0cmljdE1vZGUsIHVhKSB7XG4gICAgdmFyIF9ib3dzZXIgPSBib3dzZXI7XG5cbiAgICAvLyBtYWtlIHN0cmljdE1vZGUgcGFyYW0gb3B0aW9uYWwgd2l0aCB1YSBwYXJhbSB1c2FnZVxuICAgIGlmICh0eXBlb2Ygc3RyaWN0TW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHVhID0gc3RyaWN0TW9kZTtcbiAgICAgIHN0cmljdE1vZGUgPSB2b2lkKDApO1xuICAgIH1cblxuICAgIGlmIChzdHJpY3RNb2RlID09PSB2b2lkKDApKSB7XG4gICAgICBzdHJpY3RNb2RlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh1YSkge1xuICAgICAgX2Jvd3NlciA9IGRldGVjdCh1YSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSBcIlwiICsgX2Jvd3Nlci52ZXJzaW9uO1xuICAgIGZvciAodmFyIGJyb3dzZXIgaW4gbWluVmVyc2lvbnMpIHtcbiAgICAgIGlmIChtaW5WZXJzaW9ucy5oYXNPd25Qcm9wZXJ0eShicm93c2VyKSkge1xuICAgICAgICBpZiAoX2Jvd3Nlclticm93c2VyXSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWluVmVyc2lvbnNbYnJvd3Nlcl0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgdmVyc2lvbiBpbiB0aGUgbWluVmVyc2lvbiBtYXAgc2hvdWxkIGJlIGEgc3RyaW5nOiAnICsgYnJvd3NlciArICc6ICcgKyBTdHJpbmcobWluVmVyc2lvbnMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBicm93c2VyIHZlcnNpb24gYW5kIG1pbiBzdXBwb3J0ZWQgdmVyc2lvbi5cbiAgICAgICAgICByZXR1cm4gY29tcGFyZVZlcnNpb25zKFt2ZXJzaW9uLCBtaW5WZXJzaW9uc1ticm93c2VyXV0pIDwgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHJpY3RNb2RlOyAvLyBub3QgZm91bmRcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBicm93c2VyIGlzIHN1cHBvcnRlZFxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG1pblZlcnNpb25zIG1hcCBvZiBtaW5pbWFsIHZlcnNpb24gdG8gYnJvd3NlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbc3RyaWN0TW9kZSA9IGZhbHNlXSBmbGFnIHRvIHJldHVybiBmYWxzZSBpZiBicm93c2VyIHdhc24ndCBmb3VuZCBpbiBtYXBcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgW3VhXSB1c2VyIGFnZW50IHN0cmluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2sobWluVmVyc2lvbnMsIHN0cmljdE1vZGUsIHVhKSB7XG4gICAgcmV0dXJuICFpc1Vuc3VwcG9ydGVkQnJvd3NlcihtaW5WZXJzaW9ucywgc3RyaWN0TW9kZSwgdWEpO1xuICB9XG5cbiAgYm93c2VyLmlzVW5zdXBwb3J0ZWRCcm93c2VyID0gaXNVbnN1cHBvcnRlZEJyb3dzZXI7XG4gIGJvd3Nlci5jb21wYXJlVmVyc2lvbnMgPSBjb21wYXJlVmVyc2lvbnM7XG4gIGJvd3Nlci5jaGVjayA9IGNoZWNrO1xuXG4gIC8qXG4gICAqIFNldCBvdXIgZGV0ZWN0IG1ldGhvZCB0byB0aGUgbWFpbiBib3dzZXIgb2JqZWN0IHNvIHdlIGNhblxuICAgKiByZXVzZSBpdCB0byB0ZXN0IG90aGVyIHVzZXIgYWdlbnRzLlxuICAgKiBUaGlzIGlzIG5lZWRlZCB0byBpbXBsZW1lbnQgZnV0dXJlIHRlc3RzLlxuICAgKi9cbiAgYm93c2VyLl9kZXRlY3QgPSBkZXRlY3Q7XG5cbiAgLypcbiAgICogU2V0IG91ciBkZXRlY3QgcHVibGljIG1ldGhvZCB0byB0aGUgbWFpbiBib3dzZXIgb2JqZWN0XG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGltcGxlbWVudCBib3dzZXIgaW4gc2VydmVyIHNpZGVcbiAgICovXG4gIGJvd3Nlci5kZXRlY3QgPSBkZXRlY3Q7XG4gIHJldHVybiBib3dzZXJcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYm93c2VyL3NyYy9ib3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBhZGQoeCwgeSkge1xuICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHlIb2xkZXIgPT4gYWRkKHgsIHlIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIHggKyB5O1xufVxuXG5mdW5jdGlvbiBhZGRJbmRleChmdW5jdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZm4sIC4uLnJlc3QpIHtcbiAgICBsZXQgY250ID0gMDtcbiAgICBjb25zdCBuZXdGbiA9ICguLi5hcmdzKSA9PiBmbi5hcHBseShudWxsLCBbLi4uYXJncywgY250KytdKTtcblxuICAgIHJldHVybiBmdW5jdG9yLmFwcGx5KG51bGwsIFtuZXdGbiwgLi4ucmVzdF0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhZGp1c3QoZm4sIGluZGV4LCBhcnIpIHtcbiAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gKGluZGV4SG9sZGVyLCBhcnJIb2xkZXIpID0+IGFkanVzdChmbiwgaW5kZXhIb2xkZXIsIGFyckhvbGRlcik7XG4gIH0gZWxzZSBpZiAoYXJyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXJySG9sZGVyID0+IGFkanVzdChmbiwgaW5kZXgsIGFyckhvbGRlcik7XG4gIH1cblxuICBjb25zdCBjbG9uZSA9IGFyci5jb25jYXQoKTtcblxuICByZXR1cm4gY2xvbmUubWFwKCh2YWwsIGtleSkgPT4ge1xuICAgIGlmIChrZXkgPT09IGluZGV4KSB7XG4gICAgICByZXR1cm4gZm4oYXJyW2luZGV4XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlck9iamVjdChmbiwgb2JqKSB7XG4gIGNvbnN0IHdpbGxSZXR1cm4gPSB7fTtcblxuICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKGZuKG9ialtwcm9wXSkpIHtcbiAgICAgIHdpbGxSZXR1cm5bcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdpbGxSZXR1cm47XG59XG5cbmZ1bmN0aW9uIGZpbHRlcihmbiwgYXJyKSB7XG4gIGlmIChhcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnJIb2xkZXIgPT4gZmlsdGVyKGZuLCBhcnJIb2xkZXIpO1xuICB9XG5cbiAgaWYgKGFyci5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmaWx0ZXJPYmplY3QoZm4sIGFycik7XG4gIH1cbiAgbGV0IGluZGV4ID0gLTE7XG4gIGxldCByZXNJbmRleCA9IDA7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGNvbnN0IHdpbGxSZXR1cm4gPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyW2luZGV4XTtcblxuICAgIGlmIChmbih2YWx1ZSkpIHtcbiAgICAgIHdpbGxSZXR1cm5bcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2lsbFJldHVybjtcbn1cblxuZnVuY3Rpb24gYWxsKGNvbmRpdGlvbiwgYXJyKSB7XG4gIGlmIChhcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnJIb2xkZXIgPT4gYWxsKGNvbmRpdGlvbiwgYXJySG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXIoY29uZGl0aW9uLCBhcnIpLmxlbmd0aCA9PT0gYXJyLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gYW55KGZuLCBhcnIpIHtcbiAgaWYgKGFyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyckhvbGRlciA9PiBhbnkoZm4sIGFyckhvbGRlcik7XG4gIH1cbiAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gIHdoaWxlIChjb3VudGVyIDwgYXJyLmxlbmd0aCkge1xuICAgIGlmIChmbihhcnJbY291bnRlcl0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY291bnRlcisrO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhbGxQYXNzKGNvbmRpdGlvbnMsIHgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4geEhvbGRlciA9PiBhbGxQYXNzKGNvbmRpdGlvbnMsIHhIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuICFhbnkoY29uZGl0aW9uID0+ICFjb25kaXRpb24oeCksIGNvbmRpdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBhbnlQYXNzKGNvbmRpdGlvbnMsIHgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4geEhvbGRlciA9PiBhbnlQYXNzKGNvbmRpdGlvbnMsIHhIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIGFueShjb25kaXRpb24gPT4gY29uZGl0aW9uKHgpKShjb25kaXRpb25zKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kKHgsIGFycikge1xuICBpZiAoYXJyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXJySG9sZGVyID0+IGFwcGVuZCh4LCBhcnJIb2xkZXIpO1xuICB9XG4gIGlmICh0eXBlb2YgYXJyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBgJHthcnJ9JHt4fWA7XG4gIH1cbiAgY29uc3QgY2xvbmUgPSBhcnIuY29uY2F0KCk7XG5cbiAgY2xvbmUucHVzaCh4KTtcblxuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIGJvdGgoeCwgeSkge1xuICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHlIb2xkZXIgPT4gYm90aCh4LCB5SG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dCA9PiB4KGlucHV0KSAmJiB5KGlucHV0KTtcbn1cblxuLy9UYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRpZnkvRnVuY3Rpb25hbC1MaWdodC1KUy9ibG9iL21hc3Rlci9jaDQubWRcbmZ1bmN0aW9uIGNvbXBvc2UoLi4uZm5zKSB7XG4gIHJldHVybiByZXN1bHQgPT4ge1xuICAgIGNvbnN0IGxpc3QgPSBmbnMuc2xpY2UoKTtcblxuICAgIHdoaWxlIChsaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdCA9IGxpc3QucG9wKCkocmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb25jYXQoeCwgeSkge1xuICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHlIb2xkZXIgPT4gY29uY2F0KHgsIHlIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJyA/IGAke3h9JHt5fWAgOiBbLi4ueCwgLi4ueV07XG59XG5cbmZ1bmN0aW9uIHR5cGUoYSkge1xuICBjb25zdCB0eXBlT2YgPSB0eXBlb2YgYTtcblxuICBpZiAoYSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnTnVsbCc7XG4gIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICdVbmRlZmluZWQnO1xuICB9IGVsc2UgaWYgKHR5cGVPZiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuICdCb29sZWFuJztcbiAgfSBlbHNlIGlmICh0eXBlT2YgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICdOdW1iZXInO1xuICB9IGVsc2UgaWYgKHR5cGVPZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gJ1N0cmluZyc7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiAnQXJyYXknO1xuICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gJ1JlZ0V4cCc7XG4gIH1cblxuICBjb25zdCBhc1N0ciA9IGEudG9TdHJpbmcoKTtcblxuICBpZiAoYXNTdHIuc3RhcnRzV2l0aCgnYXN5bmMnKSkge1xuICAgIHJldHVybiAnQXN5bmMnO1xuICB9IGVsc2UgaWYgKGFzU3RyID09PSAnW29iamVjdCBQcm9taXNlXScpIHtcbiAgICByZXR1cm4gJ1Byb21pc2UnO1xuICB9IGVsc2UgaWYgKGFzU3RyLmluY2x1ZGVzKCdmdW5jdGlvbicpIHx8IGFzU3RyLmluY2x1ZGVzKCc9PicpKSB7XG4gICAgcmV0dXJuICdGdW5jdGlvbic7XG4gIH1cblxuICByZXR1cm4gJ09iamVjdCc7XG59XG5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGJIb2xkZXIgPT4gZXF1YWxzKGEsIGJIb2xkZXIpO1xuICB9XG5cbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhVHlwZSA9IHR5cGUoYSk7XG5cbiAgaWYgKGFUeXBlICE9PSB0eXBlKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGFUeXBlID09PSAnQXJyYXknKSB7XG4gICAgY29uc3QgYUNsb25lID0gQXJyYXkuZnJvbShhKTtcbiAgICBjb25zdCBiQ2xvbmUgPSBBcnJheS5mcm9tKGIpO1xuXG4gICAgcmV0dXJuIGFDbG9uZS5zb3J0KCkudG9TdHJpbmcoKSA9PT0gYkNsb25lLnNvcnQoKS50b1N0cmluZygpO1xuICB9XG5cbiAgaWYgKGFUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG5cbiAgICBpZiAoYUtleXMubGVuZ3RoID09PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgIGlmIChhS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgZmxhZyA9IHRydWU7XG5cbiAgICAgIGFLZXlzLmZvckVhY2godmFsID0+IHtcbiAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICBjb25zdCBhVmFsVHlwZSA9IHR5cGUoYVt2YWxdKTtcbiAgICAgICAgICBjb25zdCBiVmFsVHlwZSA9IHR5cGUoYlt2YWxdKTtcblxuICAgICAgICAgIGlmIChhVmFsVHlwZSA9PT0gYlZhbFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChhVmFsVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGFbdmFsXSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhiW3ZhbF0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhW3ZhbF0pLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhbHMoYVt2YWxdLCBiW3ZhbF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFlcXVhbHMoYVt2YWxdLCBiW3ZhbF0pKSB7XG4gICAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBmbGFnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoeCwgYXJyKSB7XG4gIGlmIChhcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnJIb2xkZXIgPT4gY29udGFpbnMoeCwgYXJySG9sZGVyKTtcbiAgfVxuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IGZsYWcgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGFyci5sZW5ndGggJiYgIWZsYWcpIHtcbiAgICBpZiAoZXF1YWxzKGFycltpbmRleF0sIHgpKSB7XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmxhZztcbn1cblxuLy90YWtlbiBmcm9tIHRoZSBsYXN0IGNvbW1lbnQgb2YgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWt1a2xpcy81Mjk0MjQ4XG5cbmZ1bmN0aW9uIGN1cnJ5KGYsIGEgPSBbXSkge1xuICByZXR1cm4gKC4uLnApID0+IChvID0+IG8ubGVuZ3RoID49IGYubGVuZ3RoID8gZiguLi5vKSA6IGN1cnJ5KGYsIG8pKShbLi4uYSwgLi4ucF0pO1xufVxuXG52YXIgZGVjID0gKHggPT4geCAtIDEpO1xuXG5mdW5jdGlvbiBkZWZhdWx0VG8oZGVmYXVsdEFyZ3VtZW50LCBpbnB1dEFyZ3VtZW50KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGlucHV0QXJndW1lbnRIb2xkZXIgPT4gZGVmYXVsdFRvKGRlZmF1bHRBcmd1bWVudCwgaW5wdXRBcmd1bWVudEhvbGRlcik7XG4gIH1cblxuICByZXR1cm4gaW5wdXRBcmd1bWVudCA9PT0gdW5kZWZpbmVkIHx8IGlucHV0QXJndW1lbnQgPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKGlucHV0QXJndW1lbnQpID09PSB0cnVlID8gZGVmYXVsdEFyZ3VtZW50IDogaW5wdXRBcmd1bWVudDtcbn1cblxuZnVuY3Rpb24gZGl2aWRlKHgsIHkpIHtcbiAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB5SG9sZGVyID0+IGRpdmlkZSh4LCB5SG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiB4IC8geTtcbn1cblxuZnVuY3Rpb24gZHJvcChkcm9wTnVtYmVyLCB4KSB7XG4gIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4geEhvbGRlciA9PiBkcm9wKGRyb3BOdW1iZXIsIHhIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIHguc2xpY2UoZHJvcE51bWJlcik7XG59XG5cbmZ1bmN0aW9uIGRyb3BMYXN0KGRyb3BOdW1iZXIsIHgpIHtcbiAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB4SG9sZGVyID0+IGRyb3BMYXN0KGRyb3BOdW1iZXIsIHhIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIHguc2xpY2UoMCwgLWRyb3BOdW1iZXIpO1xufVxuXG5mdW5jdGlvbiBlaXRoZXIoeCwgeSkge1xuICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHlIb2xkZXIgPT4gZWl0aGVyKHgsIHlIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0ID0+IHgoaW5wdXQpIHx8IHkoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBlbmRzV2l0aCh4LCB5KSB7XG4gIGlmICh5ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4geUhvbGRlciA9PiBlbmRzV2l0aCh4LCB5SG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiB5LmVuZHNXaXRoKHgpO1xufVxuXG52YXIgaW5jID0gKHggPT4geCArIDEpO1xuXG5mdW5jdGlvbiBmaW5kKGZuLCBhcnIpIHtcbiAgaWYgKGFyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyckhvbGRlciA9PiBmaW5kKGZuLCBhcnJIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIGFyci5maW5kKGZuKTtcbn1cblxuZnVuY3Rpb24gZmluZEluZGV4KGZuLCBhcnIpIHtcbiAgaWYgKGFyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyckhvbGRlciA9PiBmaW5kSW5kZXgoZm4sIGFyckhvbGRlcik7XG4gIH1cbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gLTE7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICBpZiAoZm4oYXJyW2luZGV4XSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCB3aWxsUmV0dXJuKSB7XG4gIHdpbGxSZXR1cm4gPSB3aWxsUmV0dXJuID09PSB1bmRlZmluZWQgPyBbXSA6IHdpbGxSZXR1cm47XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJbaV0pKSB7XG4gICAgICBmbGF0dGVuKGFycltpXSwgd2lsbFJldHVybik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbGxSZXR1cm4ucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aWxsUmV0dXJuO1xufVxuXG5mdW5jdGlvbiBmbGlwRXhwb3J0KGZuKSB7XG4gIHJldHVybiAoLi4uaW5wdXQpID0+IHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gaG9sZGVyID0+IGZuKGhvbGRlciwgaW5wdXRbMF0pO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gZm4oaW5wdXRbMV0sIGlucHV0WzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbGlwKGZuLCAuLi5pbnB1dCkge1xuICByZXR1cm4gZmxpcEV4cG9ydChmbik7XG59XG5cbmZ1bmN0aW9uIHRhcChmbiwgeCkge1xuICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHhIb2xkZXIgPT4gdGFwKGZuLCB4SG9sZGVyKTtcbiAgfVxuXG4gIGZuKHgpO1xuXG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBtYXBPYmplY3QoZm4sIG9iaikge1xuICBjb25zdCB3aWxsUmV0dXJuID0ge307XG5cbiAgZm9yIChjb25zdCBwcm9wIGluIG9iaikge1xuICAgIHdpbGxSZXR1cm5bcHJvcF0gPSBmbihvYmpbcHJvcF0pO1xuICB9XG5cbiAgcmV0dXJuIHdpbGxSZXR1cm47XG59XG5cbmZ1bmN0aW9uIG1hcChmbiwgYXJyKSB7XG4gIGlmIChhcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnJIb2xkZXIgPT4gbWFwKGZuLCBhcnJIb2xkZXIpO1xuICB9XG4gIGlmIChhcnIubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbWFwT2JqZWN0KGZuLCBhcnIpO1xuICB9XG4gIGxldCBpbmRleCA9IC0xO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBjb25zdCB3aWxsUmV0dXJuID0gQXJyYXkobGVuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgIHdpbGxSZXR1cm5baW5kZXhdID0gZm4oYXJyW2luZGV4XSk7XG4gIH1cblxuICByZXR1cm4gd2lsbFJldHVybjtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaChmbiwgYXJyKSB7XG4gIGlmIChhcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnJIb2xkZXIgPT4gZm9yRWFjaChmbiwgYXJySG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiBtYXAodGFwKGZuKSwgYXJyKTtcbn1cblxuZnVuY3Rpb24gaGFzKHByb3AsIG9iaikge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gb2JqSG9sZGVyID0+IGhhcyhwcm9wLCBvYmpIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIG9ialtwcm9wXSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoZWFkKGEpIHtcbiAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhWzBdIHx8ICcnO1xuICB9XG5cbiAgcmV0dXJuIGFbMF07XG59XG5cbmZ1bmN0aW9uIGlmRWxzZShjb25kaXRpb24sIGlmRm4sIGVsc2VGbikge1xuICBpZiAoaWZGbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIChpZkZuSG9sZGVyLCBlbHNlRm5Ib2xkZXIpID0+IGlmRWxzZShjb25kaXRpb24sIGlmRm5Ib2xkZXIsIGVsc2VGbkhvbGRlcik7XG4gIH0gZWxzZSBpZiAoZWxzZUZuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZWxzZUZuSG9sZGVyID0+IGlmRWxzZShjb25kaXRpb24sIGlmRm4sIGVsc2VGbkhvbGRlcik7XG4gIH1cblxuICByZXR1cm4gaW5wdXQgPT4ge1xuICAgIGNvbnN0IGNvbmRpdGlvblJlc3VsdCA9IHR5cGVvZiBjb25kaXRpb24gPT09ICdib29sZWFuJyA/IGNvbmRpdGlvbiA6IGNvbmRpdGlvbihpbnB1dCk7XG5cbiAgICBpZiAoY29uZGl0aW9uUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gaWZGbihpbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsc2VGbihpbnB1dCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzKHhQcm90b3R5cGUsIHgpIHtcbiAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB4SG9sZGVyID0+IGlzKHhQcm90b3R5cGUsIHhIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIHggaW5zdGFuY2VvZiB4UHJvdG90eXBlIHx8IHguY29uc3RydWN0b3IgPT09IHhQcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIGlzTmlsKHgpIHtcbiAgcmV0dXJuIHggPT09IHVuZGVmaW5lZCB8fCB4ID09PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpbmNsdWRlcyh4LCB5KSB7XG4gIGlmICh5ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4geUhvbGRlciA9PiBpbmNsdWRlcyh4LCB5SG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiB5LmluY2x1ZGVzKHgpO1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHgsIGFycikge1xuICBpZiAoYXJyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXJySG9sZGVyID0+IGluZGV4T2YoeCwgYXJySG9sZGVyKTtcbiAgfVxuICBsZXQgaW5kZXggPSAtMTtcbiAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJbaW5kZXhdID09PSB4KSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogZW5kIC0gc3RhcnQgPj4+IDA7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICBjb25zdCByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaW5pdChhKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYS5zbGljZSgwLCAtMSk7XG4gIH1cblxuICByZXR1cm4gYS5sZW5ndGggPyBiYXNlU2xpY2UoYSwgMCwgLTEpIDogW107XG59XG5cbmZ1bmN0aW9uIGpvaW4oZ2x1ZSwgYXJyKSB7XG4gIGlmIChhcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnJIb2xkZXIgPT4gam9pbihnbHVlLCBhcnJIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIGFyci5qb2luKGdsdWUpO1xufVxuXG5mdW5jdGlvbiBsYXN0SW5kZXhPZih4LCBhcnIpIHtcbiAgaWYgKGFyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyckhvbGRlciA9PiBsYXN0SW5kZXhPZih4LCBhcnJIb2xkZXIpO1xuICB9XG4gIGxldCB3aWxsUmV0dXJuID0gLTE7XG5cbiAgYXJyLm1hcCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmIChlcXVhbHModmFsdWUsIHgpKSB7XG4gICAgICB3aWxsUmV0dXJuID0ga2V5O1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHdpbGxSZXR1cm47XG59XG5cbmZ1bmN0aW9uIGxhc3QoYSkge1xuICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXSB8fCAnJztcbiAgfVxuXG4gIHJldHVybiBhW2EubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIGxlbmd0aCh4KSB7XG4gIHJldHVybiB4Lmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gbWF0Y2gocmVnZXgsIHgpIHtcbiAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB4SG9sZGVyID0+IG1hdGNoKHJlZ2V4LCB4SG9sZGVyKTtcbiAgfVxuICBjb25zdCB3aWxsUmV0dXJuID0geC5tYXRjaChyZWdleCk7XG5cbiAgcmV0dXJuIHdpbGxSZXR1cm4gPT09IG51bGwgPyBbXSA6IHdpbGxSZXR1cm47XG59XG5cbmZ1bmN0aW9uIG1lcmdlKG9iaiwgbmV3UHJvcHMpIHtcbiAgaWYgKG5ld1Byb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3UHJvcHNIb2xkZXIgPT4gbWVyZ2Uob2JqLCBuZXdQcm9wc0hvbGRlcik7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqLCBuZXdQcm9wcyk7XG59XG5cbmZ1bmN0aW9uIG1vZHVsbyh4LCB5KSB7XG4gIGlmICh5ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4geUhvbGRlciA9PiBtb2R1bG8oeCwgeUhvbGRlcik7XG4gIH1cblxuICByZXR1cm4geCAlIHk7XG59XG5cbmZ1bmN0aW9uIG11bHRpcGx5KHgsIHkpIHtcbiAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB5SG9sZGVyID0+IG11bHRpcGx5KHgsIHlIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIHggKiB5O1xufVxuXG5mdW5jdGlvbiBub25lKGZuLCBhcnIpIHtcbiAgaWYgKGFyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyckhvbGRlciA9PiBub25lKGZuLCBhcnIpO1xuICB9XG5cbiAgcmV0dXJuIGFyci5maWx0ZXIoZm4pLmxlbmd0aCA9PT0gMDtcbn1cblxuZnVuY3Rpb24gb21pdChrZXlzLCBvYmopIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gb2JqSG9sZGVyID0+IG9taXQoa2V5cywgb2JqSG9sZGVyKTtcbiAgfVxuICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGtleXNWYWx1ZSA9IHR5cGVvZiBrZXlzID09PSAnc3RyaW5nJyA/IGtleXMgPSBrZXlzLnNwbGl0KCcsJykgOiBrZXlzO1xuXG4gIGNvbnN0IHdpbGxSZXR1cm4gPSB7fTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAoIWtleXNWYWx1ZS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICB3aWxsUmV0dXJuW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2lsbFJldHVybjtcbn1cblxuZnVuY3Rpb24gcGFydGlhbEN1cnJ5KGZuLCBpbnB1dEFyZ3VtZW50cyA9IHt9KSB7XG4gIHJldHVybiBpbnB1dEFyZ3VtZW50c0hvbGRlciA9PiB7XG4gICAgaWYgKHR5cGUoZm4pID09PSAnQXN5bmMnIHx8IHR5cGUoZm4pID09PSAnUHJvbWlzZScpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZuKG1lcmdlKGlucHV0QXJndW1lbnRzSG9sZGVyLCBpbnB1dEFyZ3VtZW50cykpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmbihtZXJnZShpbnB1dEFyZ3VtZW50c0hvbGRlciwgaW5wdXRBcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGF0aChwYXRoQXJyLCBvYmopIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gb2JqSG9sZGVyID0+IHBhdGgocGF0aEFyciwgb2JqSG9sZGVyKTtcbiAgfVxuICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgd2lsbFJldHVybiA9IG9iajtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gIGNvbnN0IHBhdGhBcnJWYWx1ZSA9IHR5cGVvZiBwYXRoQXJyID09PSAnc3RyaW5nJyA/IHBhdGhBcnIgPSBwYXRoQXJyLnNwbGl0KCcuJykgOiBwYXRoQXJyO1xuXG4gIHdoaWxlIChjb3VudGVyIDwgcGF0aEFyclZhbHVlLmxlbmd0aCkge1xuICAgIGlmICh3aWxsUmV0dXJuID09PSBudWxsIHx8IHdpbGxSZXR1cm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2lsbFJldHVybiA9IHdpbGxSZXR1cm5bcGF0aEFyclZhbHVlW2NvdW50ZXJdXTtcbiAgICBjb3VudGVyKys7XG4gIH1cblxuICByZXR1cm4gd2lsbFJldHVybjtcbn1cblxuZnVuY3Rpb24gcGF0aE9yKGRlZmF1bHRWYWx1ZSwgaW5wdXRQYXRoLCBpbnB1dE9iamVjdCkge1xuICByZXR1cm4gZGVmYXVsdFRvKGRlZmF1bHRWYWx1ZSwgcGF0aChpbnB1dFBhdGgsIGlucHV0T2JqZWN0KSk7XG59XG5cbnZhciBwYXRoT3IkMSA9IGN1cnJ5KHBhdGhPcik7XG5cbmZ1bmN0aW9uIHBpY2soa2V5cywgb2JqKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIG9iakhvbGRlciA9PiBwaWNrKGtleXMsIG9iakhvbGRlcik7XG4gIH1cbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qga2V5c1ZhbHVlID0gdHlwZW9mIGtleXMgPT09ICdzdHJpbmcnID8ga2V5cy5zcGxpdCgnLCcpIDoga2V5cztcblxuICBjb25zdCB3aWxsUmV0dXJuID0ge307XG4gIGxldCBjb3VudGVyID0gMDtcblxuICB3aGlsZSAoY291bnRlciA8IGtleXNWYWx1ZS5sZW5ndGgpIHtcbiAgICBpZiAoa2V5c1ZhbHVlW2NvdW50ZXJdIGluIG9iaikge1xuICAgICAgd2lsbFJldHVybltrZXlzVmFsdWVbY291bnRlcl1dID0gb2JqW2tleXNWYWx1ZVtjb3VudGVyXV07XG4gICAgfVxuICAgIGNvdW50ZXIrKztcbiAgfVxuXG4gIHJldHVybiB3aWxsUmV0dXJuO1xufVxuXG5mdW5jdGlvbiBwaWNrQWxsKGtleXMsIG9iaikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBvYmpIb2xkZXIgPT4gcGlja0FsbChrZXlzLCBvYmpIb2xkZXIpO1xuICB9XG4gIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGtleXNWYWx1ZSA9IHR5cGVvZiBrZXlzID09PSAnc3RyaW5nJyA/IGtleXMuc3BsaXQoJywnKSA6IGtleXM7XG5cbiAgY29uc3Qgd2lsbFJldHVybiA9IHt9O1xuICBsZXQgY291bnRlciA9IDA7XG5cbiAgd2hpbGUgKGNvdW50ZXIgPCBrZXlzVmFsdWUubGVuZ3RoKSB7XG4gICAgaWYgKGtleXNWYWx1ZVtjb3VudGVyXSBpbiBvYmopIHtcbiAgICAgIHdpbGxSZXR1cm5ba2V5c1ZhbHVlW2NvdW50ZXJdXSA9IG9ialtrZXlzVmFsdWVbY291bnRlcl1dO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWxsUmV0dXJuW2tleXNWYWx1ZVtjb3VudGVyXV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvdW50ZXIrKztcbiAgfVxuXG4gIHJldHVybiB3aWxsUmV0dXJuO1xufVxuXG5mdW5jdGlvbiBwaXBlKC4uLmZucykge1xuICByZXR1cm4gY29tcG9zZSguLi5mbnMucmV2ZXJzZSgpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2soa2V5VG9QbHVjaywgYXJyKSB7XG4gIGlmIChhcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnJIb2xkZXIgPT4gcGx1Y2soa2V5VG9QbHVjaywgYXJySG9sZGVyKTtcbiAgfVxuICBjb25zdCB3aWxsUmV0dXJuID0gW107XG5cbiAgbWFwKHZhbCA9PiB7XG4gICAgaWYgKCEodmFsW2tleVRvUGx1Y2tdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICB3aWxsUmV0dXJuLnB1c2godmFsW2tleVRvUGx1Y2tdKTtcbiAgICB9XG4gIH0sIGFycik7XG5cbiAgcmV0dXJuIHdpbGxSZXR1cm47XG59XG5cbmZ1bmN0aW9uIHByZXBlbmQoeCwgYXJyKSB7XG4gIGlmIChhcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnJIb2xkZXIgPT4gcHJlcGVuZCh4LCBhcnJIb2xkZXIpO1xuICB9XG4gIGlmICh0eXBlb2YgYXJyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBgJHt4fSR7YXJyfWA7XG4gIH1cbiAgY29uc3QgY2xvbmUgPSBhcnIuY29uY2F0KCk7XG5cbiAgY2xvbmUudW5zaGlmdCh4KTtcblxuICByZXR1cm4gY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHByb3Aoa2V5LCBvYmopIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG9iakhvbGRlciA9PiBwcm9wKGtleSwgb2JqSG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiBvYmpba2V5XTtcbn1cblxuZnVuY3Rpb24gcHJvcEVxKGtleSwgeCwgb2JqKSB7XG4gIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gKHhIb2xkZXIsIG9iakhvbGRlcikgPT4gcHJvcEVxKGtleSwgeEhvbGRlciwgb2JqSG9sZGVyKTtcbiAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvYmpIb2xkZXIgPT4gcHJvcEVxKGtleSwgeCwgb2JqSG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiBvYmpba2V5XSA9PT0geDtcbn1cblxuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZW5kSG9sZGVyID0+IHJhbmdlKHN0YXJ0LCBlbmRIb2xkZXIpO1xuICB9XG4gIGNvbnN0IHdpbGxSZXR1cm4gPSBbXTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHdpbGxSZXR1cm4ucHVzaChpKTtcbiAgfVxuXG4gIHJldHVybiB3aWxsUmV0dXJuO1xufVxuXG5mdW5jdGlvbiByZWR1Y2UoZm4sIGluaXRpYWxWYWx1ZSwgYXJyKSB7XG4gIGlmIChpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAoaW5pdGlhbFZhbHVlSG9sZGVyLCBhcnJIb2xkZXIpID0+IHJlZHVjZShmbiwgaW5pdGlhbFZhbHVlSG9sZGVyLCBhcnJIb2xkZXIpO1xuICB9IGVsc2UgaWYgKGFyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyckhvbGRlciA9PiByZWR1Y2UoZm4sIGluaXRpYWxWYWx1ZSwgYXJySG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiBhcnIucmVkdWNlKGZuLCBpbml0aWFsVmFsdWUpO1xufVxuXG5mdW5jdGlvbiByZWplY3QoZm4sIGFycikge1xuICBpZiAoYXJyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXJySG9sZGVyID0+IHJlamVjdChmbiwgYXJySG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXIoeCA9PiAhZm4oeCksIGFycik7XG59XG5cbmZ1bmN0aW9uIHJlcGVhdCh4LCBudW0pIHtcbiAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bUhvbGRlciA9PiByZXBlYXQoeCwgbnVtSG9sZGVyKTtcbiAgfVxuICBjb25zdCB3aWxsUmV0dXJuID0gQXJyYXkobnVtKTtcblxuICByZXR1cm4gd2lsbFJldHVybi5maWxsKHgpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlKHJlZ2V4LCByZXBsYWNlciwgc3RyKSB7XG4gIGlmIChyZXBsYWNlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIChyZXBsYWNlckhvbGRlciwgc3RySG9sZGVyKSA9PiByZXBsYWNlKHJlZ2V4LCByZXBsYWNlckhvbGRlciwgc3RySG9sZGVyKTtcbiAgfSBlbHNlIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzdHJIb2xkZXIgPT4gcmVwbGFjZShyZWdleCwgcmVwbGFjZXIsIHN0ckhvbGRlcik7XG4gIH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsIHJlcGxhY2VyKTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZShhcnIpIHtcbiAgY29uc3QgY2xvbmUgPSBhcnIuY29uY2F0KCk7XG5cbiAgcmV0dXJuIGNsb25lLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gc29ydChmbiwgYXJyKSB7XG4gIGlmIChhcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnJIb2xkZXIgPT4gc29ydChmbiwgYXJySG9sZGVyKTtcbiAgfVxuICBjb25zdCBhcnJDbG9uZSA9IGFyci5jb25jYXQoKTtcblxuICByZXR1cm4gYXJyQ2xvbmUuc29ydChmbik7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeShmbiwgYXJyKSB7XG4gIGlmIChhcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnJIb2xkZXIgPT4gc29ydEJ5KGZuLCBhcnJIb2xkZXIpO1xuICB9XG4gIGNvbnN0IGFyckNsb25lID0gYXJyLmNvbmNhdCgpO1xuXG4gIHJldHVybiBhcnJDbG9uZS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgZm5BID0gZm4oYSk7XG4gICAgY29uc3QgZm5CID0gZm4oYik7XG5cbiAgICByZXR1cm4gZm5BIDwgZm5CID8gLTEgOiBmbkEgPiBmbkIgPyAxIDogMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0KGdsdWUsIHN0cikge1xuICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gc3RySG9sZGVyID0+IHNwbGl0KGdsdWUsIHN0ckhvbGRlcik7XG4gIH1cblxuICByZXR1cm4gc3RyLnNwbGl0KGdsdWUpO1xufVxuXG5mdW5jdGlvbiBzcGxpdEV2ZXJ5KG51bSwgeCkge1xuICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHhIb2xkZXIgPT4gc3BsaXRFdmVyeShudW0sIHhIb2xkZXIpO1xuICB9XG5cbiAgY29uc3QgbnVtVmFsdWUgPSBudW0gPiAxID8gbnVtIDogMTtcblxuICBjb25zdCB3aWxsUmV0dXJuID0gW107XG4gIGxldCBjb3VudGVyID0gMDtcblxuICB3aGlsZSAoY291bnRlciA8IHgubGVuZ3RoKSB7XG4gICAgd2lsbFJldHVybi5wdXNoKHguc2xpY2UoY291bnRlciwgY291bnRlciArPSBudW1WYWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIHdpbGxSZXR1cm47XG59XG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoeCwgeSkge1xuICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHlIb2xkZXIgPT4gc3RhcnRzV2l0aCh4LCB5SG9sZGVyKTtcbiAgfVxuXG4gIHJldHVybiB5LnN0YXJ0c1dpdGgoeCk7XG59XG5cbmZ1bmN0aW9uIHN1YnRyYWN0KHgsIHkpIHtcbiAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB5SG9sZGVyID0+IHN1YnRyYWN0KHgsIHlIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIHggLSB5O1xufVxuXG5mdW5jdGlvbiB0YWlsKGFycikge1xuICByZXR1cm4gZHJvcCgxLCBhcnIpO1xufVxuXG5mdW5jdGlvbiB0YWtlKG51bSwgeCkge1xuICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHhIb2xkZXIgPT4gdGFrZShudW0sIHhIb2xkZXIpO1xuICB9XG4gIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geC5zbGljZSgwLCBudW0pO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VTbGljZSh4LCAwLCBudW0pO1xufVxuXG5mdW5jdGlvbiB0YWtlTGFzdChudW0sIHgpIHtcbiAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB4SG9sZGVyID0+IHRha2VMYXN0KG51bSwgeEhvbGRlcik7XG4gIH1cbiAgY29uc3QgbGVuID0geC5sZW5ndGg7XG5cbiAgbGV0IG51bVZhbHVlID0gbnVtID4gbGVuID8gbGVuIDogbnVtO1xuXG4gIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geC5zbGljZShsZW4gLSBudW1WYWx1ZSk7XG4gIH1cbiAgbnVtVmFsdWUgPSBsZW4gLSBudW1WYWx1ZTtcblxuICByZXR1cm4gYmFzZVNsaWNlKHgsIG51bVZhbHVlLCBsZW4pO1xufVxuXG5mdW5jdGlvbiB0ZXN0KHJlZ2V4LCBzdHIpIHtcbiAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHN0ckhvbGRlciA9PiB0ZXN0KHJlZ2V4LCBzdHJIb2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zZWFyY2gocmVnZXgpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gdGltZXMoZm4sIG51bSkge1xuICBpZiAobnVtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVtSG9sZGVyID0+IHRpbWVzKGZuLCBudW1Ib2xkZXIpO1xuICB9XG5cbiAgcmV0dXJuIG1hcChmbiwgcmFuZ2UoMCwgbnVtKSk7XG59XG5cbmZ1bmN0aW9uIHRvTG93ZXIoeCkge1xuICByZXR1cm4geC50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiB0b1VwcGVyKHgpIHtcbiAgcmV0dXJuIHgudG9VcHBlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcoeCkge1xuICByZXR1cm4geC50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiB1bmlxKGFycikge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgY29uc3Qgd2lsbFJldHVybiA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyLmxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyW2luZGV4XTtcblxuICAgIGlmICghY29udGFpbnModmFsdWUsIHdpbGxSZXR1cm4pKSB7XG4gICAgICB3aWxsUmV0dXJuLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aWxsUmV0dXJuO1xufVxuXG5mdW5jdGlvbiB1bmlxV2l0aChmbiwgYXJyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGFyckhvbGRlciA9PiB1bmlxV2l0aChmbiwgYXJySG9sZGVyKTtcbiAgfVxuXG4gIGxldCBpbmRleCA9IC0xO1xuICBjb25zdCB3aWxsUmV0dXJuID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnIubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhcnJbaW5kZXhdO1xuICAgIGNvbnN0IGZsYWcgPSBhbnkod2lsbFJldHVybkluc3RhbmNlID0+IGZuKHZhbHVlLCB3aWxsUmV0dXJuSW5zdGFuY2UpLCB3aWxsUmV0dXJuKTtcblxuICAgIGlmICghZmxhZykge1xuICAgICAgd2lsbFJldHVybi5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2lsbFJldHVybjtcbn1cblxuZnVuY3Rpb24gdXBkYXRlKGluZGV4LCBuZXdWYWx1ZSwgYXJyKSB7XG4gIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIChuZXdWYWx1ZUhvbGRlciwgYXJySG9sZGVyKSA9PiB1cGRhdGUoaW5kZXgsIG5ld1ZhbHVlSG9sZGVyLCBhcnJIb2xkZXIpO1xuICB9IGVsc2UgaWYgKGFyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyckhvbGRlciA9PiB1cGRhdGUoaW5kZXgsIG5ld1ZhbHVlLCBhcnJIb2xkZXIpO1xuICB9XG4gIGNvbnN0IGFyckNsb25lID0gYXJyLmNvbmNhdCgpO1xuXG4gIHJldHVybiBhcnJDbG9uZS5maWxsKG5ld1ZhbHVlLCBpbmRleCwgaW5kZXggKyAxKTtcbn1cblxuZnVuY3Rpb24gdmFsdWVzKG9iaikge1xuICBjb25zdCB3aWxsUmV0dXJuID0gW107XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgd2lsbFJldHVybi5wdXNoKG9ialtrZXldKTtcbiAgfVxuXG4gIHJldHVybiB3aWxsUmV0dXJuO1xufVxuXG5mdW5jdGlvbiB3aXRob3V0KGl0ZW1zVG9PbWl0LCBjb2xsZWN0aW9uKSB7XG4gIHJldHVybiByZWR1Y2UoKGFjY3VtLCBpdGVtKSA9PiAhY29udGFpbnMoaXRlbSwgaXRlbXNUb09taXQpID8gYWNjdW0uY29uY2F0KGl0ZW0pIDogYWNjdW0sIFtdLCBjb2xsZWN0aW9uKTtcbn1cblxuY29uc3QgYWx3YXlzID0geCA9PiAoKSA9PiB4O1xuY29uc3QgY29tcGxlbWVudCA9IGZuID0+IGlucHV0ID0+ICFmbihpbnB1dCk7XG5jb25zdCBGID0gKCkgPT4gZmFsc2U7XG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcbmNvbnN0IG5vdCA9IHggPT4gIXg7XG5jb25zdCBUID0gKCkgPT4gdHJ1ZTtcbmNvbnN0IHRyaW0gPSB4ID0+IHgudHJpbSgpO1xuXG5leHBvcnQgeyBhbHdheXMsIGNvbXBsZW1lbnQsIEYsIGlkZW50aXR5LCBub3QsIFQsIHRyaW0sIGFkZCwgYWRkSW5kZXgsIGFkanVzdCwgYWxsLCBhbGxQYXNzLCBhbnlQYXNzLCBhbnksIGFwcGVuZCwgYm90aCwgY29tcG9zZSwgY29uY2F0LCBjb250YWlucywgY3VycnksIGRlYywgZGVmYXVsdFRvLCBkaXZpZGUsIGRyb3AsIGRyb3BMYXN0LCBlaXRoZXIsIGVuZHNXaXRoLCBpbmMsIGVxdWFscywgZmlsdGVyLCBmaW5kLCBmaW5kSW5kZXgsIGZsYXR0ZW4sIGZsaXAsIGZvckVhY2gsIGhhcywgaGVhZCwgaWZFbHNlLCBpcywgaXNOaWwsIGluY2x1ZGVzLCBpbmRleE9mLCBpbml0LCBqb2luLCBsYXN0SW5kZXhPZiwgbGFzdCwgbGVuZ3RoLCBtYXAsIG1hdGNoLCBtZXJnZSwgbW9kdWxvLCBtdWx0aXBseSwgbm9uZSwgb21pdCwgcGFydGlhbEN1cnJ5LCBwYXRoLCBwYXRoT3IkMSBhcyBwYXRoT3IsIHBpY2ssIHBpY2tBbGwsIHBpcGUsIHBsdWNrLCBwcmVwZW5kLCBwcm9wLCBwcm9wRXEsIHJhbmdlLCByZWR1Y2UsIHJlamVjdCwgcmVwZWF0LCByZXBsYWNlLCByZXZlcnNlLCBzb3J0LCBzb3J0QnksIHNwbGl0LCBzcGxpdEV2ZXJ5LCBzdGFydHNXaXRoLCBzdWJ0cmFjdCwgdGFwLCB0YWlsLCB0YWtlLCB0YWtlTGFzdCwgdGVzdCwgdGltZXMsIHRvTG93ZXIsIHRvVXBwZXIsIHRvU3RyaW5nLCB0eXBlLCB1bmlxLCB1bmlxV2l0aCwgdXBkYXRlLCB2YWx1ZXMsIHdpdGhvdXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbWJkYS5lc20uanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYW1iZGEvZGlzdC9yYW1iZGEuZXNtLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogalF1ZXJ5IEVhc2luZyB2MS40LjEgLSBodHRwOi8vZ3NnZC5jby51ay9zYW5kYm94L2pxdWVyeS9lYXNpbmcvXG4gKiBPcGVuIHNvdXJjZSB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG4gKiBDb3B5cmlnaHQgwqkgMjAwOCBHZW9yZ2UgTWNHaW5sZXkgU21pdGhcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2dkc21pdGgvanF1ZXJ5LWVhc2luZy9tYXN0ZXIvTElDRU5TRVxuKi9cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtcImpxdWVyeVwiXSwgZnVuY3Rpb24oJCkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoJCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwianF1ZXJ5XCIpKTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3J5KGpRdWVyeSk7XG4gIH1cbn0pKGZ1bmN0aW9uKCQpIHtcbiAgLy8gUHJlc2VydmUgdGhlIG9yaWdpbmFsIGpRdWVyeSBcInN3aW5nXCIgZWFzaW5nIGFzIFwianN3aW5nXCJcbiAgJC5lYXNpbmcuanN3aW5nID0gJC5lYXNpbmcuc3dpbmc7XG5cbiAgdmFyIHBvdyA9IE1hdGgucG93LFxuICAgIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgc2luID0gTWF0aC5zaW4sXG4gICAgY29zID0gTWF0aC5jb3MsXG4gICAgUEkgPSBNYXRoLlBJLFxuICAgIGMxID0gMS43MDE1OCxcbiAgICBjMiA9IGMxICogMS41MjUsXG4gICAgYzMgPSBjMSArIDEsXG4gICAgYzQgPSAyICogUEkgLyAzLFxuICAgIGM1ID0gMiAqIFBJIC8gNC41O1xuXG4gIC8vIHggaXMgdGhlIGZyYWN0aW9uIG9mIGFuaW1hdGlvbiBwcm9ncmVzcywgaW4gdGhlIHJhbmdlIDAuLjFcbiAgZnVuY3Rpb24gYm91bmNlT3V0KHgpIHtcbiAgICB2YXIgbjEgPSA3LjU2MjUsXG4gICAgICBkMSA9IDIuNzU7XG4gICAgaWYgKHggPCAxIC8gZDEpIHtcbiAgICAgIHJldHVybiBuMSAqIHggKiB4O1xuICAgIH0gZWxzZSBpZiAoeCA8IDIgLyBkMSkge1xuICAgICAgcmV0dXJuIG4xICogKHggLT0gMS41IC8gZDEpICogeCArIDAuNzU7XG4gICAgfSBlbHNlIGlmICh4IDwgMi41IC8gZDEpIHtcbiAgICAgIHJldHVybiBuMSAqICh4IC09IDIuMjUgLyBkMSkgKiB4ICsgMC45Mzc1O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbjEgKiAoeCAtPSAyLjYyNSAvIGQxKSAqIHggKyAwLjk4NDM3NTtcbiAgICB9XG4gIH1cblxuICAkLmV4dGVuZCgkLmVhc2luZywge1xuICAgIGRlZjogXCJlYXNlT3V0UXVhZFwiLFxuICAgIHN3aW5nOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gJC5lYXNpbmdbJC5lYXNpbmcuZGVmXSh4KTtcbiAgICB9LFxuICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4ICogeDtcbiAgICB9LFxuICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gMSAtICgxIC0geCkgKiAoMSAtIHgpO1xuICAgIH0sXG4gICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggPCAwLjUgPyAyICogeCAqIHggOiAxIC0gcG93KC0yICogeCArIDIsIDIpIC8gMjtcbiAgICB9LFxuICAgIGVhc2VJbkN1YmljOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCAqIHggKiB4O1xuICAgIH0sXG4gICAgZWFzZU91dEN1YmljOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gMSAtIHBvdygxIC0geCwgMyk7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggPCAwLjUgPyA0ICogeCAqIHggKiB4IDogMSAtIHBvdygtMiAqIHggKyAyLCAzKSAvIDI7XG4gICAgfSxcbiAgICBlYXNlSW5RdWFydDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggKiB4ICogeCAqIHg7XG4gICAgfSxcbiAgICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAxIC0gcG93KDEgLSB4LCA0KTtcbiAgICB9LFxuICAgIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA8IDAuNSA/IDggKiB4ICogeCAqIHggKiB4IDogMSAtIHBvdygtMiAqIHggKyAyLCA0KSAvIDI7XG4gICAgfSxcbiAgICBlYXNlSW5RdWludDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggKiB4ICogeCAqIHggKiB4O1xuICAgIH0sXG4gICAgZWFzZU91dFF1aW50OiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gMSAtIHBvdygxIC0geCwgNSk7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggPCAwLjUgPyAxNiAqIHggKiB4ICogeCAqIHggKiB4IDogMSAtIHBvdygtMiAqIHggKyAyLCA1KSAvIDI7XG4gICAgfSxcbiAgICBlYXNlSW5TaW5lOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gMSAtIGNvcyh4ICogUEkgLyAyKTtcbiAgICB9LFxuICAgIGVhc2VPdXRTaW5lOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gc2luKHggKiBQSSAvIDIpO1xuICAgIH0sXG4gICAgZWFzZUluT3V0U2luZTogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIC0oY29zKFBJICogeCkgLSAxKSAvIDI7XG4gICAgfSxcbiAgICBlYXNlSW5FeHBvOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA9PT0gMCA/IDAgOiBwb3coMiwgMTAgKiB4IC0gMTApO1xuICAgIH0sXG4gICAgZWFzZU91dEV4cG86IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4ID09PSAxID8gMSA6IDEgLSBwb3coMiwgLTEwICogeCk7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRFeHBvOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA9PT0gMFxuICAgICAgICA/IDBcbiAgICAgICAgOiB4ID09PSAxXG4gICAgICAgICAgPyAxXG4gICAgICAgICAgOiB4IDwgMC41ID8gcG93KDIsIDIwICogeCAtIDEwKSAvIDIgOiAoMiAtIHBvdygyLCAtMjAgKiB4ICsgMTApKSAvIDI7XG4gICAgfSxcbiAgICBlYXNlSW5DaXJjOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gMSAtIHNxcnQoMSAtIHBvdyh4LCAyKSk7XG4gICAgfSxcbiAgICBlYXNlT3V0Q2lyYzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHNxcnQoMSAtIHBvdyh4IC0gMSwgMikpO1xuICAgIH0sXG4gICAgZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggPCAwLjVcbiAgICAgICAgPyAoMSAtIHNxcnQoMSAtIHBvdygyICogeCwgMikpKSAvIDJcbiAgICAgICAgOiAoc3FydCgxIC0gcG93KC0yICogeCArIDIsIDIpKSArIDEpIC8gMjtcbiAgICB9LFxuICAgIGVhc2VJbkVsYXN0aWM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4ID09PSAwXG4gICAgICAgID8gMFxuICAgICAgICA6IHggPT09IDEgPyAxIDogLXBvdygyLCAxMCAqIHggLSAxMCkgKiBzaW4oKHggKiAxMCAtIDEwLjc1KSAqIGM0KTtcbiAgICB9LFxuICAgIGVhc2VPdXRFbGFzdGljOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA9PT0gMFxuICAgICAgICA/IDBcbiAgICAgICAgOiB4ID09PSAxID8gMSA6IHBvdygyLCAtMTAgKiB4KSAqIHNpbigoeCAqIDEwIC0gMC43NSkgKiBjNCkgKyAxO1xuICAgIH0sXG4gICAgZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggPT09IDBcbiAgICAgICAgPyAwXG4gICAgICAgIDogeCA9PT0gMVxuICAgICAgICAgID8gMVxuICAgICAgICAgIDogeCA8IDAuNVxuICAgICAgICAgICAgPyAtKHBvdygyLCAyMCAqIHggLSAxMCkgKiBzaW4oKDIwICogeCAtIDExLjEyNSkgKiBjNSkpIC8gMlxuICAgICAgICAgICAgOiBwb3coMiwgLTIwICogeCArIDEwKSAqIHNpbigoMjAgKiB4IC0gMTEuMTI1KSAqIGM1KSAvIDIgKyAxO1xuICAgIH0sXG4gICAgZWFzZUluQmFjazogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGMzICogeCAqIHggKiB4IC0gYzEgKiB4ICogeDtcbiAgICB9LFxuICAgIGVhc2VPdXRCYWNrOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gMSArIGMzICogcG93KHggLSAxLCAzKSArIGMxICogcG93KHggLSAxLCAyKTtcbiAgICB9LFxuICAgIGVhc2VJbk91dEJhY2s6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4IDwgMC41XG4gICAgICAgID8gcG93KDIgKiB4LCAyKSAqICgoYzIgKyAxKSAqIDIgKiB4IC0gYzIpIC8gMlxuICAgICAgICA6IChwb3coMiAqIHggLSAyLCAyKSAqICgoYzIgKyAxKSAqICh4ICogMiAtIDIpICsgYzIpICsgMikgLyAyO1xuICAgIH0sXG4gICAgZWFzZUluQm91bmNlOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gMSAtIGJvdW5jZU91dCgxIC0geCk7XG4gICAgfSxcbiAgICBlYXNlT3V0Qm91bmNlOiBib3VuY2VPdXQsXG4gICAgZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA8IDAuNVxuICAgICAgICA/ICgxIC0gYm91bmNlT3V0KDEgLSAyICogeCkpIC8gMlxuICAgICAgICA6ICgxICsgYm91bmNlT3V0KDIgKiB4IC0gMSkpIC8gMjtcbiAgICB9XG4gIH0pO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnkuZWFzaW5nL2pxdWVyeS5lYXNpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogalF1ZXJ5IFNtb290aCBTY3JvbGwgLSB2Mi4yLjAgLSAyMDE3LTA1LTA1XG4gKiBodHRwczovL2dpdGh1Yi5jb20va3N3ZWRiZXJnL2pxdWVyeS1zbW9vdGgtc2Nyb2xsXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgS2FybCBTd2VkYmVyZ1xuICogTGljZW5zZWQgTUlUXG4gKi9cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbXCJqcXVlcnlcIl0sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBDb21tb25KU1xuICAgIGZhY3RvcnkocmVxdWlyZShcImpxdWVyeVwiKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZmFjdG9yeShqUXVlcnkpO1xuICB9XG59KShmdW5jdGlvbigkKSB7XG4gIHZhciB2ZXJzaW9uID0gXCIyLjIuMFwiO1xuICB2YXIgb3B0aW9uT3ZlcnJpZGVzID0ge307XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBleGNsdWRlOiBbXSxcbiAgICBleGNsdWRlV2l0aGluOiBbXSxcbiAgICBvZmZzZXQ6IDAsXG5cbiAgICAvLyBvbmUgb2YgJ3RvcCcgb3IgJ2xlZnQnXG4gICAgZGlyZWN0aW9uOiBcInRvcFwiLFxuXG4gICAgLy8gaWYgc2V0LCBiaW5kIGNsaWNrIGV2ZW50cyB0aHJvdWdoIGRlbGVnYXRpb25cbiAgICAvLyAgc3VwcG9ydGVkIHNpbmNlIGpRdWVyeSAxLjQuMlxuICAgIGRlbGVnYXRlU2VsZWN0b3I6IG51bGwsXG5cbiAgICAvLyBqUXVlcnkgc2V0IG9mIGVsZW1lbnRzIHlvdSB3aXNoIHRvIHNjcm9sbCAoZm9yICQuc21vb3RoU2Nyb2xsKS5cbiAgICAvLyAgaWYgbnVsbCAoZGVmYXVsdCksICQoJ2h0bWwsIGJvZHknKS5maXJzdFNjcm9sbGFibGUoKSBpcyB1c2VkLlxuICAgIHNjcm9sbEVsZW1lbnQ6IG51bGwsXG5cbiAgICAvLyBvbmx5IHVzZSBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgc2Nyb2xsVGFyZ2V0OiBudWxsLFxuXG4gICAgLy8gYXV0b21hdGljYWxseSBmb2N1cyB0aGUgdGFyZ2V0IGVsZW1lbnQgYWZ0ZXIgc2Nyb2xsaW5nIHRvIGl0XG4gICAgYXV0b0ZvY3VzOiBmYWxzZSxcblxuICAgIC8vIGZuKG9wdHMpIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBiZWZvcmUgc2Nyb2xsaW5nIG9jY3Vycy5cbiAgICAvLyBgdGhpc2AgaXMgdGhlIGVsZW1lbnQocykgYmVpbmcgc2Nyb2xsZWRcbiAgICBiZWZvcmVTY3JvbGw6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvLyBmbihvcHRzKSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgc2Nyb2xsaW5nIG9jY3Vycy5cbiAgICAvLyBgdGhpc2AgaXMgdGhlIHRyaWdnZXJpbmcgZWxlbWVudFxuICAgIGFmdGVyU2Nyb2xsOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLy8gZWFzaW5nIG5hbWUuIGpRdWVyeSBjb21lcyB3aXRoIFwic3dpbmdcIiBhbmQgXCJsaW5lYXIuXCIgRm9yIG90aGVycywgeW91J2xsIG5lZWQgYW4gZWFzaW5nIHBsdWdpblxuICAgIC8vIGZyb20galF1ZXJ5IFVJIG9yIGVsc2V3aGVyZVxuICAgIGVhc2luZzogXCJzd2luZ1wiLFxuXG4gICAgLy8gc3BlZWQgY2FuIGJlIGEgbnVtYmVyIG9yICdhdXRvJ1xuICAgIC8vIGlmICdhdXRvJywgdGhlIHNwZWVkIHdpbGwgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZm9ybXVsYTpcbiAgICAvLyAoY3VycmVudCBzY3JvbGwgcG9zaXRpb24gLSB0YXJnZXQgc2Nyb2xsIHBvc2l0aW9uKSAvIGF1dG9Db2VmZmljXG4gICAgc3BlZWQ6IDQwMCxcblxuICAgIC8vIGNvZWZmaWNpZW50IGZvciBcImF1dG9cIiBzcGVlZFxuICAgIGF1dG9Db2VmZmljaWVudDogMixcblxuICAgIC8vICQuZm4uc21vb3RoU2Nyb2xsIG9ubHk6IHdoZXRoZXIgdG8gcHJldmVudCB0aGUgZGVmYXVsdCBjbGljayBhY3Rpb25cbiAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxuICB9O1xuXG4gIHZhciBnZXRTY3JvbGxhYmxlID0gZnVuY3Rpb24ob3B0cykge1xuICAgIHZhciBzY3JvbGxhYmxlID0gW107XG4gICAgdmFyIHNjcm9sbGVkID0gZmFsc2U7XG4gICAgdmFyIGRpciA9IG9wdHMuZGlyICYmIG9wdHMuZGlyID09PSBcImxlZnRcIiA/IFwic2Nyb2xsTGVmdFwiIDogXCJzY3JvbGxUb3BcIjtcblxuICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbCA9ICQodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzID09PSBkb2N1bWVudCB8fCB0aGlzID09PSB3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgJiZcbiAgICAgICAgKHRoaXMgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCB0aGlzID09PSBkb2N1bWVudC5ib2R5KVxuICAgICAgKSB7XG4gICAgICAgIHNjcm9sbGFibGUucHVzaChkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50KTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbFtkaXJdKCkgPiAwKSB7XG4gICAgICAgIHNjcm9sbGFibGUucHVzaCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHNjcm9sbChUb3B8TGVmdCkgPT09IDAsIG51ZGdlIHRoZSBlbGVtZW50IDFweCBhbmQgc2VlIGlmIGl0IG1vdmVzXG4gICAgICAgIGVsW2Rpcl0oMSk7XG4gICAgICAgIHNjcm9sbGVkID0gZWxbZGlyXSgpID4gMDtcblxuICAgICAgICBpZiAoc2Nyb2xsZWQpIHtcbiAgICAgICAgICBzY3JvbGxhYmxlLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlbiBwdXQgaXQgYmFjaywgb2YgY291cnNlXG4gICAgICAgIGVsW2Rpcl0oMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIXNjcm9sbGFibGUubGVuZ3RoKSB7XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIElmIG5vIHNjcm9sbGFibGUgZWxlbWVudHMgYW5kIDxodG1sPiBoYXMgc2Nyb2xsLWJlaGF2aW9yOnNtb290aCBiZWNhdXNlXG4gICAgICAgIC8vIFwiV2hlbiB0aGlzIHByb3BlcnR5IGlzIHNwZWNpZmllZCBvbiB0aGUgcm9vdCBlbGVtZW50LCBpdCBhcHBsaWVzIHRvIHRoZSB2aWV3cG9ydCBpbnN0ZWFkLlwiXG4gICAgICAgIC8vIGFuZCBcIlRoZSBzY3JvbGwtYmVoYXZpb3IgcHJvcGVydHkgb2YgdGhlIOKApiBib2R5IGVsZW1lbnQgaXMgKm5vdCogcHJvcGFnYXRlZCB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgICAgLy8g4oaSIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS12aWV3LyNwcm9wZGVmLXNjcm9sbC1iZWhhdmlvclxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcyA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmXG4gICAgICAgICAgJCh0aGlzKS5jc3MoXCJzY3JvbGxCZWhhdmlvclwiKSA9PT0gXCJzbW9vdGhcIlxuICAgICAgICApIHtcbiAgICAgICAgICBzY3JvbGxhYmxlID0gW3RoaXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgc3RpbGwgbm8gc2Nyb2xsYWJsZSBlbGVtZW50cywgZmFsbCBiYWNrIHRvIDxib2R5PixcbiAgICAgICAgLy8gaWYgaXQncyBpbiB0aGUgalF1ZXJ5IGNvbGxlY3Rpb25cbiAgICAgICAgLy8gKGRvaW5nIHRoaXMgYmVjYXVzZSBTYWZhcmkgc2V0cyBzY3JvbGxUb3AgYXN5bmMsXG4gICAgICAgIC8vIHNvIGNhbid0IHNldCBpdCB0byAxIGFuZCBpbW1lZGlhdGVseSBnZXQgdGhlIHZhbHVlLilcbiAgICAgICAgaWYgKCFzY3JvbGxhYmxlLmxlbmd0aCAmJiB0aGlzLm5vZGVOYW1lID09PSBcIkJPRFlcIikge1xuICAgICAgICAgIHNjcm9sbGFibGUgPSBbdGhpc107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVzZSB0aGUgZmlyc3Qgc2Nyb2xsYWJsZSBlbGVtZW50IGlmIHdlJ3JlIGNhbGxpbmcgZmlyc3RTY3JvbGxhYmxlKClcbiAgICBpZiAob3B0cy5lbCA9PT0gXCJmaXJzdFwiICYmIHNjcm9sbGFibGUubGVuZ3RoID4gMSkge1xuICAgICAgc2Nyb2xsYWJsZSA9IFtzY3JvbGxhYmxlWzBdXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2Nyb2xsYWJsZTtcbiAgfTtcblxuICB2YXIgclJlbGF0aXZlID0gL14oW1xcLVxcK109KShcXGQrKS87XG5cbiAgJC5mbi5leHRlbmQoe1xuICAgIHNjcm9sbGFibGU6IGZ1bmN0aW9uKGRpcikge1xuICAgICAgdmFyIHNjcmwgPSBnZXRTY3JvbGxhYmxlLmNhbGwodGhpcywgeyBkaXI6IGRpciB9KTtcblxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHNjcmwpO1xuICAgIH0sXG4gICAgZmlyc3RTY3JvbGxhYmxlOiBmdW5jdGlvbihkaXIpIHtcbiAgICAgIHZhciBzY3JsID0gZ2V0U2Nyb2xsYWJsZS5jYWxsKHRoaXMsIHsgZWw6IFwiZmlyc3RcIiwgZGlyOiBkaXIgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhzY3JsKTtcbiAgICB9LFxuXG4gICAgc21vb3RoU2Nyb2xsOiBmdW5jdGlvbihvcHRpb25zLCBleHRyYSkge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIGlmIChvcHRpb25zID09PSBcIm9wdGlvbnNcIikge1xuICAgICAgICBpZiAoIWV4dHJhKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3QoKS5kYXRhKFwic3NPcHRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAgIHZhciBvcHRzID0gJC5leHRlbmQoJHRoaXMuZGF0YShcInNzT3B0c1wiKSB8fCB7fSwgZXh0cmEpO1xuXG4gICAgICAgICAgJCh0aGlzKS5kYXRhKFwic3NPcHRzXCIsIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5zbW9vdGhTY3JvbGwuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGVzY2FwZVNlbGVjdG9yID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oOnxcXC58XFwvKS9nLCBcIlxcXFwkMVwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGluayA9IHRoaXM7XG4gICAgICAgIHZhciAkbGluayA9ICQodGhpcyk7XG4gICAgICAgIHZhciB0aGlzT3B0cyA9ICQuZXh0ZW5kKHt9LCBvcHRzLCAkbGluay5kYXRhKFwic3NPcHRzXCIpIHx8IHt9KTtcbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSBvcHRzLmV4Y2x1ZGU7XG4gICAgICAgIHZhciBleGNsdWRlV2l0aGluID0gdGhpc09wdHMuZXhjbHVkZVdpdGhpbjtcbiAgICAgICAgdmFyIGVsQ291bnRlciA9IDA7XG4gICAgICAgIHZhciBld2xDb3VudGVyID0gMDtcbiAgICAgICAgdmFyIGluY2x1ZGUgPSB0cnVlO1xuICAgICAgICB2YXIgY2xpY2tPcHRzID0ge307XG4gICAgICAgIHZhciBsb2NhdGlvblBhdGggPSAkLnNtb290aFNjcm9sbC5maWx0ZXJQYXRoKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgICAgdmFyIGxpbmtQYXRoID0gJC5zbW9vdGhTY3JvbGwuZmlsdGVyUGF0aChsaW5rLnBhdGhuYW1lKTtcbiAgICAgICAgdmFyIGhvc3RNYXRjaCA9IGxvY2F0aW9uLmhvc3RuYW1lID09PSBsaW5rLmhvc3RuYW1lIHx8ICFsaW5rLmhvc3RuYW1lO1xuICAgICAgICB2YXIgcGF0aE1hdGNoID0gdGhpc09wdHMuc2Nyb2xsVGFyZ2V0IHx8IGxpbmtQYXRoID09PSBsb2NhdGlvblBhdGg7XG4gICAgICAgIHZhciB0aGlzSGFzaCA9IGVzY2FwZVNlbGVjdG9yKGxpbmsuaGFzaCk7XG5cbiAgICAgICAgaWYgKHRoaXNIYXNoICYmICEkKHRoaXNIYXNoKS5sZW5ndGgpIHtcbiAgICAgICAgICBpbmNsdWRlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXNPcHRzLnNjcm9sbFRhcmdldCAmJiAoIWhvc3RNYXRjaCB8fCAhcGF0aE1hdGNoIHx8ICF0aGlzSGFzaCkpIHtcbiAgICAgICAgICBpbmNsdWRlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hpbGUgKGluY2x1ZGUgJiYgZWxDb3VudGVyIDwgZXhjbHVkZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgkbGluay5pcyhlc2NhcGVTZWxlY3RvcihleGNsdWRlW2VsQ291bnRlcisrXSkpKSB7XG4gICAgICAgICAgICAgIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoaW5jbHVkZSAmJiBld2xDb3VudGVyIDwgZXhjbHVkZVdpdGhpbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgkbGluay5jbG9zZXN0KGV4Y2x1ZGVXaXRoaW5bZXdsQ291bnRlcisrXSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgIGlmICh0aGlzT3B0cy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkLmV4dGVuZChjbGlja09wdHMsIHRoaXNPcHRzLCB7XG4gICAgICAgICAgICBzY3JvbGxUYXJnZXQ6IHRoaXNPcHRzLnNjcm9sbFRhcmdldCB8fCB0aGlzSGFzaCxcbiAgICAgICAgICAgIGxpbms6IGxpbmtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgICQuc21vb3RoU2Nyb2xsKGNsaWNrT3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zLmRlbGVnYXRlU2VsZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5vZmYoXCJjbGljay5zbW9vdGhzY3JvbGxcIiwgb3B0aW9ucy5kZWxlZ2F0ZVNlbGVjdG9yKS5vbihcbiAgICAgICAgICBcImNsaWNrLnNtb290aHNjcm9sbFwiLFxuICAgICAgICAgIG9wdGlvbnMuZGVsZWdhdGVTZWxlY3RvcixcbiAgICAgICAgICBjbGlja0hhbmRsZXJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2ZmKFwiY2xpY2suc21vb3Roc2Nyb2xsXCIpLm9uKFwiY2xpY2suc21vb3Roc2Nyb2xsXCIsIGNsaWNrSGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGdldEV4cGxpY2l0T2Zmc2V0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIGV4cGxpY2l0ID0geyByZWxhdGl2ZTogXCJcIiB9O1xuICAgIHZhciBwYXJ0cyA9IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgJiYgclJlbGF0aXZlLmV4ZWModmFsKTtcblxuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICBleHBsaWNpdC5weCA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHBhcnRzKSB7XG4gICAgICBleHBsaWNpdC5yZWxhdGl2ZSA9IHBhcnRzWzFdO1xuICAgICAgZXhwbGljaXQucHggPSBwYXJzZUZsb2F0KHBhcnRzWzJdKSB8fCAwO1xuICAgIH1cblxuICAgIHJldHVybiBleHBsaWNpdDtcbiAgfTtcblxuICB2YXIgb25BZnRlclNjcm9sbCA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICB2YXIgJHRndCA9ICQob3B0cy5zY3JvbGxUYXJnZXQpO1xuXG4gICAgaWYgKG9wdHMuYXV0b0ZvY3VzICYmICR0Z3QubGVuZ3RoKSB7XG4gICAgICAkdGd0WzBdLmZvY3VzKCk7XG5cbiAgICAgIGlmICghJHRndC5pcyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAkdGd0LnByb3AoeyB0YWJJbmRleDogLTEgfSk7XG4gICAgICAgICR0Z3RbMF0uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRzLmFmdGVyU2Nyb2xsLmNhbGwob3B0cy5saW5rLCBvcHRzKTtcbiAgfTtcblxuICAkLnNtb290aFNjcm9sbCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHB4KSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IFwib3B0aW9uc1wiICYmIHR5cGVvZiBweCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuICQuZXh0ZW5kKG9wdGlvbk92ZXJyaWRlcywgcHgpO1xuICAgIH1cbiAgICB2YXIgb3B0cywgJHNjcm9sbGVyLCBzcGVlZCwgZGVsdGE7XG4gICAgdmFyIGV4cGxpY2l0T2Zmc2V0ID0gZ2V0RXhwbGljaXRPZmZzZXQob3B0aW9ucyk7XG4gICAgdmFyIHNjcm9sbFRhcmdldE9mZnNldCA9IHt9O1xuICAgIHZhciBzY3JvbGxlck9mZnNldCA9IDA7XG4gICAgdmFyIG9mZlBvcyA9IFwib2Zmc2V0XCI7XG4gICAgdmFyIHNjcm9sbERpciA9IFwic2Nyb2xsVG9wXCI7XG4gICAgdmFyIGFuaVByb3BzID0ge307XG4gICAgdmFyIGFuaU9wdHMgPSB7fTtcblxuICAgIGlmIChleHBsaWNpdE9mZnNldC5weCkge1xuICAgICAgb3B0cyA9ICQuZXh0ZW5kKFxuICAgICAgICB7IGxpbms6IG51bGwgfSxcbiAgICAgICAgJC5mbi5zbW9vdGhTY3JvbGwuZGVmYXVsdHMsXG4gICAgICAgIG9wdGlvbk92ZXJyaWRlc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cyA9ICQuZXh0ZW5kKFxuICAgICAgICB7IGxpbms6IG51bGwgfSxcbiAgICAgICAgJC5mbi5zbW9vdGhTY3JvbGwuZGVmYXVsdHMsXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIG9wdGlvbk92ZXJyaWRlc1xuICAgICAgKTtcblxuICAgICAgaWYgKG9wdHMuc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICBvZmZQb3MgPSBcInBvc2l0aW9uXCI7XG5cbiAgICAgICAgaWYgKG9wdHMuc2Nyb2xsRWxlbWVudC5jc3MoXCJwb3NpdGlvblwiKSA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgIG9wdHMuc2Nyb2xsRWxlbWVudC5jc3MoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChweCkge1xuICAgICAgICBleHBsaWNpdE9mZnNldCA9IGdldEV4cGxpY2l0T2Zmc2V0KHB4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY3JvbGxEaXIgPSBvcHRzLmRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgPyBcInNjcm9sbExlZnRcIiA6IHNjcm9sbERpcjtcblxuICAgIGlmIChvcHRzLnNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICRzY3JvbGxlciA9IG9wdHMuc2Nyb2xsRWxlbWVudDtcblxuICAgICAgaWYgKFxuICAgICAgICAhZXhwbGljaXRPZmZzZXQucHggJiZcbiAgICAgICAgIS9eKD86SFRNTHxCT0RZKSQvLnRlc3QoJHNjcm9sbGVyWzBdLm5vZGVOYW1lKVxuICAgICAgKSB7XG4gICAgICAgIHNjcm9sbGVyT2Zmc2V0ID0gJHNjcm9sbGVyW3Njcm9sbERpcl0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJHNjcm9sbGVyID0gJChcImh0bWwsIGJvZHlcIikuZmlyc3RTY3JvbGxhYmxlKG9wdHMuZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBiZWZvcmVTY3JvbGwgY2FsbGJhY2sgZnVuY3Rpb24gbXVzdCBmaXJlIGJlZm9yZSBjYWxjdWxhdGluZyBvZmZzZXRcbiAgICBvcHRzLmJlZm9yZVNjcm9sbC5jYWxsKCRzY3JvbGxlciwgb3B0cyk7XG5cbiAgICBzY3JvbGxUYXJnZXRPZmZzZXQgPSBleHBsaWNpdE9mZnNldC5weFxuICAgICAgPyBleHBsaWNpdE9mZnNldFxuICAgICAgOiB7XG4gICAgICAgICAgcmVsYXRpdmU6IFwiXCIsXG4gICAgICAgICAgcHg6XG4gICAgICAgICAgICAoJChvcHRzLnNjcm9sbFRhcmdldClbb2ZmUG9zXSgpICYmXG4gICAgICAgICAgICAgICQob3B0cy5zY3JvbGxUYXJnZXQpW29mZlBvc10oKVtvcHRzLmRpcmVjdGlvbl0pIHx8XG4gICAgICAgICAgICAwXG4gICAgICAgIH07XG5cbiAgICBhbmlQcm9wc1tzY3JvbGxEaXJdID1cbiAgICAgIHNjcm9sbFRhcmdldE9mZnNldC5yZWxhdGl2ZSArXG4gICAgICAoc2Nyb2xsVGFyZ2V0T2Zmc2V0LnB4ICsgc2Nyb2xsZXJPZmZzZXQgKyBvcHRzLm9mZnNldCk7XG5cbiAgICBzcGVlZCA9IG9wdHMuc3BlZWQ7XG5cbiAgICAvLyBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZSB0aGUgc3BlZWQgb2YgdGhlIHNjcm9sbCBiYXNlZCBvbiBkaXN0YW5jZSAvIGNvZWZmaWNpZW50XG4gICAgaWYgKHNwZWVkID09PSBcImF1dG9cIikge1xuICAgICAgLy8gJHNjcm9sbGVyW3Njcm9sbERpcl0oKSBpcyBwb3NpdGlvbiBiZWZvcmUgc2Nyb2xsLCBhbmlQcm9wc1tzY3JvbGxEaXJdIGlzIHBvc2l0aW9uIGFmdGVyXG4gICAgICAvLyBXaGVuIGRlbHRhIGlzIGdyZWF0ZXIsIHNwZWVkIHdpbGwgYmUgZ3JlYXRlci5cbiAgICAgIGRlbHRhID0gTWF0aC5hYnMoYW5pUHJvcHNbc2Nyb2xsRGlyXSAtICRzY3JvbGxlcltzY3JvbGxEaXJdKCkpO1xuXG4gICAgICAvLyBEaXZpZGUgdGhlIGRlbHRhIGJ5IHRoZSBjb2VmZmljaWVudFxuICAgICAgc3BlZWQgPSBkZWx0YSAvIG9wdHMuYXV0b0NvZWZmaWNpZW50O1xuICAgIH1cblxuICAgIGFuaU9wdHMgPSB7XG4gICAgICBkdXJhdGlvbjogc3BlZWQsXG4gICAgICBlYXNpbmc6IG9wdHMuZWFzaW5nLFxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvbkFmdGVyU2Nyb2xsKG9wdHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob3B0cy5zdGVwKSB7XG4gICAgICBhbmlPcHRzLnN0ZXAgPSBvcHRzLnN0ZXA7XG4gICAgfVxuXG4gICAgaWYgKCRzY3JvbGxlci5sZW5ndGgpIHtcbiAgICAgICRzY3JvbGxlci5zdG9wKCkuYW5pbWF0ZShhbmlQcm9wcywgYW5pT3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uQWZ0ZXJTY3JvbGwob3B0cyk7XG4gICAgfVxuICB9O1xuXG4gICQuc21vb3RoU2Nyb2xsLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAkLnNtb290aFNjcm9sbC5maWx0ZXJQYXRoID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gc3RyaW5nIHx8IFwiXCI7XG5cbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICAucmVwbGFjZSgvXlxcLy8sIFwiXCIpXG4gICAgICAucmVwbGFjZSgvKD86aW5kZXh8ZGVmYXVsdCkuW2EtekEtWl17Myw0fSQvLCBcIlwiKVxuICAgICAgLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgfTtcblxuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgJC5mbi5zbW9vdGhTY3JvbGwuZGVmYXVsdHMgPSBkZWZhdWx0cztcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXNtb290aC1zY3JvbGwvanF1ZXJ5LnNtb290aC1zY3JvbGwuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXCJqcXVlcnlcIl0sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuanF1ZXJ5X2RvdGRvdGRvdF9qcyA9IGZhY3Rvcnkocm9vdC5qUXVlcnkpO1xuICB9XG59KSh0aGlzLCBmdW5jdGlvbihqUXVlcnkpIHtcbiAgLypcbiAqXHRqUXVlcnkgZG90ZG90ZG90IDMuMS4wXG4gKlx0QHJlcXVpcmVzIGpRdWVyeSAxLjcuMCBvciBsYXRlclxuICpcbiAqXHRkb3Rkb3Rkb3QuZnJlYnNpdGUubmxcbiAqXG4gKlx0Q29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICpcdHd3dy5mcmVic2l0ZS5ubFxuICpcbiAqXHRMaWNlbnNlOiBDQy1CWS1OQy00LjBcbiAqXHRodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy80LjAvXG4gKi9cbiAgIShmdW5jdGlvbih0KSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gZSgpIHtcbiAgICAgIChoID0gdCh3aW5kb3cpKSxcbiAgICAgICAgKHMgPSB7fSksXG4gICAgICAgIChyID0ge30pLFxuICAgICAgICAobyA9IHt9KSxcbiAgICAgICAgdC5lYWNoKFtzLCByLCBvXSwgZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgIGUuYWRkID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgdCA9IHQuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgbiA9IDAsIGkgPSB0Lmxlbmd0aDsgbiA8IGk7IG4rKykgZVt0W25dXSA9IGUuZGRkKHRbbl0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICAocy5kZGQgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgcmV0dXJuIFwiZGRkLVwiICsgdDtcbiAgICAgICAgfSksXG4gICAgICAgIHMuYWRkKFwidHJ1bmNhdGVkIGtlZXAgdGV4dFwiKSxcbiAgICAgICAgKHIuZGRkID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgIHJldHVybiBcImRkZC1cIiArIHQ7XG4gICAgICAgIH0pLFxuICAgICAgICByLmFkZChcInRleHRcIiksXG4gICAgICAgIChvLmRkZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCArIFwiLmRkZFwiO1xuICAgICAgICB9KSxcbiAgICAgICAgby5hZGQoXCJyZXNpemVcIiksXG4gICAgICAgIChlID0gZnVuY3Rpb24oKSB7fSk7XG4gICAgfVxuICAgIHZhciBuID0gXCJkb3Rkb3Rkb3RcIixcbiAgICAgIGkgPSBcIjMuMS4wXCI7XG4gICAgaWYgKCEodFtuXSAmJiB0W25dLnZlcnNpb24gPiBpKSkge1xuICAgICAgKHRbbl0gPSBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgICh0aGlzLiRkb3QgPSB0KSxcbiAgICAgICAgICAodGhpcy5hcGkgPSBbXG4gICAgICAgICAgICBcImdldEluc3RhbmNlXCIsXG4gICAgICAgICAgICBcInRydW5jYXRlXCIsXG4gICAgICAgICAgICBcInJlc3RvcmVcIixcbiAgICAgICAgICAgIFwiZGVzdHJveVwiLFxuICAgICAgICAgICAgXCJ3YXRjaFwiLFxuICAgICAgICAgICAgXCJ1bndhdGNoXCJcbiAgICAgICAgICBdKSxcbiAgICAgICAgICAodGhpcy5vcHRzID0gZSk7XG4gICAgICAgIHZhciBpID0gdGhpcy4kZG90LmRhdGEobik7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgaSAmJiBpLmRlc3Ryb3koKSxcbiAgICAgICAgICB0aGlzLmluaXQoKSxcbiAgICAgICAgICB0aGlzLnRydW5jYXRlKCksXG4gICAgICAgICAgdGhpcy5vcHRzLndhdGNoICYmIHRoaXMud2F0Y2goKSxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9KSxcbiAgICAgICAgKHRbbl0udmVyc2lvbiA9IGkpLFxuICAgICAgICAodFtuXS51bmlxdWVJZCA9IDApLFxuICAgICAgICAodFtuXS5kZWZhdWx0cyA9IHtcbiAgICAgICAgICBlbGxpcHNpczogXCLigKYgXCIsXG4gICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKHQpIHt9LFxuICAgICAgICAgIHRydW5jYXRlOiBcIndvcmRcIixcbiAgICAgICAgICB0b2xlcmFuY2U6IDAsXG4gICAgICAgICAga2VlcDogbnVsbCxcbiAgICAgICAgICB3YXRjaDogXCJ3aW5kb3dcIixcbiAgICAgICAgICBoZWlnaHQ6IG51bGxcbiAgICAgICAgfSksXG4gICAgICAgICh0W25dLnByb3RvdHlwZSA9IHtcbiAgICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICh0aGlzLndhdGNoVGltZW91dCA9IG51bGwpLFxuICAgICAgICAgICAgICAodGhpcy53YXRjaEludGVydmFsID0gbnVsbCksXG4gICAgICAgICAgICAgICh0aGlzLnVuaXF1ZUlkID0gdFtuXS51bmlxdWVJZCsrKSxcbiAgICAgICAgICAgICAgKHRoaXMub3JpZ2luYWxDb250ZW50ID0gdGhpcy4kZG90LmNvbnRlbnRzKCkpLFxuICAgICAgICAgICAgICAodGhpcy5vcmlnaW5hbFN0eWxlID0gdGhpcy4kZG90LmF0dHIoXCJzdHlsZVwiKSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgXCJicmVhay13b3JkXCIgIT09IHRoaXMuJGRvdC5jc3MoXCJ3b3JkLXdyYXBcIikgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiRkb3QuY3NzKFwid29yZC13cmFwXCIsIFwiYnJlYWstd29yZFwiKSxcbiAgICAgICAgICAgICAgXCJub3dyYXBcIiA9PT0gdGhpcy4kZG90LmNzcyhcIndoaXRlLXNwYWNlXCIpICYmXG4gICAgICAgICAgICAgICAgdGhpcy4kZG90LmNzcyhcIndoaXRlLXNwYWNlXCIsIFwibm9ybWFsXCIpLFxuICAgICAgICAgICAgICBudWxsID09PSB0aGlzLm9wdHMuaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0cy5oZWlnaHQgPSB0aGlzLl9nZXRNYXhIZWlnaHQoKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydW5jYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgICAgICh0aGlzLiRpbm5lciA9IHRoaXMuJGRvdFxuICAgICAgICAgICAgICAud3JhcElubmVyKFwiPGRpdiAvPlwiKVxuICAgICAgICAgICAgICAuY2hpbGRyZW4oKVxuICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgIHRoaXMuJGlubmVyXG4gICAgICAgICAgICAgICAgLmNvbnRlbnRzKClcbiAgICAgICAgICAgICAgICAuZGV0YWNoKClcbiAgICAgICAgICAgICAgICAuZW5kKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMub3JpZ2luYWxDb250ZW50LmNsb25lKCEwKSksXG4gICAgICAgICAgICAgIHRoaXMuJGlubmVyLmZpbmQoXCJzY3JpcHQsIHN0eWxlXCIpLmFkZENsYXNzKHMua2VlcCksXG4gICAgICAgICAgICAgIHRoaXMub3B0cy5rZWVwICYmXG4gICAgICAgICAgICAgICAgdGhpcy4kaW5uZXIuZmluZCh0aGlzLm9wdHMua2VlcCkuYWRkQ2xhc3Mocy5rZWVwKSxcbiAgICAgICAgICAgICAgdGhpcy4kaW5uZXJcbiAgICAgICAgICAgICAgICAuZmluZChcIipcIilcbiAgICAgICAgICAgICAgICAubm90KFwiLlwiICsgcy5rZWVwKVxuICAgICAgICAgICAgICAgIC5hZGQodGhpcy4kaW5uZXIpXG4gICAgICAgICAgICAgICAgLmNvbnRlbnRzKClcbiAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgaSA9IHQodGhpcyk7XG4gICAgICAgICAgICAgICAgICBpZiAoMyA9PSBuLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICBpXG4gICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pcyhcInRhYmxlLCB0aGVhZCwgdGZvb3QsIHRyLCBkbCwgdWwsIG9sLCB2aWRlb1wiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgaS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkucGFyZW50KCkuY29udGVudHMoKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0KFxuICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMudGV4dCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZS5fX2dldFRleHRDb250ZW50KG4pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8L3NwYW4+XCJcbiAgICAgICAgICAgICAgICAgICAgICApLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgaS5yZXBsYWNlV2l0aChyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIDggPT0gbi5ub2RlVHlwZSAmJiBpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAodGhpcy5tYXhIZWlnaHQgPSB0aGlzLl9nZXRNYXhIZWlnaHQoKSk7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuX3RydW5jYXRlTm9kZSh0aGlzLiRkb3QpO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdGhpcy4kZG90W24gPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKHMudHJ1bmNhdGVkKSxcbiAgICAgICAgICAgICAgdGhpcy4kaW5uZXIuZmluZChcIi5cIiArIHMudGV4dCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0KHRoaXMpLnJlcGxhY2VXaXRoKHQodGhpcykuY29udGVudHMoKSk7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0aGlzLiRpbm5lci5maW5kKFwiLlwiICsgcy5rZWVwKS5yZW1vdmVDbGFzcyhzLmtlZXApLFxuICAgICAgICAgICAgICB0aGlzLiRpbm5lci5yZXBsYWNlV2l0aCh0aGlzLiRpbm5lci5jb250ZW50cygpKSxcbiAgICAgICAgICAgICAgKHRoaXMuJGlubmVyID0gbnVsbCksXG4gICAgICAgICAgICAgIHRoaXMub3B0cy5jYWxsYmFjay5jYWxsKHRoaXMuJGRvdFswXSwgbiksXG4gICAgICAgICAgICAgIG5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudW53YXRjaCgpLFxuICAgICAgICAgICAgICB0aGlzLiRkb3RcbiAgICAgICAgICAgICAgICAuY29udGVudHMoKVxuICAgICAgICAgICAgICAgIC5kZXRhY2goKVxuICAgICAgICAgICAgICAgIC5lbmQoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQodGhpcy5vcmlnaW5hbENvbnRlbnQpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJzdHlsZVwiLCB0aGlzLm9yaWdpbmFsU3R5bGUpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHMudHJ1bmNhdGVkKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCksIHRoaXMuJGRvdC5kYXRhKG4sIG51bGwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd2F0Y2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy51bndhdGNoKCk7XG4gICAgICAgICAgICB2YXIgZSA9IHt9O1xuICAgICAgICAgICAgXCJ3aW5kb3dcIiA9PSB0aGlzLm9wdHMud2F0Y2hcbiAgICAgICAgICAgICAgPyBoLm9uKG8ucmVzaXplICsgdC51bmlxdWVJZCwgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgdC53YXRjaFRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHQud2F0Y2hUaW1lb3V0KSxcbiAgICAgICAgICAgICAgICAgICAgKHQud2F0Y2hUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlID0gdC5fd2F0Y2hTaXplcyhlLCBoLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDApKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICA6ICh0aGlzLndhdGNoSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGUgPSB0Ll93YXRjaFNpemVzKGUsIHQuJGRvdCwgXCJpbm5lcldpZHRoXCIsIFwiaW5uZXJIZWlnaHRcIik7XG4gICAgICAgICAgICAgICAgfSwgNTAwKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1bndhdGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGgub2ZmKG8ucmVzaXplICsgdGhpcy51bmlxdWVJZCksXG4gICAgICAgICAgICAgIHRoaXMud2F0Y2hJbnRlcnZhbCAmJiBjbGVhckludGVydmFsKHRoaXMud2F0Y2hJbnRlcnZhbCksXG4gICAgICAgICAgICAgIHRoaXMud2F0Y2hUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLndhdGNoVGltZW91dCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBfYXBpOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgICAgbiA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdC5lYWNoKHRoaXMuYXBpLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzO1xuICAgICAgICAgICAgICAgIG5baV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0ID0gZVtpXS5hcHBseShlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIHQgPyBuIDogdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIF90cnVuY2F0ZU5vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcyxcbiAgICAgICAgICAgICAgaSA9ICExLFxuICAgICAgICAgICAgICByID0gITE7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICB0KFxuICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICAgICAgIC5jaGlsZHJlbigpXG4gICAgICAgICAgICAgICAgICAuZ2V0KClcbiAgICAgICAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5ub3QoXCIuXCIgKyBzLmtlZXApXG4gICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZSA9ICh0KHRoaXMpLmNvbnRlbnRzKClbMF0sIHQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpICYmICFlLmhhc0NsYXNzKHMua2VlcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuY2hpbGRyZW4oKS5sZW5ndGgpIGkgPSBuLl90cnVuY2F0ZU5vZGUoZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFuLl9maXRzKCkgfHwgcikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gdChcIjxzcGFuPlwiKS5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKGUucmVwbGFjZVdpdGgobyksIGUuZGV0YWNoKCksIG4uX2ZpdHMoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm5vZGVcIiA9PSBuLm9wdHMudHJ1bmNhdGUpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucmVwbGFjZVdpdGgoZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChpID0gbi5fdHJ1bmNhdGVXb3JkKGUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaSB8fCAoKHIgPSAhMCksIGUuZGV0YWNoKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBvLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGUuY29udGVudHMoKS5sZW5ndGggfHwgZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIF90cnVuY2F0ZVdvcmQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdC5jb250ZW50cygpWzBdO1xuICAgICAgICAgICAgaWYgKCFlKSByZXR1cm4gITE7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaSA9IHRoaXMuX19nZXRUZXh0Q29udGVudChlKSxcbiAgICAgICAgICAgICAgICBzID0gaS5pbmRleE9mKFwiIFwiKSAhPT0gLTEgPyBcIiBcIiA6IFwi44CAXCIsXG4gICAgICAgICAgICAgICAgciA9IGkuc3BsaXQocyksXG4gICAgICAgICAgICAgICAgbyA9IFwiXCIsXG4gICAgICAgICAgICAgICAgaCA9IHIubGVuZ3RoO1xuICAgICAgICAgICAgICBoID49IDA7XG4gICAgICAgICAgICAgIGgtLVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgoKG8gPSByLnNsaWNlKDAsIGgpLmpvaW4ocykpLCAwID09IGgpKVxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICBcImxldHRlclwiID09IG4ub3B0cy50cnVuY2F0ZSAmJlxuICAgICAgICAgICAgICAgICAgKG4uX19zZXRUZXh0Q29udGVudChlLCByLnNsaWNlKDAsIGggKyAxKS5qb2luKHMpKSxcbiAgICAgICAgICAgICAgICAgIG4uX3RydW5jYXRlTGV0dGVyKGUpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBvLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIChuLl9fc2V0VGV4dENvbnRlbnQoZSwgbi5fYWRkRWxsaXBzaXMobykpLCBuLl9maXRzKCkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgXCJsZXR0ZXJcIiAhPSBuLm9wdHMudHJ1bmNhdGUgfHxcbiAgICAgICAgICAgICAgICAgIChuLl9fc2V0VGV4dENvbnRlbnQoZSwgci5zbGljZSgwLCBoICsgMSkuam9pbihzKSksXG4gICAgICAgICAgICAgICAgICBuLl90cnVuY2F0ZUxldHRlcihlKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgX3RydW5jYXRlTGV0dGVyOiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbiA9IHRoaXMuX19nZXRUZXh0Q29udGVudCh0KSxcbiAgICAgICAgICAgICAgICBpID0gbi5zcGxpdChcIlwiKSxcbiAgICAgICAgICAgICAgICBzID0gXCJcIixcbiAgICAgICAgICAgICAgICByID0gaS5sZW5ndGg7XG4gICAgICAgICAgICAgIHIgPj0gMDtcbiAgICAgICAgICAgICAgci0tXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKHMgPSBpLnNsaWNlKDAsIHIpLmpvaW4oXCJcIikpLFxuICAgICAgICAgICAgICAgIHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAoZS5fX3NldFRleHRDb250ZW50KHQsIGUuX2FkZEVsbGlwc2lzKHMpKSwgZS5fZml0cygpKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIF9maXRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHRoaXMuJGlubmVyLmlubmVySGVpZ2h0KCkgPD0gdGhpcy5tYXhIZWlnaHQgKyB0aGlzLm9wdHMudG9sZXJhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgX2FkZEVsbGlwc2lzOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgbiA9IFtcIiBcIiwgXCLjgIBcIiwgXCIsXCIsIFwiO1wiLCBcIi5cIiwgXCIhXCIsIFwiP1wiXTtcbiAgICAgICAgICAgICAgdC5pbkFycmF5KGUuc2xpY2UoLTEpLCBuKSA+IC0xO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGUgPSBlLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIHJldHVybiAoZSArPSB0aGlzLm9wdHMuZWxsaXBzaXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgX2dldE1heEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgdGhpcy5vcHRzLmhlaWdodCkgcmV0dXJuIHRoaXMub3B0cy5oZWlnaHQ7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICB2YXIgdCA9IFtcIm1heEhlaWdodFwiLCBcImhlaWdodFwiXSwgZSA9IDAsIG4gPSAwO1xuICAgICAgICAgICAgICBuIDwgdC5sZW5ndGg7XG4gICAgICAgICAgICAgIG4rK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kZG90WzBdKVt0W25dXSksXG4gICAgICAgICAgICAgICAgXCJweFwiID09IGUuc2xpY2UoLTIpKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBlID0gcGFyc2VGbG9hdChlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQgPSBbXTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy4kZG90LmNzcyhcImJveFNpemluZ1wiKSkge1xuICAgICAgICAgICAgICBjYXNlIFwiYm9yZGVyLWJveFwiOlxuICAgICAgICAgICAgICAgIHQucHVzaChcImJvcmRlclRvcFdpZHRoXCIpLCB0LnB1c2goXCJib3JkZXJCb3R0b21XaWR0aFwiKTtcbiAgICAgICAgICAgICAgY2FzZSBcInBhZGRpbmctYm94XCI6XG4gICAgICAgICAgICAgICAgdC5wdXNoKFwicGFkZGluZ1RvcFwiKSwgdC5wdXNoKFwicGFkZGluZ0JvdHRvbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICB2YXIgaSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGRvdFswXSlbdFtuXV07XG4gICAgICAgICAgICAgIFwicHhcIiA9PSBpLnNsaWNlKC0yKSAmJiAoZSAtPSBwYXJzZUZsb2F0KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChlLCAwKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIF93YXRjaFNpemVzOiBmdW5jdGlvbih0LCBlLCBuLCBpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kZG90LmlzKFwiOnZpc2libGVcIikpIHtcbiAgICAgICAgICAgICAgdmFyIHMgPSB7IHdpZHRoOiBlW25dKCksIGhlaWdodDogZVtpXSgpIH07XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHQud2lkdGggPT0gcy53aWR0aCAmJiB0LmhlaWdodCA9PSBzLmhlaWdodCkgfHwgdGhpcy50cnVuY2F0ZSgpLFxuICAgICAgICAgICAgICAgIHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgX19nZXRUZXh0Q29udGVudDogZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgdmFyIGUgPSBbXCJub2RlVmFsdWVcIiwgXCJ0ZXh0Q29udGVudFwiLCBcImlubmVyVGV4dFwiXSwgbiA9IDA7XG4gICAgICAgICAgICAgIG4gPCBlLmxlbmd0aDtcbiAgICAgICAgICAgICAgbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0W2Vbbl1dKSByZXR1cm4gdFtlW25dXTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgX19zZXRUZXh0Q29udGVudDogZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgdmFyIG4gPSBbXCJub2RlVmFsdWVcIiwgXCJ0ZXh0Q29udGVudFwiLCBcImlubmVyVGV4dFwiXSwgaSA9IDA7XG4gICAgICAgICAgICAgIGkgPCBuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRbbltpXV0gPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgICh0LmZuW25dID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlKCksXG4gICAgICAgICAgICAoaSA9IHQuZXh0ZW5kKCEwLCB7fSwgdFtuXS5kZWZhdWx0cywgaSkpLFxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0KHRoaXMpLmRhdGEobiwgbmV3IHRbbl0odCh0aGlzKSwgaSkuX2FwaSgpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB2YXIgcywgciwgbywgaDtcbiAgICB9XG4gIH0pKGpRdWVyeSk7XG4gIHJldHVybiB0cnVlO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnkuZG90ZG90ZG90L2Rpc3QvanF1ZXJ5LmRvdGRvdGRvdC5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBqcXVlcnktbWF0Y2gtaGVpZ2h0IG1hc3RlciBieSBAbGlhYnJ1XG4gKiBodHRwOi8vYnJtLmlvL2pxdWVyeS1tYXRjaC1oZWlnaHQvXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuXG4oZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCkge1xuICAvKlxuICAgICogIGludGVybmFsXG4gICAgKi9cblxuICB2YXIgX3ByZXZpb3VzUmVzaXplV2lkdGggPSAtMSxcbiAgICBfdXBkYXRlVGltZW91dCA9IC0xO1xuXG4gIC8qXG4gICAgKiAgX3BhcnNlXG4gICAgKiAgdmFsdWUgcGFyc2UgdXRpbGl0eSBmdW5jdGlvblxuICAgICovXG5cbiAgdmFyIF9wYXJzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gcGFyc2UgdmFsdWUgYW5kIGNvbnZlcnQgTmFOIHRvIDBcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcbiAgfTtcblxuICAvKlxuICAgICogIF9yb3dzXG4gICAgKiAgdXRpbGl0eSBmdW5jdGlvbiByZXR1cm5zIGFycmF5IG9mIGpRdWVyeSBzZWxlY3Rpb25zIHJlcHJlc2VudGluZyBlYWNoIHJvd1xuICAgICogIChhcyBkaXNwbGF5ZWQgYWZ0ZXIgZmxvYXQgd3JhcHBpbmcgYXBwbGllZCBieSBicm93c2VyKVxuICAgICovXG5cbiAgdmFyIF9yb3dzID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICB2YXIgdG9sZXJhbmNlID0gMSxcbiAgICAgICRlbGVtZW50cyA9ICQoZWxlbWVudHMpLFxuICAgICAgbGFzdFRvcCA9IG51bGwsXG4gICAgICByb3dzID0gW107XG5cbiAgICAvLyBncm91cCBlbGVtZW50cyBieSB0aGVpciB0b3AgcG9zaXRpb25cbiAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkdGhhdCA9ICQodGhpcyksXG4gICAgICAgIHRvcCA9ICR0aGF0Lm9mZnNldCgpLnRvcCAtIF9wYXJzZSgkdGhhdC5jc3MoXCJtYXJnaW4tdG9wXCIpKSxcbiAgICAgICAgbGFzdFJvdyA9IHJvd3MubGVuZ3RoID4gMCA/IHJvd3Nbcm93cy5sZW5ndGggLSAxXSA6IG51bGw7XG5cbiAgICAgIGlmIChsYXN0Um93ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGZpcnN0IGl0ZW0gb24gdGhlIHJvdywgc28ganVzdCBwdXNoIGl0XG4gICAgICAgIHJvd3MucHVzaCgkdGhhdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB0aGUgcm93IHRvcCBpcyB0aGUgc2FtZSwgYWRkIHRvIHRoZSByb3cgZ3JvdXBcbiAgICAgICAgaWYgKE1hdGguZmxvb3IoTWF0aC5hYnMobGFzdFRvcCAtIHRvcCkpIDw9IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHJvd3Nbcm93cy5sZW5ndGggLSAxXSA9IGxhc3RSb3cuYWRkKCR0aGF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugc3RhcnQgYSBuZXcgcm93IGdyb3VwXG4gICAgICAgICAgcm93cy5wdXNoKCR0aGF0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHJvdyB0b3BcbiAgICAgIGxhc3RUb3AgPSB0b3A7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcm93cztcbiAgfTtcblxuICAvKlxuICAgICogIF9wYXJzZU9wdGlvbnNcbiAgICAqICBoYW5kbGUgcGx1Z2luIG9wdGlvbnNcbiAgICAqL1xuXG4gIHZhciBfcGFyc2VPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgYnlSb3c6IHRydWUsXG4gICAgICBwcm9wZXJ0eTogXCJoZWlnaHRcIixcbiAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgIHJlbW92ZTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gJC5leHRlbmQob3B0cywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgICAgb3B0cy5ieVJvdyA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zID09PSBcInJlbW92ZVwiKSB7XG4gICAgICBvcHRzLnJlbW92ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdHM7XG4gIH07XG5cbiAgLypcbiAgICAqICBtYXRjaEhlaWdodFxuICAgICogIHBsdWdpbiBkZWZpbml0aW9uXG4gICAgKi9cblxuICB2YXIgbWF0Y2hIZWlnaHQgPSAoJC5mbi5tYXRjaEhlaWdodCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cyA9IF9wYXJzZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvLyBoYW5kbGUgcmVtb3ZlXG4gICAgaWYgKG9wdHMucmVtb3ZlKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIC8vIHJlbW92ZSBmaXhlZCBoZWlnaHQgZnJvbSBhbGwgc2VsZWN0ZWQgZWxlbWVudHNcbiAgICAgIHRoaXMuY3NzKG9wdHMucHJvcGVydHksIFwiXCIpO1xuXG4gICAgICAvLyByZW1vdmUgc2VsZWN0ZWQgZWxlbWVudHMgZnJvbSBhbGwgZ3JvdXBzXG4gICAgICAkLmVhY2gobWF0Y2hIZWlnaHQuX2dyb3VwcywgZnVuY3Rpb24oa2V5LCBncm91cCkge1xuICAgICAgICBncm91cC5lbGVtZW50cyA9IGdyb3VwLmVsZW1lbnRzLm5vdCh0aGF0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUT0RPOiBjbGVhbnVwIGVtcHR5IGdyb3Vwc1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gMSAmJiAhb3B0cy50YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhpcyBncm91cCBzbyB3ZSBjYW4gcmUtYXBwbHkgbGF0ZXIgb24gbG9hZCBhbmQgcmVzaXplIGV2ZW50c1xuICAgIG1hdGNoSGVpZ2h0Ll9ncm91cHMucHVzaCh7XG4gICAgICBlbGVtZW50czogdGhpcyxcbiAgICAgIG9wdGlvbnM6IG9wdHNcbiAgICB9KTtcblxuICAgIC8vIG1hdGNoIGVhY2ggZWxlbWVudCdzIGhlaWdodCB0byB0aGUgdGFsbGVzdCBlbGVtZW50IGluIHRoZSBzZWxlY3Rpb25cbiAgICBtYXRjaEhlaWdodC5fYXBwbHkodGhpcywgb3B0cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgLypcbiAgICAqICBwbHVnaW4gZ2xvYmFsIG9wdGlvbnNcbiAgICAqL1xuXG4gIG1hdGNoSGVpZ2h0LnZlcnNpb24gPSBcIm1hc3RlclwiO1xuICBtYXRjaEhlaWdodC5fZ3JvdXBzID0gW107XG4gIG1hdGNoSGVpZ2h0Ll90aHJvdHRsZSA9IDgwO1xuICBtYXRjaEhlaWdodC5fbWFpbnRhaW5TY3JvbGwgPSBmYWxzZTtcbiAgbWF0Y2hIZWlnaHQuX2JlZm9yZVVwZGF0ZSA9IG51bGw7XG4gIG1hdGNoSGVpZ2h0Ll9hZnRlclVwZGF0ZSA9IG51bGw7XG4gIG1hdGNoSGVpZ2h0Ll9yb3dzID0gX3Jvd3M7XG4gIG1hdGNoSGVpZ2h0Ll9wYXJzZSA9IF9wYXJzZTtcbiAgbWF0Y2hIZWlnaHQuX3BhcnNlT3B0aW9ucyA9IF9wYXJzZU9wdGlvbnM7XG5cbiAgLypcbiAgICAqICBtYXRjaEhlaWdodC5fYXBwbHlcbiAgICAqICBhcHBseSBtYXRjaEhlaWdodCB0byBnaXZlbiBlbGVtZW50c1xuICAgICovXG5cbiAgbWF0Y2hIZWlnaHQuX2FwcGx5ID0gZnVuY3Rpb24oZWxlbWVudHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cyA9IF9wYXJzZU9wdGlvbnMob3B0aW9ucyksXG4gICAgICAkZWxlbWVudHMgPSAkKGVsZW1lbnRzKSxcbiAgICAgIHJvd3MgPSBbJGVsZW1lbnRzXTtcblxuICAgIC8vIHRha2Ugbm90ZSBvZiBzY3JvbGwgcG9zaXRpb25cbiAgICB2YXIgc2Nyb2xsVG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpLFxuICAgICAgaHRtbEhlaWdodCA9ICQoXCJodG1sXCIpLm91dGVySGVpZ2h0KHRydWUpO1xuXG4gICAgLy8gZ2V0IGhpZGRlbiBwYXJlbnRzXG4gICAgdmFyICRoaWRkZW5QYXJlbnRzID0gJGVsZW1lbnRzLnBhcmVudHMoKS5maWx0ZXIoXCI6aGlkZGVuXCIpO1xuXG4gICAgLy8gY2FjaGUgdGhlIG9yaWdpbmFsIGlubGluZSBzdHlsZVxuICAgICRoaWRkZW5QYXJlbnRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgJHRoYXQgPSAkKHRoaXMpO1xuICAgICAgJHRoYXQuZGF0YShcInN0eWxlLWNhY2hlXCIsICR0aGF0LmF0dHIoXCJzdHlsZVwiKSk7XG4gICAgfSk7XG5cbiAgICAvLyB0ZW1wb3JhcmlseSBtdXN0IGZvcmNlIGhpZGRlbiBwYXJlbnRzIHZpc2libGVcbiAgICAkaGlkZGVuUGFyZW50cy5jc3MoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG5cbiAgICAvLyBnZXQgcm93cyBpZiB1c2luZyBieVJvdywgb3RoZXJ3aXNlIGFzc3VtZSBvbmUgcm93XG4gICAgaWYgKG9wdHMuYnlSb3cgJiYgIW9wdHMudGFyZ2V0KSB7XG4gICAgICAvLyBtdXN0IGZpcnN0IGZvcmNlIGFuIGFyYml0cmFyeSBlcXVhbCBoZWlnaHQgc28gZmxvYXRpbmcgZWxlbWVudHMgYnJlYWsgZXZlbmx5XG4gICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICR0aGF0ID0gJCh0aGlzKSxcbiAgICAgICAgICBkaXNwbGF5ID0gJHRoYXQuY3NzKFwiZGlzcGxheVwiKTtcblxuICAgICAgICAvLyB0ZW1wb3JhcmlseSBmb3JjZSBhIHVzYWJsZSBkaXNwbGF5IHZhbHVlXG4gICAgICAgIGlmIChcbiAgICAgICAgICBkaXNwbGF5ICE9PSBcImlubGluZS1ibG9ja1wiICYmXG4gICAgICAgICAgZGlzcGxheSAhPT0gXCJmbGV4XCIgJiZcbiAgICAgICAgICBkaXNwbGF5ICE9PSBcImlubGluZS1mbGV4XCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhY2hlIHRoZSBvcmlnaW5hbCBpbmxpbmUgc3R5bGVcbiAgICAgICAgJHRoYXQuZGF0YShcInN0eWxlLWNhY2hlXCIsICR0aGF0LmF0dHIoXCJzdHlsZVwiKSk7XG5cbiAgICAgICAgJHRoYXQuY3NzKHtcbiAgICAgICAgICBkaXNwbGF5OiBkaXNwbGF5LFxuICAgICAgICAgIFwicGFkZGluZy10b3BcIjogXCIwXCIsXG4gICAgICAgICAgXCJwYWRkaW5nLWJvdHRvbVwiOiBcIjBcIixcbiAgICAgICAgICBcIm1hcmdpbi10b3BcIjogXCIwXCIsXG4gICAgICAgICAgXCJtYXJnaW4tYm90dG9tXCI6IFwiMFwiLFxuICAgICAgICAgIFwiYm9yZGVyLXRvcC13aWR0aFwiOiBcIjBcIixcbiAgICAgICAgICBcImJvcmRlci1ib3R0b20td2lkdGhcIjogXCIwXCIsXG4gICAgICAgICAgaGVpZ2h0OiBcIjEwMHB4XCIsXG4gICAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZ2V0IHRoZSBhcnJheSBvZiByb3dzIChiYXNlZCBvbiBlbGVtZW50IHRvcCBwb3NpdGlvbilcbiAgICAgIHJvd3MgPSBfcm93cygkZWxlbWVudHMpO1xuXG4gICAgICAvLyByZXZlcnQgb3JpZ2luYWwgaW5saW5lIHN0eWxlc1xuICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciAkdGhhdCA9ICQodGhpcyk7XG4gICAgICAgICR0aGF0LmF0dHIoXCJzdHlsZVwiLCAkdGhhdC5kYXRhKFwic3R5bGUtY2FjaGVcIikgfHwgXCJcIik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAkLmVhY2gocm93cywgZnVuY3Rpb24oa2V5LCByb3cpIHtcbiAgICAgIHZhciAkcm93ID0gJChyb3cpLFxuICAgICAgICB0YXJnZXRIZWlnaHQgPSAwO1xuXG4gICAgICBpZiAoIW9wdHMudGFyZ2V0KSB7XG4gICAgICAgIC8vIHNraXAgYXBwbHkgdG8gcm93cyB3aXRoIG9ubHkgb25lIGl0ZW1cbiAgICAgICAgaWYgKG9wdHMuYnlSb3cgJiYgJHJvdy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICRyb3cuY3NzKG9wdHMucHJvcGVydHksIFwiXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhlIHJvdyBhbmQgZmluZCB0aGUgbWF4IGhlaWdodFxuICAgICAgICAkcm93LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyICR0aGF0ID0gJCh0aGlzKSxcbiAgICAgICAgICAgIHN0eWxlID0gJHRoYXQuYXR0cihcInN0eWxlXCIpLFxuICAgICAgICAgICAgZGlzcGxheSA9ICR0aGF0LmNzcyhcImRpc3BsYXlcIik7XG5cbiAgICAgICAgICAvLyB0ZW1wb3JhcmlseSBmb3JjZSBhIHVzYWJsZSBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZGlzcGxheSAhPT0gXCJpbmxpbmUtYmxvY2tcIiAmJlxuICAgICAgICAgICAgZGlzcGxheSAhPT0gXCJmbGV4XCIgJiZcbiAgICAgICAgICAgIGRpc3BsYXkgIT09IFwiaW5saW5lLWZsZXhcIlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlbnN1cmUgd2UgZ2V0IHRoZSBjb3JyZWN0IGFjdHVhbCBoZWlnaHQgKGFuZCBub3QgYSBwcmV2aW91c2x5IHNldCBoZWlnaHQgdmFsdWUpXG4gICAgICAgICAgdmFyIGNzcyA9IHsgZGlzcGxheTogZGlzcGxheSB9O1xuICAgICAgICAgIGNzc1tvcHRzLnByb3BlcnR5XSA9IFwiXCI7XG4gICAgICAgICAgJHRoYXQuY3NzKGNzcyk7XG5cbiAgICAgICAgICAvLyBmaW5kIHRoZSBtYXggaGVpZ2h0IChpbmNsdWRpbmcgcGFkZGluZywgYnV0IG5vdCBtYXJnaW4pXG4gICAgICAgICAgaWYgKCR0aGF0Lm91dGVySGVpZ2h0KGZhbHNlKSA+IHRhcmdldEhlaWdodCkge1xuICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gJHRoYXQub3V0ZXJIZWlnaHQoZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJldmVydCBzdHlsZXNcbiAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgICR0aGF0LmF0dHIoXCJzdHlsZVwiLCBzdHlsZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR0aGF0LmNzcyhcImRpc3BsYXlcIiwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHRhcmdldCBzZXQsIHVzZSB0aGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICB0YXJnZXRIZWlnaHQgPSBvcHRzLnRhcmdldC5vdXRlckhlaWdodChmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0ZXJhdGUgdGhlIHJvdyBhbmQgYXBwbHkgdGhlIGhlaWdodCB0byBhbGwgZWxlbWVudHNcbiAgICAgICRyb3cuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyICR0aGF0ID0gJCh0aGlzKSxcbiAgICAgICAgICB2ZXJ0aWNhbFBhZGRpbmcgPSAwO1xuXG4gICAgICAgIC8vIGRvbid0IGFwcGx5IHRvIGEgdGFyZ2V0XG4gICAgICAgIGlmIChvcHRzLnRhcmdldCAmJiAkdGhhdC5pcyhvcHRzLnRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgcGFkZGluZyBhbmQgYm9yZGVyIGNvcnJlY3RseSAocmVxdWlyZWQgd2hlbiBub3QgdXNpbmcgYm9yZGVyLWJveClcbiAgICAgICAgaWYgKCR0aGF0LmNzcyhcImJveC1zaXppbmdcIikgIT09IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgICAgICAgdmVydGljYWxQYWRkaW5nICs9XG4gICAgICAgICAgICBfcGFyc2UoJHRoYXQuY3NzKFwiYm9yZGVyLXRvcC13aWR0aFwiKSkgK1xuICAgICAgICAgICAgX3BhcnNlKCR0aGF0LmNzcyhcImJvcmRlci1ib3R0b20td2lkdGhcIikpO1xuICAgICAgICAgIHZlcnRpY2FsUGFkZGluZyArPVxuICAgICAgICAgICAgX3BhcnNlKCR0aGF0LmNzcyhcInBhZGRpbmctdG9wXCIpKSArXG4gICAgICAgICAgICBfcGFyc2UoJHRoYXQuY3NzKFwicGFkZGluZy1ib3R0b21cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBoZWlnaHQgKGFjY291bnRpbmcgZm9yIHBhZGRpbmcgYW5kIGJvcmRlcilcbiAgICAgICAgJHRoYXQuY3NzKG9wdHMucHJvcGVydHksIHRhcmdldEhlaWdodCAtIHZlcnRpY2FsUGFkZGluZyArIFwicHhcIik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIHJldmVydCBoaWRkZW4gcGFyZW50c1xuICAgICRoaWRkZW5QYXJlbnRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgJHRoYXQgPSAkKHRoaXMpO1xuICAgICAgJHRoYXQuYXR0cihcInN0eWxlXCIsICR0aGF0LmRhdGEoXCJzdHlsZS1jYWNoZVwiKSB8fCBudWxsKTtcbiAgICB9KTtcblxuICAgIC8vIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9uIGlmIGVuYWJsZWRcbiAgICBpZiAobWF0Y2hIZWlnaHQuX21haW50YWluU2Nyb2xsKSB7XG4gICAgICAkKHdpbmRvdykuc2Nyb2xsVG9wKHNjcm9sbFRvcCAvIGh0bWxIZWlnaHQgKiAkKFwiaHRtbFwiKS5vdXRlckhlaWdodCh0cnVlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLypcbiAgICAqICBtYXRjaEhlaWdodC5fYXBwbHlEYXRhQXBpXG4gICAgKiAgYXBwbGllcyBtYXRjaEhlaWdodCB0byBhbGwgZWxlbWVudHMgd2l0aCBhIGRhdGEtbWF0Y2gtaGVpZ2h0IGF0dHJpYnV0ZVxuICAgICovXG5cbiAgbWF0Y2hIZWlnaHQuX2FwcGx5RGF0YUFwaSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBncm91cHMgPSB7fTtcblxuICAgIC8vIGdlbmVyYXRlIGdyb3VwcyBieSB0aGVpciBncm91cElkIHNldCBieSBlbGVtZW50cyB1c2luZyBkYXRhLW1hdGNoLWhlaWdodFxuICAgICQoXCJbZGF0YS1tYXRjaC1oZWlnaHRdLCBbZGF0YS1taF1cIikuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgIGdyb3VwSWQgPSAkdGhpcy5hdHRyKFwiZGF0YS1taFwiKSB8fCAkdGhpcy5hdHRyKFwiZGF0YS1tYXRjaC1oZWlnaHRcIik7XG5cbiAgICAgIGlmIChncm91cElkIGluIGdyb3Vwcykge1xuICAgICAgICBncm91cHNbZ3JvdXBJZF0gPSBncm91cHNbZ3JvdXBJZF0uYWRkKCR0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyb3Vwc1tncm91cElkXSA9ICR0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgbWF0Y2hIZWlnaHQgdG8gZWFjaCBncm91cFxuICAgICQuZWFjaChncm91cHMsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5tYXRjaEhlaWdodCh0cnVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKlxuICAgICogIG1hdGNoSGVpZ2h0Ll91cGRhdGVcbiAgICAqICB1cGRhdGVzIG1hdGNoSGVpZ2h0IG9uIGFsbCBjdXJyZW50IGdyb3VwcyB3aXRoIHRoZWlyIGNvcnJlY3Qgb3B0aW9uc1xuICAgICovXG5cbiAgdmFyIF91cGRhdGUgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGlmIChtYXRjaEhlaWdodC5fYmVmb3JlVXBkYXRlKSB7XG4gICAgICBtYXRjaEhlaWdodC5fYmVmb3JlVXBkYXRlKGV2ZW50LCBtYXRjaEhlaWdodC5fZ3JvdXBzKTtcbiAgICB9XG5cbiAgICAkLmVhY2gobWF0Y2hIZWlnaHQuX2dyb3VwcywgZnVuY3Rpb24oKSB7XG4gICAgICBtYXRjaEhlaWdodC5fYXBwbHkodGhpcy5lbGVtZW50cywgdGhpcy5vcHRpb25zKTtcbiAgICB9KTtcblxuICAgIGlmIChtYXRjaEhlaWdodC5fYWZ0ZXJVcGRhdGUpIHtcbiAgICAgIG1hdGNoSGVpZ2h0Ll9hZnRlclVwZGF0ZShldmVudCwgbWF0Y2hIZWlnaHQuX2dyb3Vwcyk7XG4gICAgfVxuICB9O1xuXG4gIG1hdGNoSGVpZ2h0Ll91cGRhdGUgPSBmdW5jdGlvbih0aHJvdHRsZSwgZXZlbnQpIHtcbiAgICAvLyBwcmV2ZW50IHVwZGF0ZSBpZiBmaXJlZCBmcm9tIGEgcmVzaXplIGV2ZW50XG4gICAgLy8gd2hlcmUgdGhlIHZpZXdwb3J0IHdpZHRoIGhhc24ndCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgLy8gZml4ZXMgYW4gZXZlbnQgbG9vcGluZyBidWcgaW4gSUU4XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFwicmVzaXplXCIpIHtcbiAgICAgIHZhciB3aW5kb3dXaWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xuICAgICAgaWYgKHdpbmRvd1dpZHRoID09PSBfcHJldmlvdXNSZXNpemVXaWR0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfcHJldmlvdXNSZXNpemVXaWR0aCA9IHdpbmRvd1dpZHRoO1xuICAgIH1cblxuICAgIC8vIHRocm90dGxlIHVwZGF0ZXNcbiAgICBpZiAoIXRocm90dGxlKSB7XG4gICAgICBfdXBkYXRlKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKF91cGRhdGVUaW1lb3V0ID09PSAtMSkge1xuICAgICAgX3VwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdXBkYXRlKGV2ZW50KTtcbiAgICAgICAgX3VwZGF0ZVRpbWVvdXQgPSAtMTtcbiAgICAgIH0sIG1hdGNoSGVpZ2h0Ll90aHJvdHRsZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAgKiAgYmluZCBldmVudHNcbiAgICAqL1xuXG4gIC8vIGFwcGx5IG9uIERPTSByZWFkeSBldmVudFxuICAkKG1hdGNoSGVpZ2h0Ll9hcHBseURhdGFBcGkpO1xuXG4gIC8vIHVwZGF0ZSBoZWlnaHRzIG9uIGxvYWQgYW5kIHJlc2l6ZSBldmVudHNcbiAgJCh3aW5kb3cpLmJpbmQoXCJsb2FkXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgbWF0Y2hIZWlnaHQuX3VwZGF0ZShmYWxzZSwgZXZlbnQpO1xuICB9KTtcblxuICAvLyB0aHJvdHRsZWQgdXBkYXRlIGhlaWdodHMgb24gcmVzaXplIGV2ZW50c1xuICAkKHdpbmRvdykuYmluZChcInJlc2l6ZSBvcmllbnRhdGlvbmNoYW5nZVwiLCBmdW5jdGlvbihldmVudCkge1xuICAgIG1hdGNoSGVpZ2h0Ll91cGRhdGUodHJ1ZSwgZXZlbnQpO1xuICB9KTtcbn0pKGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnktbWF0Y2gtaGVpZ2h0LWJyb3dzZXJpZnkvanF1ZXJ5Lm1hdGNoSGVpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIExvYWQgc3ZnIHZpYSBhamF4XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCBwYXRoIHRvIHN2ZyBzcHJpdGVcbiAqIEBnZW5lcmF0b3I6IHdlYnBhY2stc3Znc3RvcmUtcGx1Z2luXG4gKiBAc2VlOiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS93ZWJwYWNrLXN2Z3N0b3JlLXBsdWdpblxuICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG52YXIgc3ZnWEhSID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgdXJsID0gZmFsc2U7XG4gIHZhciBiYXNlVXJsID0gdW5kZWZpbmVkO1xuXG4gIG9wdGlvbnMgJiYgb3B0aW9ucy5maWxlbmFtZSA/ICh1cmwgPSBvcHRpb25zLmZpbGVuYW1lKSA6IG51bGw7XG5cbiAgaWYgKCF1cmwpIHJldHVybiBmYWxzZTtcbiAgdmFyIF9hamF4ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHZhciBfZnVsbFBhdGg7XG5cbiAgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIF9hamF4ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJhc2VVcmwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5iYXNlVXJsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBiYXNlVXJsID0gd2luZG93LmJhc2VVcmw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VVcmwgPVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgK1xuICAgICAgICBcIi8vXCIgK1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgK1xuICAgICAgICAod2luZG93LmxvY2F0aW9uLnBvcnQgPyBcIjpcIiArIHdpbmRvdy5sb2NhdGlvbi5wb3J0IDogXCJcIik7XG4gICAgfVxuICB9XG5cbiAgX2Z1bGxQYXRoID0gKGJhc2VVcmwgKyBcIi9cIiArIHVybCkucmVwbGFjZSgvKFteOl1cXC8pXFwvKy9nLCBcIiQxXCIpO1xuICBfYWpheC5vcGVuKFwiR0VUXCIsIF9mdWxsUGF0aCwgdHJ1ZSk7XG4gIF9hamF4Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHt9O1xuICBfYWpheC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIV9hamF4LnJlc3BvbnNlVGV4dCB8fCBfYWpheC5yZXNwb25zZVRleHQuc3Vic3RyKDAsIDQpICE9PSBcIjxzdmdcIikge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIFNWRyBSZXNwb25zZVwiKTtcbiAgICB9XG4gICAgaWYgKF9hamF4LnN0YXR1cyA8IDIwMCB8fCBfYWpheC5zdGF0dXMgPj0gMzAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5pbm5lckhUTUwgPSBfYWpheC5yZXNwb25zZVRleHQ7XG4gICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoZGl2LCBkb2N1bWVudC5ib2R5LmNoaWxkTm9kZXNbMF0pO1xuICB9O1xuICBfYWpheC5zZW5kKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN2Z1hIUjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zdmdzdG9yZS1wbHVnaW4vc3JjL2hlbHBlcnMvc3ZneGhyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9